
AVRASM ver. 2.1.43  TankDemo.asm Tue May 24 15:28:25 2011

TankDemo.asm(24): +--------------------+
TankDemo.asm(26): |  Info: Release...  |
TankDemo.asm(31): +--------------------+
TankDemo.asm(36): +-------------
TankDemo.asm(37): | TIME FORMAT: "2011-05-24" "15:28"
TankDemo.asm(38): +----------------
TankDemo.asm(48): Including file 'TankDemo.inc'
TankDemo.inc(34): Including file 'C:\RadASM\AVR\Include\m64def.inc'
TankDemo.inc(142): Including file 'MacroEX.asm'
TankDemo.inc(143): Including file 'DataRAM.inc'
TankDemo.asm(49): Including file 'IntVector.inc'
TankDemo.asm(57): Including file 'Delays.asm'
TankDemo.asm(59): Including file 'Interrupt.inc'
TankDemo.asm(61): Including file 'IntRoutines.asm'
TankDemo.asm(67): Including file 'RTOSA/RTOSA.inc'
RTOSA/RTOSA.inc(11): Including file 'RTOSA\TimerCntrs.inc'
RTOSA/RTOSA.inc(304): PreDiv for ATmega8
TankDemo.asm(69): Including file 'ADC.inc'
TankDemo.asm(70): Including file 'KBD_3x1.inc'
KBD_3x1.inc(33): Including file 'KBD_3x1.asm'
TankDemo.asm(71): Including file 'NCod.inc'
NCod.inc(19): Including file 'NCod.asm'
TankDemo.asm(72): Including file 'Drive.asm'
TankDemo.asm(73): Including file 'LCD_uni.inc'
LCD_uni.inc(270): Including file 'LCD_uni.asm'
TankDemo.asm(74): Including file 'Soft_RTC.inc'
Soft_RTC.inc(15): Including file 'Soft_RTC.asm'
TankDemo.asm(1723): Including file 'EEPROM.ASM'
TankDemo.asm(1725): Including file 'RTOSA/RTOSA.asm'
RTOSA/RTOSA.asm(375): Including file 'RTOSA/Debug.asm'
TankDemo.asm(1726): Including file 'ServoHXT900.inc'
TankDemo.asm(1727): Including file 'Melody.asm'
TankDemo.asm(1728): Including file 'InfraRedControl.inc'
TankDemo.asm(1729): Including file 'BCD_Math.asm'
TankDemo.asm(1870): Including file 'Songs.inc'
TankDemo.asm(1871): Including file 'MoveLists.inc'
TankDemo.asm(2004): Including file 'LCD_RecodeTable.asm'
TankDemo.asm(2005): +--------------------+
TankDemo.asm(2007): |  Info: Release...  |
TankDemo.asm(2011): +--------------------+
                 
                 
                 ;Updated: "2011-03-07" "19:41"
                 
                 ;###############################################################################
                 #pragma warning range byte overflow
                 #pragma overlap error
                 ;###############################################################################
                 
                 ;.equ DEBUG   = 1
                 
                 ; ! ! ! ! ! ! ! ! ! !! ВНИМАНИЕ ! ! ATTENTION !  ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! !
                 ; ! ! ! ! ! ! ! ! ! !! ВНИМАНИЕ ! ! ATTENTION !  ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! !
                 ;4,OT,"$b\avrasm2143" -fI -vs -v2 -I"$I" -c -o"$3" -l"$4" -d"$2" -e"$5" -m"$7" -FD"%Y-%m-%d" -FT"%H:%M" ,1
                 ; !!! avrasm2143 - установить совместимость с Windows 98
                 ; !!! avrasm2143 - поменять на другую если выдает ошибки потери определений
                 ; Искать тут
                 ;   \RadASM\AVR\Bin\avrasm2143.exe
                 ; Например: YH - определена, но ... что за ф..ня ?!?!?!?
                 ;   MacroEX.asm(22): error: Invalid symbol in this context: YH(11)
                 
                 ; ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! !
                 
                 ;###############################################################################
                   #message "+--------------------+"
                 #ifndef DBG
                   #message "|  Info: Release...  |"
                 #else
                 #endif
                   #message "+--------------------+"
                 ;###############################################################################
                 
                 
                 ;###############################################################################
                   #message "+-------------"
                   #message "| TIME FORMAT:" __DATE__ __TIME__
                   #message "+----------------"
                 ;###############################################################################
                 
                 .equ  PROTEUS   = 1
                 
                 ;###############################################################################
                 
                 ;###############################################################################
                 ;######################### Include Files #######################################
                 ;###############################################################################
                 .include  "TankDemo.inc"  ;
                 
                 ;Updated: "2011-03-07" "19:41"
                 ;72 - звена на гусеницу
                 ;5.08 шаг звена
                 ;73* 5.08 = 370.84 mm длина гусеницы
                 ;73.66 = 29*2.54 ширина
                 ;
                 
                 #define tdLenFM     83000 ;um длина стрелы
                 #define tdRotate   150000 ;um длина от центра до датчика монеты
                 #define tdWidth   29*2540 ;um ширина гусенец
                 #define tdLength  73*2540 ;um 
                 #define tdStep       2540 ;um 2 pulse
                 #define PI         3.1415
                 
                 .equ  TMONET  = 614   ;Value for 1grn = 614 - значение монеты
                 .equ  FLAMP   = 50    ;Flash frequency [Hz] частота лампы
                 .equ  GNDMIN  = 128   ;Low level for GND sensor уровень черного
                 .equ  GMDMAX  = 255   ;High level for GND sensor 
                 
                 #define	Alf			50    ; угол размаха стрелы
                 #define	TIMEOUT	 5*60 ;[сек] Время нахождения на поле. После рвем когти на финиш
                 
                 
                 #define degT      *2*PI*tdWidth /(tdStep*360)
                 #define degTM     *2*PI*tdWidth*tdLenFM /(tdStep*360*tdRotate)
                 
                 
                 #define mm  *1000/tdStep
                 #define um  *1/tdStep
                 
                 ;
                 ;###############################################################################
                 .include  "m64def.inc"    ;Include the specific headers file for MCU
                 
                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega64.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m64def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega64
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega64
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M64DEF_INC_
                 #define _M64DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega64
                 #pragma AVRPART ADMIN PART_NAME ATmega64
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x96
                 .equ	SIGNATURE_002	= 0x02
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	UCSR1C	= 0x9d	; MEMORY MAPPED
                 .equ	UDR1	= 0x9c	; MEMORY MAPPED
                 .equ	UCSR1A	= 0x9b	; MEMORY MAPPED
                 .equ	UCSR1B	= 0x9a	; MEMORY MAPPED
                 .equ	UBRR1H	= 0x98	; MEMORY MAPPED
                 .equ	UBRR1L	= 0x99	; MEMORY MAPPED
                 .equ	UCSR0C	= 0x95	; MEMORY MAPPED
                 .equ	UBRR0H	= 0x90	; MEMORY MAPPED
                 .equ	ADCSRB	= 0x8e	; MEMORY MAPPED
                 .equ	TCCR3C	= 0x8c	; MEMORY MAPPED
                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                 .equ	OCR3CL	= 0x82	; MEMORY MAPPED
                 .equ	OCR3CH	= 0x83	; MEMORY MAPPED
                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                 .equ	TCCR1C	= 0x7a	; MEMORY MAPPED
                 .equ	OCR1CL	= 0x78	; MEMORY MAPPED
                 .equ	OCR1CH	= 0x79	; MEMORY MAPPED
                 .equ	TWCR	= 0x74	; MEMORY MAPPED
                 .equ	TWDR	= 0x73	; MEMORY MAPPED
                 .equ	TWAR	= 0x72	; MEMORY MAPPED
                 .equ	TWSR	= 0x71	; MEMORY MAPPED
                 .equ	TWBR	= 0x70	; MEMORY MAPPED
                 .equ	OSCCAL	= 0x6f	; MEMORY MAPPED
                 .equ	XMCRA	= 0x6d	; MEMORY MAPPED
                 .equ	XMCRB	= 0x6c	; MEMORY MAPPED
                 .equ	EICRA	= 0x6a	; MEMORY MAPPED
                 .equ	SPMCSR	= 0x68	; MEMORY MAPPED
                 .equ	PORTG	= 0x65	; MEMORY MAPPED
                 .equ	DDRG	= 0x64	; MEMORY MAPPED
                 .equ	PING	= 0x63	; MEMORY MAPPED
                 .equ	PORTF	= 0x62	; MEMORY MAPPED
                 .equ	DDRF	= 0x61	; MEMORY MAPPED
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	XDIV	= 0x3c
                 .equ	EICRB	= 0x3a
                 .equ	EIMSK	= 0x39
                 .equ	EIFR	= 0x38
                 .equ	TIMSK	= 0x37
                 .equ	TIFR	= 0x36
                 .equ	MCUCR	= 0x35
                 .equ	MCUCSR	= 0x34
                 .equ	TCCR0	= 0x33
                 .equ	TCNT0	= 0x32
                 .equ	OCR0	= 0x31
                 .equ	ASSR	= 0x30
                 .equ	TCCR1A	= 0x2f
                 .equ	TCCR1B	= 0x2e
                 .equ	TCNT1L	= 0x2c
                 .equ	TCNT1H	= 0x2d
                 .equ	OCR1AL	= 0x2a
                 .equ	OCR1AH	= 0x2b
                 .equ	OCR1BL	= 0x28
                 .equ	OCR1BH	= 0x29
                 .equ	ICR1L	= 0x26
                 .equ	ICR1H	= 0x27
                 .equ	TCCR2	= 0x25
                 .equ	TCNT2	= 0x24
                 .equ	OCR2	= 0x23
                 .equ	OCDR	= 0x22
                 .equ	WDTCR	= 0x21
                 .equ	SFIOR	= 0x20
                 .equ	EEARL	= 0x1e
                 .equ	EEARH	= 0x1f
                 .equ	EEDR	= 0x1d
                 .equ	EECR	= 0x1c
                 .equ	PORTA	= 0x1b
                 .equ	DDRA	= 0x1a
                 .equ	PINA	= 0x19
                 .equ	PORTB	= 0x18
                 .equ	DDRB	= 0x17
                 .equ	PINB	= 0x16
                 .equ	PORTC	= 0x15
                 .equ	DDRC	= 0x14
                 .equ	PINC	= 0x13
                 .equ	PORTD	= 0x12
                 .equ	DDRD	= 0x11
                 .equ	PIND	= 0x10
                 .equ	SPDR	= 0x0f
                 .equ	SPSR	= 0x0e
                 .equ	SPCR	= 0x0d
                 .equ	UDR0	= 0x0c
                 .equ	UCSR0A	= 0x0b
                 .equ	UCSR0B	= 0x0a
                 .equ	UBRR0L	= 0x09
                 .equ	ACSR	= 0x08
                 .equ	ADMUX	= 0x07
                 .equ	ADCSRA	= 0x06
                 .equ	ADCH	= 0x05
                 .equ	ADCL	= 0x04
                 .equ	PORTE	= 0x03
                 .equ	DDRE	= 0x02
                 .equ	PINE	= 0x01
                 .equ	PINF	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; SFIOR - Special Function IO Register
                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register A
                 .equ	ADCSR	= ADCSRA	; For compatibility
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                 .equ	ADFR	= ADATE	; For compatibility
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; ADCSRB - The ADC Control and Status register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** TWI **************************
                 ; TWBR - TWI Bit Rate register
                 .equ	I2BR	= TWBR	; For compatibility
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	I2CR	= TWCR	; For compatibility
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	I2IE	= TWIE	; For compatibility
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	I2EN	= TWEN	; For compatibility
                 .equ	ENI2C	= TWEN	; For compatibility
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	I2WC	= TWWC	; For compatibility
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	I2STO	= TWSTO	; For compatibility
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	I2STA	= TWSTA	; For compatibility
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	I2EA	= TWEA	; For compatibility
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 .equ	I2INT	= TWINT	; For compatibility
                 
                 ; TWSR - TWI Status Register
                 .equ	I2SR	= TWSR	; For compatibility
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWS0	= TWPS0	; For compatibility
                 .equ	I2GCE	= TWPS0	; For compatibility
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS1	= TWPS1	; For compatibility
                 .equ	TWS3	= 3	; TWI Status
                 .equ	I2S3	= TWS3	; For compatibility
                 .equ	TWS4	= 4	; TWI Status
                 .equ	I2S4	= TWS4	; For compatibility
                 .equ	TWS5	= 5	; TWI Status
                 .equ	I2S5	= TWS5	; For compatibility
                 .equ	TWS6	= 6	; TWI Status
                 .equ	I2S6	= TWS6	; For compatibility
                 .equ	TWS7	= 7	; TWI Status
                 .equ	I2S7	= TWS7	; For compatibility
                 
                 ; TWDR - TWI Data register
                 .equ	I2DR	= TWDR	; For compatibility
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	I2AR	= TWAR	; For compatibility
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** USART0 ***********************
                 ; UDR0 - USART I/O Data Register
                 .equ	UDR00	= 0	; USART I/O Data Register bit 0
                 .equ	UDR01	= 1	; USART I/O Data Register bit 1
                 .equ	UDR02	= 2	; USART I/O Data Register bit 2
                 .equ	UDR03	= 3	; USART I/O Data Register bit 3
                 .equ	UDR04	= 4	; USART I/O Data Register bit 4
                 .equ	UDR05	= 5	; USART I/O Data Register bit 5
                 .equ	UDR06	= 6	; USART I/O Data Register bit 6
                 .equ	UDR07	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR0A - USART Control and Status Register A
                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                 .equ	U2X0	= 1	; Double the USART transmission speed
                 .equ	UPE0	= 2	; Parity Error
                 .equ	DOR0	= 3	; Data overRun
                 .equ	FE0	= 4	; Framing Error
                 .equ	UDRE0	= 5	; USART Data Register Empty
                 .equ	TXC0	= 6	; USART Transmitt Complete
                 .equ	RXC0	= 7	; USART Receive Complete
                 
                 ; UCSR0B - USART Control and Status Register B
                 .equ	TXB80	= 0	; Transmit Data Bit 8
                 .equ	RXB80	= 1	; Receive Data Bit 8
                 .equ	UCSZ02	= 2	; Character Size
                 .equ	UCSZ2	= UCSZ02	; For compatibility
                 .equ	TXEN0	= 3	; Transmitter Enable
                 .equ	RXEN0	= 4	; Receiver Enable
                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR0C - USART Control and Status Register C
                 .equ	UCPOL0	= 0	; Clock Polarity
                 .equ	UCSZ00	= 1	; Character Size
                 .equ	UCSZ01	= 2	; Character Size
                 .equ	USBS0	= 3	; Stop Bit Select
                 .equ	UPM00	= 4	; Parity Mode Bit 0
                 .equ	UPM01	= 5	; Parity Mode Bit 1
                 .equ	UMSEL0	= 6	; USART Mode Select
                 
                 ; UBRR0H - USART Baud Rate Register Hight Byte
                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR0L - USART Baud Rate Register Low Byte
                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** USART1 ***********************
                 ; UDR1 - USART I/O Data Register
                 .equ	UDR10	= 0	; USART I/O Data Register bit 0
                 .equ	UDR11	= 1	; USART I/O Data Register bit 1
                 .equ	UDR12	= 2	; USART I/O Data Register bit 2
                 .equ	UDR13	= 3	; USART I/O Data Register bit 3
                 .equ	UDR14	= 4	; USART I/O Data Register bit 4
                 .equ	UDR15	= 5	; USART I/O Data Register bit 5
                 .equ	UDR16	= 6	; USART I/O Data Register bit 6
                 .equ	UDR17	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR1A - USART Control and Status Register A
                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                 .equ	U2X1	= 1	; Double the USART transmission speed
                 .equ	UPE1	= 2	; Parity Error
                 .equ	DOR1	= 3	; Data overRun
                 .equ	FE1	= 4	; Framing Error
                 .equ	UDRE1	= 5	; USART Data Register Empty
                 .equ	TXC1	= 6	; USART Transmitt Complete
                 .equ	RXC1	= 7	; USART Receive Complete
                 
                 ; UCSR1B - USART Control and Status Register B
                 .equ	TXB81	= 0	; Transmit Data Bit 8
                 .equ	RXB81	= 1	; Receive Data Bit 8
                 .equ	UCSZ12	= 2	; Character Size
                 .equ	TXEN1	= 3	; Transmitter Enable
                 .equ	RXEN1	= 4	; Receiver Enable
                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR1C - USART Control and Status Register C
                 .equ	UCPOL1	= 0	; Clock Polarity
                 .equ	UCSZ10	= 1	; Character Size
                 .equ	UCSZ11	= 2	; Character Size
                 .equ	USBS1	= 3	; Stop Bit Select
                 .equ	UPM10	= 4	; Parity Mode Bit 0
                 .equ	UPM11	= 5	; Parity Mode Bit 1
                 .equ	UMSEL1	= 6	; USART Mode Select
                 
                 ; UBRR1H - USART Baud Rate Register Hight Byte
                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR1L - USART Baud Rate Register Low Byte
                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                 .equ	IVSEL	= 1	; Interrupt Vector Select
                 .equ	SM2	= 2	; Sleep Mode Select
                 .equ	SM0	= 3	; Sleep Mode Select
                 .equ	SM1	= 4	; Sleep Mode Select
                 .equ	SE	= 5	; Sleep Enable
                 .equ	SRW10	= 6	; External SRAM Wait State Select
                 .equ	SRE	= 7	; External SRAM Enable
                 
                 ; XMCRA - External Memory Control Register A
                 .equ	SRW11	= 1	; Wait state select bit upper page
                 .equ	SRW00	= 2	; Wait state select bit lower page
                 .equ	SRW01	= 3	; Wait state select bit lower page
                 .equ	SRL0	= 4	; Wait state page limit
                 .equ	SRL1	= 5	; Wait state page limit
                 .equ	SRL2	= 6	; Wait state page limit
                 
                 ; XMCRB - External Memory Control Register B
                 .equ	XMM0	= 0	; External Memory High Mask
                 .equ	XMM1	= 1	; External Memory High Mask
                 .equ	XMM2	= 2	; External Memory High Mask
                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value
                 .equ	CAL1	= 1	; Oscillator Calibration Value
                 .equ	CAL2	= 2	; Oscillator Calibration Value
                 .equ	CAL3	= 3	; Oscillator Calibration Value
                 .equ	CAL4	= 4	; Oscillator Calibration Value
                 .equ	CAL5	= 5	; Oscillator Calibration Value
                 .equ	CAL6	= 6	; Oscillator Calibration Value
                 .equ	CAL7	= 7	; Oscillator Calibration Value
                 
                 ; XDIV - XTAL Divide Control Register
                 .equ	XDIV0	= 0	; XTAl Divide Select Bit 0
                 .equ	XDIV1	= 1	; XTAl Divide Select Bit 1
                 .equ	XDIV2	= 2	; XTAl Divide Select Bit 2
                 .equ	XDIV3	= 3	; XTAl Divide Select Bit 3
                 .equ	XDIV4	= 4	; XTAl Divide Select Bit 4
                 .equ	XDIV5	= 5	; XTAl Divide Select Bit 5
                 .equ	XDIV6	= 6	; XTAl Divide Select Bit 6
                 .equ	XDIVEN	= 7	; XTAL Divide Enable
                 
                 ; MCUCSR - MCU Control And Status Register
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 .equ	JTRF	= 4	; JTAG Reset Flag
                 .equ	JTD	= 7	; JTAG Interface Disable
                 
                 
                 ; ***** BOOT_LOAD ********************
                 ; SPMCSR - Store Program Memory Control Register
                 .equ	SPMCR	= SPMCSR	; For compatibility
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read While Write section read enable
                 .equ	ASRE	= RWWSRE	; For compatibility
                 .equ	RWWSB	= 6	; Read While Write Section Busy
                 .equ	ASB	= RWWSB	; For compatibility
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 
                 ; ***** JTAG *************************
                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                 .equ	IDRD	= OCDR7	; For compatibility
                 
                 ; MCUCSR - MCU Control And Status Register
                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                 ;.equ	JTD	= 7	; JTAG Interface Disable
                 
                 
                 ; ***** MISC *************************
                 ; SFIOR - Special Function IO Register
                 .equ	PSR321	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1
                 .equ	PSR1	= PSR321	; For compatibility
                 .equ	PSR2	= PSR321	; For compatibility
                 .equ	PSR3	= PSR321	; For compatibility
                 .equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                 .equ	PUD	= 2	; Pull Up Disable
                 ;.equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; EICRA - External Interrupt Control Register A
                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                 
                 ; EICRB - External Interrupt Control Register B
                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                 
                 ; EIMSK - External Interrupt Mask Register
                 .equ	GICR	= EIMSK	; For compatibility
                 .equ	GIMSK	= EIMSK	; For compatibility
                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                 
                 ; EIFR - External Interrupt Flag Register
                 .equ	GIFR	= EIFR	; For compatibility
                 .equ	INTF0	= 0	; External Interrupt Flag 0
                 .equ	INTF1	= 1	; External Interrupt Flag 1
                 .equ	INTF2	= 2	; External Interrupt Flag 2
                 .equ	INTF3	= 3	; External Interrupt Flag 3
                 .equ	INTF4	= 4	; External Interrupt Flag 4
                 .equ	INTF5	= 5	; External Interrupt Flag 5
                 .equ	INTF6	= 6	; External Interrupt Flag 6
                 .equ	INTF7	= 7	; External Interrupt Flag 7
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEWE	= 1	; EEPROM Write Enable
                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 
                 
                 ; ***** PORTA ************************
                 ; PORTA - Port A Data Register
                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                 .equ	PA0	= 0	; For compatibility
                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                 .equ	PA1	= 1	; For compatibility
                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                 .equ	PA2	= 2	; For compatibility
                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                 .equ	PA3	= 3	; For compatibility
                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                 .equ	PA4	= 4	; For compatibility
                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                 .equ	PA5	= 5	; For compatibility
                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                 .equ	PA6	= 6	; For compatibility
                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                 .equ	PA7	= 7	; For compatibility
                 
                 ; DDRA - Port A Data Direction Register
                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                 
                 ; PINA - Port A Input Pins
                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                 .equ	PC7	= 7	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** PORTE ************************
                 ; PORTE - Data Register, Port E
                 .equ	PORTE0	= 0	; 
                 .equ	PE0	= 0	; For compatibility
                 .equ	PORTE1	= 1	; 
                 .equ	PE1	= 1	; For compatibility
                 .equ	PORTE2	= 2	; 
                 .equ	PE2	= 2	; For compatibility
                 .equ	PORTE3	= 3	; 
                 .equ	PE3	= 3	; For compatibility
                 .equ	PORTE4	= 4	; 
                 .equ	PE4	= 4	; For compatibility
                 .equ	PORTE5	= 5	; 
                 .equ	PE5	= 5	; For compatibility
                 .equ	PORTE6	= 6	; 
                 .equ	PE6	= 6	; For compatibility
                 .equ	PORTE7	= 7	; 
                 .equ	PE7	= 7	; For compatibility
                 
                 ; DDRE - Data Direction Register, Port E
                 .equ	DDE0	= 0	; 
                 .equ	DDE1	= 1	; 
                 .equ	DDE2	= 2	; 
                 .equ	DDE3	= 3	; 
                 .equ	DDE4	= 4	; 
                 .equ	DDE5	= 5	; 
                 .equ	DDE6	= 6	; 
                 .equ	DDE7	= 7	; 
                 
                 ; PINE - Input Pins, Port E
                 .equ	PINE0	= 0	; 
                 .equ	PINE1	= 1	; 
                 .equ	PINE2	= 2	; 
                 .equ	PINE3	= 3	; 
                 .equ	PINE4	= 4	; 
                 .equ	PINE5	= 5	; 
                 .equ	PINE6	= 6	; 
                 .equ	PINE7	= 7	; 
                 
                 
                 ; ***** PORTF ************************
                 ; PORTF - Data Register, Port F
                 .equ	PORTF0	= 0	; 
                 .equ	PF0	= 0	; For compatibility
                 .equ	PORTF1	= 1	; 
                 .equ	PF1	= 1	; For compatibility
                 .equ	PORTF2	= 2	; 
                 .equ	PF2	= 2	; For compatibility
                 .equ	PORTF3	= 3	; 
                 .equ	PF3	= 3	; For compatibility
                 .equ	PORTF4	= 4	; 
                 .equ	PF4	= 4	; For compatibility
                 .equ	PORTF5	= 5	; 
                 .equ	PF5	= 5	; For compatibility
                 .equ	PORTF6	= 6	; 
                 .equ	PF6	= 6	; For compatibility
                 .equ	PORTF7	= 7	; 
                 .equ	PF7	= 7	; For compatibility
                 
                 ; DDRF - Data Direction Register, Port F
                 .equ	DDF0	= 0	; 
                 .equ	DDF1	= 1	; 
                 .equ	DDF2	= 2	; 
                 .equ	DDF3	= 3	; 
                 .equ	DDF4	= 4	; 
                 .equ	DDF5	= 5	; 
                 .equ	DDF6	= 6	; 
                 .equ	DDF7	= 7	; 
                 
                 ; PINF - Input Pins, Port F
                 .equ	PINF0	= 0	; 
                 .equ	PINF1	= 1	; 
                 .equ	PINF2	= 2	; 
                 .equ	PINF3	= 3	; 
                 .equ	PINF4	= 4	; 
                 .equ	PINF5	= 5	; 
                 .equ	PINF6	= 6	; 
                 .equ	PINF7	= 7	; 
                 
                 
                 ; ***** PORTG ************************
                 ; PORTG - Data Register, Port G
                 .equ	PORTG0	= 0	; 
                 .equ	PG0	= 0	; For compatibility
                 .equ	PORTG1	= 1	; 
                 .equ	PG1	= 1	; For compatibility
                 .equ	PORTG2	= 2	; 
                 .equ	PG2	= 2	; For compatibility
                 .equ	PORTG3	= 3	; 
                 .equ	PG3	= 3	; For compatibility
                 .equ	PORTG4	= 4	; 
                 .equ	PG4	= 4	; For compatibility
                 
                 ; DDRG - Data Direction Register, Port G
                 .equ	DDG0	= 0	; 
                 .equ	DDG1	= 1	; 
                 .equ	DDG2	= 2	; 
                 .equ	DDG3	= 3	; 
                 .equ	DDG4	= 4	; 
                 
                 ; PING - Input Pins, Port G
                 .equ	PING0	= 0	; 
                 .equ	PING1	= 1	; 
                 .equ	PING2	= 2	; 
                 .equ	PING3	= 3	; 
                 .equ	PING4	= 4	; 
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TCCR0 - Timer/Counter Control Register
                 .equ	CS00	= 0	; Clock Select 0
                 .equ	CS01	= 1	; Clock Select 1
                 .equ	CS02	= 2	; Clock Select 2
                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                 .equ	CTC0	= WGM01	; For compatibility
                 .equ	COM00	= 4	; Compare match Output Mode 0
                 .equ	COM01	= 5	; Compare Match Output Mode 1
                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                 .equ	PWM0	= WGM00	; For compatibility
                 .equ	FOC0	= 7	; Force Output Compare
                 
                 ; TCNT0 - Timer/Counter Register
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0 - Output Compare Register
                 .equ	OCR0_0	= 0	; 
                 .equ	OCR0_1	= 1	; 
                 .equ	OCR0_2	= 2	; 
                 .equ	OCR0_3	= 3	; 
                 .equ	OCR0_4	= 4	; 
                 .equ	OCR0_5	= 5	; 
                 .equ	OCR0_6	= 6	; 
                 .equ	OCR0_7	= 7	; 
                 
                 ; ASSR - Asynchronus Status Register
                 .equ	TCR0UB	= 0	; Timer/Counter Control Register 0 Update Busy
                 .equ	OCR0UB	= 1	; Output Compare register 0 Busy
                 .equ	TCN0UB	= 2	; Timer/Counter0 Update Busy
                 .equ	AS0	= 3	; Asynchronus Timer/Counter 0
                 
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0	= 1	; Output Compare Flag 0
                 
                 ; SFIOR - Special Function IO Register
                 ;.equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                 .equ	OCIE1C	= 0	; Timer/Counter 1, Output Compare Match C Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                 .equ	OCF1C	= 0	; Timer/Counter 1, Output Compare C Match Flag
                 
                 ; SFIOR - Special Function IO Register
                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                 .equ	PWM10	= WGM10	; For compatibility
                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                 .equ	PWM11	= WGM11	; For compatibility
                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Clock Select bit 0
                 .equ	CS11	= 1	; Clock Select 1 bit 1
                 .equ	CS12	= 2	; Clock Select1 bit 2
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	CTC10	= WGM12	; For compatibility
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	CTC11	= WGM13	; For compatibility
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 ; TCCR1C - Timer/Counter1 Control Register C
                 .equ	FOC1C	= 5	; Force Output Compare for channel C
                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TCCR2 - Timer/Counter Control Register
                 .equ	CS20	= 0	; Clock Select
                 .equ	CS21	= 1	; Clock Select
                 .equ	CS22	= 2	; Clock Select
                 .equ	WGM21	= 3	; Waveform Generation Mode
                 .equ	CTC2	= WGM21	; For compatibility
                 .equ	COM20	= 4	; Compare Match Output Mode
                 .equ	COM21	= 5	; Compare Match Output Mode
                 .equ	WGM20	= 6	; Wafeform Generation Mode
                 .equ	PWM2	= WGM20	; For compatibility
                 .equ	FOC2	= 7	; Force Output Compare
                 
                 ; TCNT2 - Timer/Counter Register
                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                 
                 ; OCR2 - Output Compare Register
                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                 
                 ; TIMSK - 
                 .equ	TOIE2	= 6	; 
                 .equ	OCIE2	= 7	; 
                 
                 ; TIFR - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                 .equ	OCF2	= 7	; Output Compare Flag 2
                 
                 
                 ; ***** TIMER_COUNTER_3 **************
                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                 .equ	OCIE3C	= 1	; Timer/Counter3, Output Compare Match Interrupt Enable
                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                 
                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                 .equ	OCF3C	= 1	; Timer/Counter3 Output Compare C Match Flag
                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                 .equ	OCF3B	= 3	; Output Compare Flag 1B
                 .equ	OCF3A	= 4	; Output Compare Flag 1A
                 .equ	ICF3	= 5	; Input Capture Flag 1
                 
                 ; SFIOR - Special Function IO Register
                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                 ;.equ	PSR1	= PSR321	; For compatibility
                 ;.equ	PSR2	= PSR321	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 ; TCCR3A - Timer/Counter3 Control Register A
                 .equ	WGM30	= 0	; Waveform Generation Mode Bit 0
                 .equ	PWM30	= WGM30	; For compatibility
                 .equ	WGM31	= 1	; Waveform Generation Mode Bit 1
                 .equ	PWM31	= WGM31	; For compatibility
                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                 
                 ; TCCR3B - Timer/Counter3 Control Register B
                 .equ	CS30	= 0	; Clock Select 3 bit 0
                 .equ	CS31	= 1	; Clock Select 3 bit 1
                 .equ	CS32	= 2	; Clock Select3 bit 2
                 .equ	WGM32	= 3	; Waveform Generation Mode
                 .equ	CTC30	= WGM32	; For compatibility
                 .equ	WGM33	= 4	; Waveform Generation Mode
                 .equ	CTC31	= WGM33	; For compatibility
                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                 .equ	ICNC3	= 7	; Input Capture 3  Noise Canceler
                 
                 ; TCCR3C - Timer/Counter3 Control Register C
                 .equ	FOC3C	= 5	; Force Output Compare for channel C
                 .equ	FOC3B	= 6	; Force Output Compare for channel B
                 .equ	FOC3A	= 7	; Force Output Compare for channel A
                 
                 ; TCNT3L - Timer/Counter3 Low Byte
                 .equ	TCN3L0	= 0	; Timer/Counter 3 bit 0
                 .equ	TCN3L1	= 1	; Timer/Counter 3 bit 1
                 .equ	TCN3L2	= 2	; Timer/Counter 3 bit 2
                 .equ	TCN3L3	= 3	; Timer/Counter 3 bit 3
                 .equ	TCN3L4	= 4	; Timer/Counter 3 bit 4
                 .equ	TCN3L5	= 5	; Timer/Counter 3 bit 5
                 .equ	TCN3L6	= 6	; Timer/Counter 3 bit 6
                 .equ	TCN3L7	= 7	; Timer/Counter 3 bit 7
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCR - Watchdog Timer Control Register
                 .equ	WDTCSR	= WDTCR	; For compatibility
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDTOE	= WDCE	; For compatibility
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	BODEN	= 6	; Brown out detector enable
                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select Reset Vector
                 .equ	BOOTSZ0	= 1	; Select Boot Size
                 .equ	BOOTSZ1	= 2	; Select Boot Size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	CKOPT	= 4	; Oscillator Options
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	JTAGEN	= 6	; Enable JTAG
                 .equ	OCDEN	= 7	; Enable OCD
                 
                 ; EXTENDED fuse bits
                 .equ	WDTON	= 0	; Watchdog timer always on
                 .equ	CompMode	= 1	; Compabillity mode
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x7fff	; Note: Word address
                 .equ	IOEND	= 0x00ff
                 .equ	SRAM_START	= 0x0100
                 .equ	SRAM_SIZE	= 4096
                 .equ	RAMEND	= 0x10ff
                 .equ	XRAMEND	= 0xffff
                 .equ	E2END	= 0x07ff
                 .equ	EEPROMEND	= 0x07ff
                 .equ	EEADRBITS	= 11
                 #pragma AVRPART MEMORY PROG_FLASH 65536
                 #pragma AVRPART MEMORY EEPROM 2048
                 #pragma AVRPART MEMORY INT_SRAM SIZE 4096
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x7000
                 .equ	NRWW_STOP_ADDR	= 0x7fff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x6fff
                 .equ	PAGESIZE	= 128
                 .equ	FIRSTBOOTSTART	= 0x7e00
                 .equ	SECONDBOOTSTART	= 0x7c00
                 .equ	THIRDBOOTSTART	= 0x7800
                 .equ	FOURTHBOOTSTART	= 0x7000
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                 .equ	OC2addr	= 0x0012	; Timer/Counter2 Compare Match
                 .equ	OVF2addr	= 0x0014	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x0016	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x0018	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x001a	; Timer/Counter Compare Match B
                 .equ	OVF1addr	= 0x001c	; Timer/Counter1 Overflow
                 .equ	OC0addr	= 0x001e	; Timer/Counter0 Compare Match
                 .equ	OVF0addr	= 0x0020	; Timer/Counter0 Overflow
                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                 .equ	URXC0addr	= 0x0024	; USART0, Rx Complete
                 .equ	UDRE0addr	= 0x0026	; USART0 Data Register Empty
                 .equ	UTXC0addr	= 0x0028	; USART0, Tx Complete
                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                 .equ	OC1Caddr	= 0x0030	; Timer/Counter1 Compare Match C
                 .equ	ICP3addr	= 0x0032	; Timer/Counter3 Capture Event
                 .equ	OC3Aaddr	= 0x0034	; Timer/Counter3 Compare Match A
                 .equ	OC3Baddr	= 0x0036	; Timer/Counter3 Compare Match B
                 .equ	OC3Caddr	= 0x0038	; Timer/Counter3 Compare Match C
                 .equ	OVF3addr	= 0x003a	; Timer/Counter3 Overflow
                 .equ	URXC1addr	= 0x003c	; USART1, Rx Complete
                 .equ	UDRE1addr	= 0x003e	; USART1, Data Register Empty
                 .equ	UTXC1addr	= 0x0040	; USART1, Tx Complete
                 .equ	TWIaddr	= 0x0042	; 2-wire Serial Interface
                 .equ	SPMRaddr	= 0x0044	; Store Program Memory Read
                 
                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                 
                 #endif  /* _M64DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 ;###############################################################################
                 ;################### Define a symbol equal to an expression ####################
                 ;###############################################################################
                 .equ  Fclk    = 16000000  ;Hz
                 .set  us      = 1
                 ;###############################################################################
                 
                 ;###############################################################################
                 ;################## Define a symbolic name on a register #######################
                 ;###############################################################################
                 .equ  CF    =   0;Carry Flag
                 .equ  ZF    =   1;Zero Flag
                 .equ  NF    =   2;Negative Flag
                 .equ  VF    =   3;Two's Complement Overflow Flag
                 .equ  SF    =   4;Sign Bit
                 .equ  HF    =   5;Half Carry Flag
                 .equ  TF    =   6;Bit Copy Storage
                 .equ  IF    =   7;Global Interrupt Enable
                 
                 .equ  bit0  = 0
                 .equ  bit1  = 1
                 .equ  bit2  = 2
                 .equ  bit3  = 3
                 .equ  bit4  = 4
                 .equ  bit5  = 5
                 .equ  bit6  = 6
                 .equ  bit7  = 7
                 
                 .def  ZERO    = r3  ;регистр только для чтения
                                     ; всегда должен содержать 0
                 
                 
                 .def  TmpSREG = r6
                 .def  StoreI  = r8
                 
                 .def  rvInitFlag  = r9
                 
                 .def  rvIDEvent  = r11
                 .def  rvIDTask   = r12
                 
                 
                 .def  rvSpeedLR = r24 ; Регистровая переменная содержит направление движения и скорость
                 ;bit 76543210
                 ;    ||||||||
                 ;    |||||+++--> Текущая скорость Правая гусеница
                 ;    ||||+-----> Направление; 1 - вперед, 0 - назад
                 ;    ||||
                 ;    |+++------> Текущая скорость Левая гусеница
                 ;    +---------> Направление; 1 - вперед, 0 - назад
                 ; Числа 4-х битные
                 
                 .def  rvIndxServo = r25 ; Index for Servo position
                 
                 
                 ;< Register A 16bit
                 ;#define  AL  r16
                 .def  AL  = r16
                 .def  AH  = r17
                 ;> Register A 16bit
                 ;< Register B 16bit
                 .def  BL  = r18
                 .def  BH  = r19
                 ;> Register B 16bit
                 ;< Register C 16bit
                 .def  CL  = r20
                 .def  CH  = r21
                 ;> Register C 16bit
                 ;;< Register D 16bit
                 ;.def DL  = r22
                 ;.def DH  = r23
                 ;;> Register D 16bit
                 ;;< Register E 16bit
                 ;.def EL  = r24
                 ;.def EH  = r25
                 ;;> Register E 16bit
                 
                 .def  r_Flags   = r22
                   .equ flg_ServoDir = 0   ; 1 - INC ; 0 - DEC rvIndxServo
                   .equ flg_AnyKey   = 1   ;
                   .equ flg_ADC      = 2
                   .equ flg_LS_LR    = 3   ; 1 - Left; 0 - Right
                   .equ flg_StepL    = 4   ; Проход гусеницы левой
                   .equ flg_StepR    = 5   ; Проход гусеницы правой
                   .equ flg_IRStart  = 6   ; IRStart
                   .set flg_IR_OK    = 7   ; IROK
                 .def  r_FlagsH  = r23
                   .equ flg_LFL      = 8   ; LINE FRONT-L
                   .equ flg_LFR      = 9   ; LINE FRONT-R
                   .equ flg_LRL      = 10  ; LINE REAR-L
                   .equ flg_LRR      = 11  ; LINE REAR-R
                   .equ flg_BampF    = 12  ; Препятствие спереди
                   .equ flg_BampR    = 13  ; Препятствие сзади
                   .equ flg_Init     = 13  ; Initialization
                   .equ flg_Lamp     = 14  ; Источник света
                   .equ flg_Monet    = 15  ; Монетка
                 
                 #define TReklama  2000ms
                 
                 ;###############################################################################
                 
                 .ifdef  PROTEUS
                   .equ  Stop_P    = PORTC
                   .equ  Stop_Bit  = bit0
                 .endif
                 ;###############################################################################
                 
                 ;###############################################################################
                 .include  "MacroEX.asm" ;Include User macros
                 
                 ;Updated: "2011-03-07" "19:41"
                 ;
                 #ifndef MACROEX_INC
                 #define MACROEX_INC 1
                  #define sz(Name,String) sz_ ## Name: .db String,0
                 ;<
                   ;###############################################################################
                   ;###################### Common Macros ##########################################
                   ;###############################################################################
                   ;
                   .macro  SetStack
                       ldi    r16,   low(@0)
                       out    SPL,   r16
                       ldi    r16,   high(@0)
                       out    SPH,   r16
                   .endmacro
                   ;###############################################################################
                   ;###############################################################################
                   
                   .macro LDW
                     ldi @0H,high(@1)
                     ldi @0L,low(@1)
                   .endmacro
                   
                    .macro LDWY
                     ldi YH,high(@0)
                     ldi YL,low(@0)
                   .endmacro
                  
                   ;###############################################################################
                   ;###############################################################################
                   .macro mPUSHw
                       push    @0H
                       push    @0L
                   .endmacro
                   .macro mPOPw
                     pop   @0L
                     pop   @0H
                   .endmacro
                   .macro alignD
                   .if (@0==2)||(@0==4)||(@0==8)||(@0==16)
                     LA:
                     .if LA & (@0-1)
                       .warning ""
                       .message "+---------------------------------------+";
                       .message "| Not used DATA. See NoUse in map file. |"
                       .message "+---------------------------------------+";
                       .set NoUse = ((LA + (@0-1)) & ~(@0-1))-LA
                     .endif
                     .org  ((LA + (@0-1)) & ~(@0-1))
                   .else
                     .error "Align not valid."
                   .endif
                     ;
                   .endmacro
                   ;###############################################################################
                   ;############################ High Level Macro #################################
                   ;###############################################################################
                   .macro  PROC
                     .equ @0 = (pc)
                   .endmacro
                   
                   .macro  CPROC
                     .equ @0 = (pc)
                   .endmacro
                   
                   .macro  ENDP
                     .equ  SizeOf_@0=(pc-@0)
                   .endmacro
                   ;###############################################################################
                   ;###############################################################################
                   
                   ;###############################################################################
                   ;------------------------------------------------;
                   ; Long branch
                   .macro  rjne
                       breq  (pc+1)+1
                       rjmp  @0
                   .endmacro
                   
                   .macro  rjeq
                     brne  (pc+1)+1
                     rjmp  @0
                   .endmacro
                   
                   .macro  rjcc
                     brcs  (pc+1)+1
                     rjmp  @0
                   .endmacro
                   
                   .macro  rjcs
                     brcc  (pc+1)+1
                     rjmp  @0
                   .endmacro
                   
                   .macro  rjtc
                     brts  (pc+1)+1
                     rjmp  @0
                   .endmacro
                   
                   .macro  rjts
                     brtc  (pc+1)+1
                     rjmp  @0
                   .endmacro
                   
                   .macro  rjge
                     brlt  (pc+1)+1
                     rjmp  @0
                   .endmacro
                   
                   .macro  rjlt
                     brge  (pc+1)+1
                     rjmp  @0
                   .endmacro
                   
                   
                   .macro  retcc
                     brcs  (pc+1)+1
                     ret
                   .endmacro
                   
                   .macro  retcs
                     brcc  (pc+1)+1
                     ret
                   .endmacro
                   
                   .macro  reteq
                     brne  (pc+1)+1
                     ret
                   .endmacro
                   
                   .macro  retne
                     breq  (pc+1)+1
                     ret
                   .endmacro
                   
                   ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
                   .macro  rr
                     bst   @0, 0
                     lsr   @0
                     bld   @0, 7
                   .endmacro
                   ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
                   .macro  rl
                     bst   @0, 7
                     lsl   @0
                     bld   @0, 0
                   .endmacro
                   ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
                   .macro stsi
                     push  r16
                     ldi   r16,  @1
                     sts   @0, r16
                     pop   r16
                   .endmacro
                   ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
                   
                   ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
                   .macro  sbm
                     lds   r16,  @0
                     ori   r16,  1<<@1
                     sts   @0,   r16
                   .endmacro
                   
                   ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
                   .macro  cbm
                     lds   r16,  @0
                     andi  r16,  ~(1<<@1)
                     sts   @0,   r16
                   .endmacro
                   ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
                   .macro  addi
                     subi  @0, -@1
                   .endmacro
                 
                   ;/////////////////////////////////////////////////////////////////
                   .macro mEquPin  ;NameOfPin,Port,BitNumber
                   .equ  P_@0  = @1
                   .equ  @0    = @2
                   .endmacro
                   ;--------------------------------------------------------------------------------
                   .macro  mPinOut ;NameOfPin
                     .if (P_@0-1)>(0x3f)
                       push  r16
                       lds   r16,    P_@0-1
                       sbr   r16,    (1<<@0)
                       sts   P_@0-1, r16
                       pop   r16
                     .else
                       sbi   P_@0-1, @0
                     .endif
                   .endmacro
                   ;--------------------------------------------------------------------------------
                   .macro  mPinIn  ;NameOfPin
                     .if (P_@0-1)>(0x3f)
                       push  r16
                       lds   r16,    P_@0-1
                       cbr   r16,    (1<<@0)
                       sts   P_@0-1, r16
                       pop   r16
                     .else
                       cbi   P_@0-1, @0
                     .endif
                   .endmacro
                   ;--------------------------------------------------------------------------------
                   
                   ;-----------------------------------------------------------------
                   .macro  mPinGetDir  ;NameOfPin
                     push  r16
                     .if (P_@0-1)>(0x3f)
                       lds   r16,  P_@0-1
                     .else
                       in    r16,  P_@0-1
                     .endif
                       bst   r16,  @0
                     pop   r16
                   .endmacro
                 
                   .macro  mPinSetDir  ;NameOfPin
                     .if (P_@0-1)>(0x3f)
                       push  r16
                       lds   r16,    P_@0-1
                       brtc (pc+1)+1
                         sbr   r16,    (1<<@0)
                       brts (pc+1)+1
                         cbr   r16,    (1<<@0)
                       sts   P_@0-1, r16
                       pop   r16
                     .else
                       brtc (pc+1)+1
                       sbi   P_@0-1, @0
                       brts (pc+1)+1
                       cbi   P_@0-1, @0
                     .endif
                       
                   .endmacro
                   
                   
                   .macro  mPinSET ;NameOfPin
                     .if P_@0 > (0x3f);
                       push  r16
                       push  r17
                       in    r17   ,SREG
                       lds   r16   ,P_@0
                       sbr   r16   ,(1<<@0)
                       sts   P_@0  ,r16
                       out   SREG  ,r17
                       pop   r17
                       pop   r16
                     .else
                       sbi   P_@0  ,@0
                     .endif
                   .endmacro
                   ;-----------------------------------------------------------------
                   .macro  mPinCLR
                     .if P_@0 > (0x3f);
                       push  r16
                       push  r17
                       in    r17   ,SREG
                       lds   r16   ,P_@0
                       cbr   r16   ,(1<<@0)
                       sts   P_@0  ,r16
                       out   SREG  ,r17
                       pop   r17
                       pop   r16
                     .else
                       cbi   P_@0  ,@0
                     .endif
                   .endmacro
                   
                   .macro  mPinCpl
                     push  r16
                     push  r17
                     push  r18
                     in    r18   ,SREG
                     .if P_@0>(0x3f)
                       lds   r16,  P_@0
                       ldi   r17,  1<<@0
                       eor   r16,  r17
                       sts   P_@0, r16
                     .else
                       in    r16,  P_@0
                       ldi   r17,  1<<@0
                       eor   r16,  r17
                       out   P_@0, r16
                     .endif
                     out   SREG  ,r18
                     pop   r18
                     pop   r17
                     pop   r16
                   .endmacro
                   
                   ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
                   .macro  mPinState
                     push  r16
                     .if (P_@0-2)>(0x3f)
                       lds   r16,  P_@0-2
                     .else
                       in    r16,  P_@0-2
                     .endif
                       bst   r16,  @0
                     pop   r16
                   .endmacro
                   
                   ;/////////////////////////////////////////////////////////////////
                   ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
                   .ifdef  PROTEUS
                     .macro  mStop
                       mPinCLR Stop
                       mPinSET Stop
                   ;   sbi   Stop_P,Stop_Bit
                   ;   cbi   Stop_P,Stop_Bit
                     .endmacro
                   .endif
                   ;/////////////////////////////////////////////////////////////////
                   ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
                   
                   ;###############################################################################
                   ;< Flags. New version.
                   .ifndef r_Flags
                   .else
                   
                   .endif
                   .macro  mFlgSet
                     ;Установим флаг
                     .if @0<8
                       ori   r_Flags,  1<<@0
                     .else
                       ori   r_FlagsH, 1<<(@0&0b111)
                     .endif
                   .endmacro
                   
                   .macro  mFlgClr
                     ;Сбросим флаг
                     .if @0<8
                       cbr   r_Flags,  (1<<@0)
                     .else
                       cbr   r_FlagsH, 1<<(@0&0b111)
                     .endif
                   .endmacro
                   
                   .macro  mFlgCpl
                     push  r16
                     .if @0<8
                       ldi   r16,    1<<@0
                       eor   r_Flags,  r16
                     .else
                       ldi   r16,    1<<(@0&0b111)
                       eor   r_FlagsH, r16
                     .endif
                     pop   r16
                   .endmacro
                 
                   .macro  mFlgSkipClr
                     .if @0<8
                       sbrc  r_Flags,  @0
                     .else
                       sbrc  r_FlagsH, @0&0b111
                     .endif
                   .endmacro
                   
                   .macro  mFlgSkipSet
                     .if @0<8
                       sbrs  r_Flags,  @0
                     .else
                       sbrs  r_FlagsH, @0&0b111
                     .endif
                   .endmacro
                 
                   
                   .macro  mFlgLd
                     .if @0<8
                       bld   r_Flags,  @0
                     .else
                       bld   r_FlagsH, @0&0b111
                     .endif
                   .endmacro
                   ; Store Flag to T Flag
                   .macro  mFlgSt
                     .if @0<8
                       bst   r_Flags,  @0
                     .else
                       bst   r_FlagsH, @0&0b111
                     .endif
                   .endmacro
                   ;> Flags. New version.
                   ;###############################################################################
                   
                   .macro  mTestFlag
                     .if @0<8
                       sbrc  r_Flags,  @0
                     .else
                       sbrc  r_FlagsH, @0&0b111
                     .endif
                   .endmacro
                   
                   .macro  mCallIfSET
                     .if @0<8
                       sbrc  r_Flags,  @0
                       rcall @1
                     .else
                       sbrc  r_FlagsH, @0&0b111
                       rcall @1
                     .endif
                   .endmacro
                   
                   .macro  mCallIfSETC
                     .if @0<8
                       sbrc  r_Flags,  @0
                       rcall @1
                       sbrc  r_Flags,  @0
                       cbr   r_Flags,  1<<@0
                     .else
                       sbrc  r_FlagsH, @0&0b111
                       rcall @1
                       sbrc  r_FlagsH, @0
                       cbr   r_FlagsH, 1<<(@0&0b111)
                     .endif
                   .endmacro
                   
                   .macro  mJmpIfSET
                     .if @0<8
                       sbrc  r_Flags,  @0
                       rjmp  @1
                     .else
                       sbrc  r_FlagsH, @0&0b111
                       rjmp @1
                     .endif
                   .endmacro
                   
                   .macro  mCallIfCLR
                     .if @0<8
                       sbrs  r_Flags,  @0
                       rcall @1
                     .else
                       sbrs  r_FlagsH, @0&0b111
                       rcall @1
                     .endif
                   .endmacro
                   
                   .macro  mJmpIfCLR
                     .if @0<8
                       sbrs  r_Flags,  @0
                       rjmp  @1
                     .else
                       sbrs  r_FlagsH, @0&0b111
                       rjmp @1
                     .endif
                   .endmacro
                   
                   .macro  mIfFlgSET
                   ; mIfFlgSET flg_ADC,rjmp MainLoop
                   ; mIfFlgSET flg_ADC,rcall MainLoop
                     .if @0<8
                       sbrc  r_Flags,  @0
                       @1
                     .else
                       sbrc  r_FlagsH, @0&0b111
                       @1
                     .endif
                   .endmacro
                   
                   .macro  mIfFlgCLR
                   ; mIfFlgCLR flg_ADC,rjmp MainLoop
                   ; mIfFlgCLR flg_ADC,rcall MainLoop
                     .if @0<8
                       sbrs  r_Flags,  @0
                       @1
                     .else
                       sbrs  r_FlagsH, (@0&0b111)
                       @1
                     .endif
                   .endmacro
                 
                   ;/////////////////////////////////////////////////////////////////
                   ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
                   .macro mstiw
                     push  r16
                     ldi   r16,  low (@1)
                     sts   (@0), r16
                     ldi   r16,  high(@1)
                     sts   (@0+1), r16
                     pop   r16
                   .endmacro
                   
                   
                   ;mMemFill SRAM_START,RAMEND,$00
                   .macro mMemFill
                     .if @0<SRAM_START || @1>RAMEND
                       .error "mMemFill: Parameter(s) out of range!"
                     .else
                       .message "Ok"
                       ldi   YL,   low(@0)
                       ldi   YH,   high(@0)
                       ldi   ZL, @2
                      LMemClr_Loop:
                       st    y+,   ZL
                       cpi   YL,   low(@1)   ;Compare low byte
                       ldi   r16,  high(@1)  ;
                       cpc   YH,   r16     ;Compare high byte
                       brlo LMemClr_Loop
                   
                     .endif
                   
                   .endmacro
                 
                   .macro mAllRegZero
                       ldi   YL,   28
                       clr   YH
                       clr   ZL
                       clr   ZH
                      L_AllRegZero:
                       st    -y,   ZL
                       tst   YL
                       brne L_AllRegZero
                   .endmacro
                 
                   .macro mOuti
                     push  r16
                       ldi   r16,  @1
                     .if @0>(0x3f)
                       sts   @0,   r16
                     .else
                       out   @0,   r16
                     .endif
                     pop   r16
                   .endmacro 
                   
                   .macro mOut
                     .if @0 > (0x3f)
                       sts   @0,   @1
                     .else
                       out   @0,   @1
                     .endif
                   .endmacro 
                 
                   .macro mIn
                     .if @1 > (0x3f)
                       lds   @0,   @1
                     .else
                       in    @0,   @1
                     .endif
                   .endmacro 
                 
                   ;< FOR STRUCTURE
                   #define SOI(Struc,Item) Struc##Item-Struc ;
                   
                   ;< FOR STRUCTURE
                   #define GetEventID(Struc,Item) Struc##_##Item-Struc ;
                   
                   ; ;< struct v_GND
                   ; v_GND:
                   ; v_GNDCur:   .byte 4 ;
                   ; v_GNDMin:   .byte 4 ;
                   ; v_GNDMax:   .byte 4 ;
                   ; ;> struct v_GND
                   ; 
                   ; ldd AH, y+SOI(v_GND,Min)
                   ;> OR STRUCTURE
                 
                 ;>
                 #else
                 #endif
                 
                 .include  "DataRAM.inc" ;
                 
                 .dseg
                 .list
                 .listmac
                 ;###############################################################################
                 ;###############################################################################
                 
                 ;###############################################################################
                 ;S_Alex
                 ;###############################################################################
                 ;###############################################################################
                   .eseg
                 #endif
                 .list
                 
                 .include  "IntRoutines.asm" ;
                 
                 ;
                 ;###############################################################################
                 ;######################### Interrupt routines ##################################
                 ;###############################################################################
                 ;
                 ;###############################################################################
                 .cseg
                 
                 INT_0:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
000068 9518        reti
                 ;---
                 INT_1:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
000069 9518        reti
                 ;---
                 INT_2:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
00006a 9518        reti
                 ;---
                +
                +.equ INT_3 = ( pc )
                 PROC INT_3 ;Calc LS
                 
00006b b66f        in    TmpSREG,  SREG
                   ;Place your code here
00006c 930f        push  AL
00006d 931f        push  AH
00006e 932f        push  BL
00006f 933f        push  BH
000070 934f        push  CL
000071 935f        push  CH
                 
                +
                +.if TCNT3L > ( 0x3f )
000072 9100 0088+lds AL , TCNT3L
                +.else 
                +in AL , TCNT3L
                   mIn   AL        ,TCNT3L
000074 9110 0109   lds   AH        ,(v_LSOldL)
000076 9300 0109   sts   (v_LSOldL),AL
000078 1b01        sub   AL        ,AH
000079 9300 0107   sts   (v_LSCurL),AL
                 
                +
                +.if TCNT3H > ( 0x3f )
00007b 9100 0089+lds AL , TCNT3H
                +.else 
                +in AL , TCNT3H
                   mIn   AL        ,TCNT3H
00007d 9110 010a   lds   AH        ,(v_LSOldH)
00007f 9300 010a   sts   (v_LSOldH),AL
000081 0b01        sbc   AL        ,AH
000082 9300 0108   sts   (v_LSCurH),AL
                 
                 
                   ;< LS SET_SENSOR_FLGAG
                 ;  mFlgClr flg_Lamp    ; Источник света
                 
000084 9100 010b   lds   AL  ,(v_LSMidL)
000086 9110 010c   lds   AH  ,(v_LSMidH)
000088 9516        lsr   AH
000089 9507        ror   AL  ;AL/2   ±50%
00008a 9516        lsr   AH
00008b 9507        ror   AL  ;AL/4   ±25%
00008c 9516        lsr   AH
00008d 9507        ror   AL  ;AL/8   ±12.5%
00008e 9516        lsr   AH
00008f 9507        ror   AL  ;AL/16  ±6.25%
000090 9516        lsr   AH
000091 9507        ror   AL  ;AL/32  ±3.125%
                 
000092 9120 010b   lds   BL  ,(v_LSMidL)
000094 9130 010c   lds   BH  ,(v_LSMidH)
000096 0f20        add   BL  ,AL
000097 1f31        adc   BH  ,AH
                 
000098 9140 010b   lds   CL  ,(v_LSMidL)     ;        |
00009a 9150 010c   lds   CH  ,(v_LSMidH)     ;        |
00009c 1b40        sub   CL  ,AL             ;        |
00009d 0b51        sbc   CH  ,AH             ;        |
                 
                 
00009e 9100 0107   lds   AL  ,(v_LSCurL)
0000a0 9110 0108   lds   AH  ,(v_LSCurH)
0000a2 1702        cp    AL  ,BL
0000a3 0713        cpc   AH  ,BH
0000a4 f438        brsh (pc+1)+1+1+1+1+1+2 ;----------->+
0000a5 1704          cp    AL  ,CL             ;        |
0000a6 0715          cpc   AH  ,CH             ;        |
0000a7 f020          brlo (pc+1)+1+1+2         ;------->+
                +
                +
                +.if flg_Lamp < 8
                +ori r_Flags , 1 << flg_Lamp
0000a8 6470     +.else 
                +ori r_FlagsH , 1 << ( flg_Lamp & 0b111 )
                       mFlgSet flg_Lamp        ;        |
0000a9 e800            ldi AL  ,0x80           ;        |
0000aa 9300 01b5       sts (v_InfoBuf1+5),AL   ;        |Источник света
                   ;                       ;-<----------+
                   ;> LS SET_SENSOR_FLGAG
                 
                   ;
0000ac 915f        pop   CH
0000ad 914f        pop   CL
0000ae 913f        pop   BH
0000af 912f        pop   BL
0000b0 911f        pop   AH
0000b1 910f        pop   AL
0000b2 be6f        out   SREG,   TmpSREG
0000b3 9518        reti
                 
                +
                +.equ SizeOf_INT_3 = ( pc - INT_3 )
                 ENDP INT_3
                 ;---
                 INT_4:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
0000b4 9518        reti
                 ;---
                +
                +.equ INT_5 = ( pc )
                 PROC INT_5
0000b5 b66f        in    TmpSREG,  SREG
                   ;Place your code here
                 
                   ;< F-Bamper
                +
0000b6 930f     +push r16
                +.if ( P_TSOPF - 2 ) > ( 0x3f )
                +lds r16 , P_TSOPF - 2
0000b7 b101     +.else 
                +in r16 , P_TSOPF - 2
0000b8 fb05     +.endif 
0000b9 910f     +bst r16 , TSOPF
                   mPinState TSOPF
                +
                +.if flg_BampF < 8
                +bld r_Flags , flg_BampF
0000ba f974     +.else 
                +bld r_FlagsH , flg_BampF & 0b111
                   mFlgLd    flg_BampF
                +
0000bb 930f     +push r16
                +.if flg_BampF < 8
                +ldi r16 , 1 << flg_BampF
0000bc e100     +eor r_Flags , r16
0000bd 2770     +.else 
                +ldi r16 , 1 << ( flg_BampF & 0b111 )
0000be 910f     +eor r_FlagsH , r16
                   mFlgCpl   flg_BampF
                   ;> F-Bamper
                 
0000bf 930f        push  AL
0000c0 e50e        ldi   AL, '^'
                +
                +.if flg_BampF < 8
                +sbrs r_Flags , flg_BampF
0000c1 ff74     +.else 
                +sbrs r_FlagsH , flg_BampF & 0b111
                   mFlgSkipSet flg_BampF   ; Препятствие спереди
0000c2 e50f          ldi   AL, '_'
0000c3 9300 01b4   sts   v_InfoBuf1+4,  AL ; Препятствие спереди
0000c5 9300 01b3   sts   v_InfoBuf1+3,  AL ; Препятствие спереди
0000c7 910f        pop   AL
                 
                 
                +
0000c8 930f     +push r16
0000c9 931f     +push r17
0000ca 932f     +push r18
0000cb b72f     +in r18 , SREG
                +.if P_LedRed > ( 0x3f )
0000cc 9100 0065+lds r16 , P_LedRed
0000ce e011     +ldi r17 , 1 << LedRed
0000cf 2701     +eor r16 , r17
0000d0 9300 0065+sts P_LedRed , r16
                +.else 
                +in r16 , P_LedRed
0000d2 bf2f     +ldi r17 , 1 << LedRed
0000d3 912f     +eor r16 , r17
0000d4 911f     +out P_LedRed , r16
0000d5 910f     +.endif 
                   mPinCpl LedRed
                 
0000d6 940e 0a59   call fIRShiftBuff
                 
0000d8 be6f        out   SREG,   TmpSREG
0000d9 9518        reti
                 
                +
                +.equ SizeOf_INT_5 = ( pc - INT_5 )
                 ENDP INT_5
                 ;---
                +
                +.equ INT_6 = ( pc )
                 PROC INT_6
0000da b66f        in    TmpSREG,  SREG
                   ;Place your code here
                   ;< R-Bamper
                +
0000db 930f     +push r16
                +.if ( P_TSOPR - 2 ) > ( 0x3f )
                +lds r16 , P_TSOPR - 2
0000dc b101     +.else 
                +in r16 , P_TSOPR - 2
0000dd fb06     +.endif 
0000de 910f     +bst r16 , TSOPR
                   mPinState TSOPR
                +
                +.if flg_BampR < 8
                +bld r_Flags , flg_BampR
0000df f975     +.else 
                +bld r_FlagsH , flg_BampR & 0b111
                   mFlgLd    flg_BampR
                +
0000e0 930f     +push r16
                +.if flg_BampR < 8
                +ldi r16 , 1 << flg_BampR
0000e1 e200     +eor r_Flags , r16
0000e2 2770     +.else 
                +ldi r16 , 1 << ( flg_BampR & 0b111 )
0000e3 910f     +eor r_FlagsH , r16
                   mFlgCpl   flg_BampR
                   ;> R-Bamper
                 
                 ; rcall krRand
                 
0000e4 be6f        out   SREG,   TmpSREG
0000e5 9518        reti
                 
                +
                +.equ SizeOf_INT_6 = ( pc - INT_6 )
                 ENDP INT_6
                 ;---
                 INT_7:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
0000e6 9518        reti
                 ;---
                 INT_OC2:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
0000e7 9518        reti
                 ;---
                 INT_OVF2:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
0000e8 9518        reti
                 ;---
                 INT_ICP1:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
0000e9 9518        reti
                 ;---
                 INT_OC1A:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
0000ea 9518        reti
                 ;---
                 INT_OC1B:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
0000eb 9518        reti
                 ;---
                 INT_OVF1:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
0000ec 9518        reti
                 ;---
                 INT_OC0:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
0000ed 9518        reti
                 ;---
                 INT_OVF0:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
0000ee 9518        reti
                 ;---
                 INT_SPI:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
0000ef 9518        reti
                 ;---
                 INT_URXC0:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
0000f0 9518        reti
                 ;---
                 INT_UDRE0:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
0000f1 9518        reti
                 ;---
                 INT_UTXC0:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
0000f2 9518        reti
                 ;---
                 INT_ADCC:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
0000f3 9518        reti
                 ;---
                 INT_ERDY:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
0000f4 9518        reti
                 ;---
                 INT_ACI:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
0000f5 9518        reti
                 ;---
                 INT_OC1C:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
0000f6 9518        reti
                 ;---
                +
                +.equ INT_ICP3 = ( pc )
                 PROC INT_ICP3 ; Interrupt from FM sensor
0000f7 b66f        in    TmpSREG,  SREG
                   ;Place your code here
0000f8 930f        push  AL
0000f9 931f        push  AH
0000fa 932f        push  BL
0000fb 933f        push  BH
0000fc 934f        push  CL
0000fd 935f        push  CH
                 
                   ;< Calculate current value for FM sensor
                +
                +.if ICR3L > ( 0x3f )
0000fe 9100 0080+lds AL , ICR3L
                +.else 
                +in AL , ICR3L
                   mIn   AL        ,ICR3L
000100 9110 0102   lds   AH        ,(v_FMOldL)
000102 9300 0102   sts   (v_FMOldL),AL
000104 1b01        sub   AL        ,AH
000105 9300 0100   sts   (v_FMCurL),AL
                 
                +
                +.if ICR3H > ( 0x3f )
000107 9100 0081+lds AL , ICR3H
                +.else 
                +in AL , ICR3H
                   mIn   AL        ,ICR3H
000109 9110 0103   lds   AH        ,(v_FMOldH)
00010b 9300 0103   sts   (v_FMOldH),AL
00010d 0b01        sbc   AL        ,AH
00010e 9300 0101   sts   (v_FMCurH),AL
                   ;> Calculate current value for FM sensor
                 
                   ;< FM SET_SENSOR_FLGAG
                 ;  mFlgClr flg_Monet   ; Монетка
                 
                   ;lds    AL  ,(v_FMMidL)
                   ;lds    AH  ,(v_FMMidH)
000110 9100 0105   lds   AL  ,(v_FMMidH)
000112 6001        sbr   AL  ,0x01
000113 e010        ldi   AH  ,0x00   ; AH:AL = (v_FMMid / 256) or 1
                 
000114 9120 0104   lds   BL  ,(v_FMMidL)
000116 9130 0105   lds   BH  ,(v_FMMidH)
000118 0f20        add   BL  ,AL
000119 1f31        adc   BH  ,AH
                   ;Hi = v_FMMid + v_FMMid / 256
                 
00011a 9140 0104   lds   CL  ,(v_FMMidL)
00011c 9150 0105   lds   CH  ,(v_FMMidH)
00011e 1b40        sub   CL  ,AL
00011f 0b51        sbc   CH  ,AH
                   ;Lo = v_FMMid - v_FMMid / 256
                 
                 
000120 9100 0100   lds   AL  ,(v_FMCurL)
000122 9110 0101   lds   AH  ,(v_FMCurH)
000124 1702        cp    AL  ,BL
000125 0713        cpc   AH  ,BH
000126 f438        brsh (pc+1)+1+1+1+1+1+2     ;------->+
000127 1704          cp    AL  ,CL               ;        |
000128 0715          cpc   AH  ,CH               ;        |
000129 f020          brlo (pc+1)+1+1+2           ;------->+
                +
                +
                +.if flg_Monet < 8
                +ori r_Flags , 1 << flg_Monet
00012a 6870     +.else 
                +ori r_FlagsH , 1 << ( flg_Monet & 0b111 )
                       mFlgSet flg_Monet         ;        |
00012b e204              ldi   AL, '$'           ;        |
00012c 9300 01b2         sts   (v_InfoBuf1+2),AL ;Монетка |
                         
                   ;                             ; <------+
                   ;> FM SET_SENSOR_FLGAG
                 
00012e 915f        pop   CH
00012f 914f        pop   CL
000130 913f        pop   BH
000131 912f        pop   BL
000132 911f        pop   AH
000133 910f        pop   AL
000134 be6f        out   SREG,   TmpSREG
000135 9518        reti
                 
                +
                +.equ SizeOf_INT_ICP3 = ( pc - INT_ICP3 )
                 ENDP INT_ICP3
                 ;---
                 INT_OC3A:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
000136 9518        reti
                 ;---
                 INT_OC3B:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
000137 9518        reti
                 ;---
                +
                +.equ INT_OC3C = ( pc )
                 PROC INT_OC3C ;"Buzer"
                 
000138 b66f        in    TmpSREG   ,SREG
                   ;Place your code here
                +
000139 930f     +push r16
00013a 931f     +push r17
00013b 932f     +push r18
00013c b72f     +in r18 , SREG
                +.if P_pBuzer > ( 0x3f )
                +lds r16 , P_pBuzer
00013d b305     +ldi r17 , 1 << pBuzer
00013e e810     +eor r16 , r17
00013f 2701     +sts P_pBuzer , r16
000140 bb05     +.else 
                +in r16 , P_pBuzer
000141 bf2f     +ldi r17 , 1 << pBuzer
000142 912f     +eor r16 , r17
000143 911f     +out P_pBuzer , r16
000144 910f     +.endif 
                   mPinCpl pBuzer  ; Инверсия состояния для вывода "Buzer"
                 
000145 930f        push  AL
000146 931f        push  AH
                +
                +.if OCR3CL > ( 0x3f )
000147 9100 0082+lds AL , OCR3CL
                +.else 
                +in AL , OCR3CL
                   mIn   AL    ,OCR3CL
000149 9110 012e   lds   AH    ,v_DivNote+0
00014b 0f01        add   AL    ,AH
                 
00014c 930f        push  AL
                +
                +.if OCR3CH > ( 0x3f )
00014d 9100 0083+lds AL , OCR3CH
                +.else 
                +in AL , OCR3CH
                   mIn   AL    ,OCR3CH
00014f 9110 012f   lds   AH    ,v_DivNote+1
000151 1f10        adc   AH    ,AL
000152 910f        pop   AL
                 
                +
                +.if OCR3CH > ( 0x3f )
000153 9310 0083+sts OCR3CH , AH
                +.else 
                +out OCR3CH , AH
                   mOut OCR3CH ,AH
                +
                +.if OCR3CL > ( 0x3f )
000155 9300 0082+sts OCR3CL , AL
                +.else 
                +out OCR3CL , AL
                   mOut OCR3CL ,AL
                 
000157 911f        pop   AH
000158 910f        pop   AL
000159 be6f        out   SREG  ,TmpSREG
00015a 9518        reti
                 
                +
                +.equ SizeOf_INT_OC3C = ( pc - INT_OC3C )
                 ENDP INT_OC3C
                 ;---
                 INT_OVF3:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
00015b 9518        reti
                 ;---
                 INT_URXC1:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
00015c 9518        reti
                 ;---
                 INT_UDRE1:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
00015d 9518        reti
                 ;---
                 INT_UTXC1:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
00015e 9518        reti
                 ;---
                 INT_TWI:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
00015f 9518        reti
                 ;---
                 INT_SPMR:
                 ;  in    TmpSREG ,SREG
                 ;  ;Place your code here
                 ;  out   SREG    ,TmpSREG
000160 9518        reti
                 ;---
                 
                 
                 
                 ;;###############################################################################
                +
                +.equ f_IntOVF1 = ( pc )
                 PROC  f_IntOVF1
                     ;Timer0 Overflow Handler
000161 b66f        in    TmpSREG ,SREG
000162 930f        push    AL
000163 931f        push    AH
                +
000164 93ff     +push ZH
000165 93ef     +push ZL
                   mPUSHw  Z
                   ;Place your code here
                   ;< Set Servo into new position
                +
000166 e0fe     +ldi ZH , high ( ( ct_Servo4Scan ) )
000167 e8e8     +ldi ZL , low ( ( ct_Servo4Scan ) )
                   LDW   Z       ,(ct_Servo4Scan)
000168 2f09        mov   AL      ,rvIndxServo
000169 700f        andi  AL      ,0x0F
00016a 0fe0        add   ZL      ,AL
00016b 1df3        adc   ZH      ,ZERO
00016c 0fee        lsl   ZL
00016d 1fff        rol   ZH
00016e 9105        lpm   AL      ,z+
00016f 9115        lpm   AH      ,z+
                +
                +.if OCR1AH > ( 0x3f )
                +sts OCR1AH , AH
000170 bd1b     +.else 
                +out OCR1AH , AH
                   mOut  OCR1AH  ,AH
                +
                +.if OCR1AL > ( 0x3f )
                +sts OCR1AL , AL
000171 bd0a     +.else 
                +out OCR1AL , AL
                   mOut  OCR1AL  ,AL
                   ;> Set Servo into new position
                   ;
                +
000172 91ef     +pop ZL
000173 91ff     +pop ZH
                   mPOPw   Z
000174 911f        pop     AH
000175 910f        pop     AL
000176 be6f        out   SREG    ,TmpSREG
000177 9518        reti
                 
                +
                +.equ SizeOf_f_IntOVF1 = ( pc - f_IntOVF1 )
                 ENDP f_IntOVF1
                 ;;###############################################################################
                 ;;###############################################################################
                 
                 
                 ;;###############################################################################
                 
                 ;###############################################################################
                 ;S_Alex
                 
                 
                 ;RESET:
                 ;   mDelay_Us (exp2(8)*3)+4
                 ;.exit
                 
                 .include  "RTOSA/RTOSA.inc"
                 
                 ;RTOSA Ver. 0.0.0.1 - Copyright (C) 2009-2010 S_Alex.
                 ;This file is part of the RTOSA distribution.
                 ; "2010-08-09" "19:24"
                 ;Updated: "2010-09-09" "23:32"
                 ;Updated: "2011-03-07" "19:41"
                 ;Updated: "2011-04-05" "14:27"
                 
                 ;###############################################################################
                 #ifndef TIMERCNTRS_INC
                   #include  "RTOSA\TimerCntrs.inc"
                 
                 ;Updated: "2011-03-07" "19:41"
                 ;Updated: "2011-03-17" "23:39"
                 
                 #ifndef TIMERCNTRS_INC
                 #define TIMERCNTRS_INC 1
                   ;< <<<
                   ;< TC0
                     #if defined(__ATmega8__)
                     #elif defined (__ATmega103__)|defined (__ATmega64__)
                       ;CS02 CS01 CS00         ;Description
                       .equ T0_OFF     = 0b000 ;No clock source. (Timer/counter stopped)
                       .equ T0Div1     = 0b001 ;clkI/O/1 (No prescaling)
                       .equ T0Div8     = 0b010 ;clkI/O/8 (From prescaler)
                       .equ T0Div32    = 0b011 ;clkI/O/32 (From prescaler)
                       .equ T0Div64    = 0b100 ;clkI/O/64 (From prescaler)
                       .equ T0Div128   = 0b101 ;clkI/O/128 (From prescaler)
                       .equ T0Div256   = 0b110 ;clkI/O/256 (From prescaler)
                       .equ T0Div1024  = 0b111 ;clkI/O/1024 (From prescaler)
                       ;-----------------------------------------------------+
                       ;Compare Output Mode, Non-PWM Mode                    |
                       ;COM01|COM00| Description                             |
                       ;  0  |  0  | Normal port operation, OC2 disconnected.|
                       ;  0  |  1  | Toggle OC2 on compare match             |
                       ;  1  |  0  | Clear OC2 on compare match              |
                       ;  1  |  1  | Set OC2 on compare match                |
                       ;-----------------------------------------------------+
                       .equ  COMTC0NORMAL  = (0<<COM01)|(0<<COM00) ;         |
                       .equ  COMTC0Toggle  = (0<<COM01)|(1<<COM00) ;         |
                       .equ  COMTC0Clear   = (1<<COM01)|(0<<COM00) ;         |
                       .equ  COMTC0Set     = (1<<COM01)|(1<<COM00) ;         |
                       ;-----------------------------------------------------+
                     #endif
                   ;> TC0
                 
                   ;< TC1
                   ;< 16-bit Timer/Counter (Timer/Counterl and Timer/Counter3)
                   #if defined(__ATmega8__)||defined(__ATmega64__)
                   ;Тактируется от задающего генератора TCK или от внешнего входа T1
                   ;через делитель коэффициент деления 1,8,64,256,1024.
                   ;Регистр управления таймером/счетчиком0.
                   ;TCCR1A-(The Timer/Counter1 Control Register)
                     ;CS12 CS11 CS10 Description
                     .equ T1_OFF     = 0b000 ;No clock source. (Timer/counter stopped)
                     .equ T1Div1     = 0b001 ;clkI/O/1 (No prescaling)
                     .equ T1Div8     = 0b010 ;clkI/O/8 (From prescaler)
                     .equ T1Div64    = 0b011 ;clkI/O/64 (From prescaler)
                     .equ T1Div256   = 0b100 ;clkI/O/256 (From prescaler)
                     .equ T1Div1024  = 0b101 ;clkI/O/1024 (From prescaler)
                     .equ T1ExtFall  = 0b110 ;External clock source on T1 pin. Clock on falling edge.
                     .equ T1ExtRis   = 0b111 ;External clock source on T1 pin. Clock on rising edge.
                 
                 
                 ;----+-----+-----+-----+-----+---------------------------+------+---------+---------+
                 ;Mode|WGMn3|WGMn2|WGMnl|WGMnO|Timer/Counter Mode of      |TOP   |Update of|TOVn Flag|
                 ;    |     |CTCn |PWMnl|PWMn0|        Operation          |      |OCRnx at | Set on  |
                 ;  0 |  0  |  0  |  0  |  0  |Normal                     |OxFFFF|Immediate|MAX      |
                 ;  1 |  0  |  0  |  0  |  1  |PWM, Phase Correct, 8-bit  |OxOOFF|TOP      |BOTTOM   |
                 ;  2 |  0  |  0  |  1  |  0  |PWM, Phase Correct, 9-bit  |0x01FF|TOP      |BOTTOM   |
                 ;  3 |  0  |  0  |  1  |  1  |PWM, Phase Correct, 10-bit |0x03FF|TOP      |BOTTOM   |
                 ;  4 |  0  |  1  |  0  |  0  |CTC                        |OCRnA |Immediate|MAX      |
                 ;  5 |  0  |  1  |  0  |  1  |Fast PWM, 8-bit            |OxOOFF|TOP      |TOP      |
                 ;  6 |  0  |  1  |  1  |  0  |Fast PWM, 9-bit            |0x01FF|TOP      |TOP      |
                 ;  7 |  0  |  1  |  1  |  1  |Fast PWM, 10-bit           |0x03FF|TOP      |TOP      |
                 ;  8 |  1  |  0  |  0  |  0  |PWM, Phase and Freq Correct|ICRn  |BOTTOM   |BOTTOM   |
                 ;  9 |  1  |  0  |  0  |  1  |PWM, Phase and Freq Correct|OCRnA |BOTTOM   |BOTTOM   |
                 ;  10|  1  |  0  |  1  |  0  |PWM, Phase Correct         |ICRn  |TOP      |BOTTOM   |
                 ;  11|  1  |  0  |  1  |  1  |PWM, Phase Correct         |OCRnA |TOP      |BOTTOM   |
                 ;  12|  1  |  1  |  0  |  0  |CTC                        |ICRn  |Immediate|MAX      |
                 ;  13|  1  |  1  |  0  |  1  |(Reserved)                 |-     |  -      |-        |
                 ;  14|  1  |  1  |  1  |  0  |Fast PWM                   |ICRn  |TOP      |TOP      |
                 ;  15|  1  |  1  |  1  |  1  |Fast PWM                   |OCRnA |TOP      |TOP      |
                 ;----+-----+-----+-----+-----+---------------------------+------+---------+---------+
                     .equ  PWM1A_Discon  = (0<<COM1A1)|(0<<COM1A0)
                     .equ  PWM1A_Toggle  = (0<<COM1A1)|(1<<COM1A0)
                     .equ  PWM1A_NoInv   = (1<<COM1A1)|(0<<COM1A0)
                     .equ  PWM1A_Inv     = (1<<COM1A1)|(1<<COM1A0)
                 
                     .equ  PWM1B_Discon  = (0<<COM1B1)|(0<<COM1B0)
                     .equ  PWM1B_Toggle  = (0<<COM1B1)|(1<<COM1B0)
                     .equ  PWM1B_NoInv   = (1<<COM1B1)|(0<<COM1B0)
                     .equ  PWM1B_Inv     = (1<<COM1B1)|(1<<COM1B0)
                 
                     #if defined(__ATmega64__)
                     
                       .equ T3_OFF     = 0b000 ;No clock source. (Timer/counter stopped)
                       .equ T3Div1     = 0b001 ;clkI/O/1 (No prescaling)
                       .equ T3Div8     = 0b010 ;clkI/O/8 (From prescaler)
                       .equ T3Div64    = 0b011 ;clkI/O/64 (From prescaler)
                       .equ T3Div256   = 0b100 ;clkI/O/256 (From prescaler)
                       .equ T3Div1024  = 0b101 ;clkI/O/1024 (From prescaler)
                       .equ T3ExtFall  = 0b110 ;External clock source on T1 pin. Clock on falling edge.
                       .equ T3ExtRis   = 0b111 ;External clock source on T1 pin. Clock on rising edge.
                   
                       .equ  PWM1C_Discon  = (0<<COM1C1)|(0<<COM1C0)
                       .equ  PWM1C_Toggle  = (0<<COM1C1)|(1<<COM1C0)
                       .equ  PWM1C_NoInv   = (1<<COM1C1)|(0<<COM1C0)
                       .equ  PWM1C_Inv     = (1<<COM1C1)|(1<<COM1C0)
                     #endif
                 
                 
                   #endif
                   ;> 16-bit Timer/Counter (Timer/Counterl and Timer/Counter3)
                   ;> TC1
                 
                   ;< TC2
                     #if defined(__ATmega8__)
                     #elif defined (__ATmega103__)|defined (__ATmega64__)
                       ;CS22 CS21 CS20         ;Description
                       .equ T2_OFF     = 0b000 ;No clock source. (Timer/counter stopped)
                       .equ T2Div1     = 0b001 ;clkI/O/1 (No prescaling)
                       .equ T2Div8     = 0b010 ;clkI/O/8 (From prescaler)
                       .equ T2Div64    = 0b011 ;clkI/O/64 (From prescaler)
                       .equ T2Div256   = 0b100 ;clkI/O/256 (From prescaler)
                       .equ T2Div1024  = 0b101 ;clkI/O/1024 (From prescaler)
                       .equ T2ExtFall  = 0b110 ;External clock source on T0 pin. Clock on falling edge.
                       .equ T2ExtRis   = 0b111 ;External clock source on T0 pin. Clock on rising edge.
                       ;-----------------------------------------------------+
                       ;Compare Output Mode, Non-PWM Mode                    |
                       ;COM21|COM20| Description                             |
                       ;  0  |  0  | Normal port operation, OC2 disconnected.|
                       ;  0  |  1  | Toggle OC2 on compare match             |
                       ;  1  |  0  | Clear OC2 on compare match              |
                       ;  1  |  1  | Set OC2 on compare match                |
                       ;-----------------------------------------------------+
                       .equ  COMTC2NORMAL  = (0<<COM21)|(0<<COM20) ;         |
                       .equ  COMTC2Toggle  = (0<<COM21)|(1<<COM20) ;         |
                       .equ  COMTC2Clear   = (1<<COM21)|(0<<COM20) ;         |
                       .equ  COMTC2Set     = (1<<COM21)|(1<<COM20) ;         |
                       ;-----------------------------------------------------+
                 
                     #endif
                 
                   ;> TC2
                 
                     .macro mInitTC8bit  ;TIMER,FREQUENCY ;mInitTC8bit 0,100
                       #if defined(__ATmega8__)
                       #elif defined(__ATmega64__)
                         .set  F_Ovf = @1*2;100
                       #endif
                       .set  F_Ovf = @1*2;100
                       .set  N_Cnt   = 8
                       .set  FnMin   = 1
                       .set  FnMax   = (1<<N_Cnt) - 1
                 
                       .set  PreDivMin = Fclk / ( F_Ovf * FnMax)
                       .set  PreDivMax = Fclk / ( F_Ovf * FnMin)
                 
                     #if defined(__ATmega8__)||defined(__ATmega64__)
                       .message  " +--------------+"
                       .if @0==0
                        .message " |PreDiv for TC0|"
                       .elif @0==2
                        .message " |PreDiv for TC2|"
                       .endif
                       .if PreDivMin < 1
                         .message " |   Div1       |"
                         .set PreDiv = 1
                         .set DivMask = T@0Div1
                       .elif (PreDivMin<8)&&defined(T@0Div8)
                         .message " |   Div8       |"
                         .set PreDiv = 8
                         .set DivMask = T@0Div8
                       .elif (PreDivMin<32)&&defined(T@0Div32)
                         .message " |   Div32      |"
                         .set PreDiv = 32
                         .set DivMask = T@0Div32
                       .elif (PreDivMin<64)&&defined(T@0Div64)
                         .message " |   Div64      |"
                         .set PreDiv = 64
                         .set DivMask = T@0Div64
                       .elif (PreDivMin<128)&&defined(T@0Div128)
                         .message " |   Div128     |"
                         .set PreDiv = 128
                         .set DivMask = T@0Div128
                       .elif (PreDivMin<256)&&defined(T@0Div256)
                         .message " |   Div256     |"
                         .set PreDiv = 256
                         .set DivMask = T@0Div256
                       .elif (PreDivMin<1024)&& defined(T@0Div8)
                         .message " |   Div1024    |"
                         .set PreDiv = 1024
                         .set DivMask = T@0Div1024
                       .else
                         .error "Timer not config"
                       .endif
                       .message  "+--------------+"
                 
                 
                       .set  Fn  = Fclk/(PreDiv * F_Ovf)
                       #if defined(__ATmega8__)
                       #elif defined(__ATmega64__)
                         .if @0==0
                           ldi   AL,     DivMask|(1<<WGM01)|(0<<WGM00)|COMTC0Toggle
                           out   TCCR0,  AL
                           ldi   AL,     Fn
                           out   OCR0,   AL
                         .elif @0==2
                           ldi   AL,     DivMask|(1<<WGM21)|(0<<WGM20)|COMTC2Toggle
                           out   TCCR2,  AL
                           ldi   AL,     Fn
                           out   OCR2,   AL
                         .endif
                       #endif
                     #else
                     #endif
                 
                 
                     .endmacro
                 
                     ;F_Ovf = Fclk / (PreDiv * (2^n - Fn))
                     ;PreDiv  = Fclk / ( F_Ovf * (2^n - Fn))
                 
                 
                 
                 
                 
                 
                   #if defined(__ATmega8__)
                   #elif defined(__ATmega64__)
                     .equ  PWM1A     = bit5
                     .equ  P_PWM1A   = PORTB
                     .equ  PWM1B     = bit6
                     .equ  P_PWM1B   = PORTB
                   #endif
                 
                   ;###############################################################################
                   ;###############################################################################
                 
                   ;###############################################################################
                   ;опредение переменных для работы с таймерами/счетчиками.
                   ;###############################################################################
                   ;Table 42. Waveform Generation Mode Bit Description
                   ;---------------------------------------------------------------------|
                   ;Mode | WGM21 | WGM20 | Timer/Counter      | TOP |  Update  | TOV2    |
                   ;     | (CTC2)| (PWM2)| Mode of Operation  |     | of OCR2  | Flag Set|
                   ;---------------------------------------------------------------------|
                   ; 0   |   0   |   0   | Normal             |0xFF |Immediate | MAX     |
                   ; 1   |   0   |   1   | PWM, Phase Correct |0xFF |   TOP    | BOTTOM  |
                   ; 2   |   1   |   0   | CTC                |OCR2 |Immediate | MAX     |
                   ; 3   |   1   |   1   | Fast PWM           |0xFF |   TOP    | MAX     |
                   ;---------------------------------------------------------------------|
                   ;Note: 1. The CTC2 and PWM2 bit definition names are now obsolete.
                   ;Use the WGM21:0 definitions.
                   ;However, the functionality and location of these bits are compatible with
                   ;previous versions of the timer.
                   ;###############################################################################
                 
                   ;###############################################################################
                   ;Bit        |  7 |   6  |   5  |   4  |   3  |   2 |   1 |  0  |
                   ;TCCR2      |FOC2| WGM20| COM21| COM20| WGM21| CS22| CS21| CS20| ;OLD
                   ;TCCR2      |FOC2| PWM2 | COM21| COM20| CTC2 | CS22| CS21| CS20|
                   ;Read/Write |  W | R/W  | R/W  | R/W  | R/W  | R/W | R/W | R/W |
                   ;Init Value |  0 |   0  |   0  |   0  |   0  |   0 |   0 |  0  |
                   ;###############################################################################
                 
                 
                   .macro  mPWM2Init
                     ldi   ACC,  T2Div1|PWM_Fast|PWM_NoInv
                     out   TCCR2,  ACC
                     mPinOut PWM
                     mPinSET PWM
                   .endmacro
                 
                   .macro  mPWM2Stop
                     ldi   ACC,  T2_OFF
                     out   TCCR2,  ACC
                     mPinIn  PWM
                     mPinSET PWM
                   .endmacro
                 
                 
                   ;###############################################################################
                   ;For  ATmega8 & ATmega103 & ATmega64
                 
                   ;опредение переменных для работы с таймерами/счетчиками.
                 
                   ;Таймер/счетчик0  8 разрядный.
                   ;Тактируется от задающего генератора TCK, или TOSC1 RTC,
                   ;через делитель коэффициент деления 1,8,32,64,128,256,1024.
                   ;Регистр управления таймером/счетчиком0.
                   ;TCCR0-(The Timer/Counter0 Control Register)
                   #if defined(__ATmega8__)
                   #elif defined (__ATmega103__)|defined (__ATmega64__)
                 ; ;code specific for ATmega103
                 ;   ;Bits2,1,0-CS02,CS01,CS00:Clock Select
                 ;   ;Биты выбора тактовой частоты таймера/счетчика0
                 ;   ;       = 0b76543210
                 ;   .equ T0_OFF   = 0b00000000
                 ;   .equ T0Div1   = 0b00000001
                 ;   .equ T0Div8   = 0b00000010
                 ;   .equ T0Div32  = 0b00000011
                 ;   .equ T0Div64  = 0b00000100
                 ;   .equ T0Div128 = 0b00000101
                 ;   .equ T0Div256 = 0b00000110
                 ;   .equ T0Div1024  = 0b00000111
                   #endif
                 
                   ;mInit_TC0  T0Div8, 1 установить предделитель на 8 и разрешить прерывания от таймера
                   .macro  mInit_TC0 ;T0Div8, 1
                     ldi   ACC,  @0
                     out   TCCR0,  ACC
                     out   TCNT0,  ZERO  ;Clear T/C 0
                     .if @1
                       in    ACC,  TIMSK
                       ori   ACC,  @1
                       out   TIMSK,  ACC
                     .endif
                 
                   .endmacro
                   ;###############################################################################
                   ;###############################################################################
                 
                   ;###############################################################################
                 
                   #if defined(__ATmega8__)
                   #elif defined (__ATmega103__)
                   #endif
                   ;###############################################################################
                   ;###############################################################################
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                   ;###############################################################################
                 
                 
                   .macro  mInit_TC1
                     ldi   ACC   ,@0
                     out   TCCR1B,ACC
                   .endmacro
                 
                 
                 
                 
                   .macro  mPWM1Init
                     ;Timer/Counter 1 Control
                     ;Register A – TCCR1A
                     ;   7      6     5      4      3       2     1     0
                     ;COM1A1 COM1A0 COM1B1 COM1B0 COM1C1 COM1C0 WGM11 WGM10
                     
                     ;Timer/Counter 1 Control
                     ;Register B – TCCR1B
                     ; 7   |  6  |5|  4  |  3  | 2  | 1  | 0  |
                     ;ICNC1|ICES1|–|WGM13|WGM12|CS12|CS11|CS10|
                     
                     ldi   AL      ,0x80
                     mOut  TCCR1A  ,AL;
                     ldi   AL      ,0x14
                     mOut  TCCR1B  ,AL;
                     
                     
                     ldi   AL      ,0x00
                     mOut  OCR1AH  ,AL;
                     ldi   AL      ,0xf0
                     mOut  OCR1AL  ,AL;
                     
                     LDW   Z       ,(2500)
                     mOut  ICR1H   ,ZL;
                     mOut  ICR1L   ,ZH;
                 
                     mPinOut PWM1A
                     mPinSET PWM1A
                   .endmacro
                 
                   .macro mT1SetMode ;MODE,PREDIV,PWM1TYPE
                   .if 1
                   .endif
                     mIn   AL    ,TCCR1A
                     cbr   AL    ,0xff;(1<<WGM11)|(1<<WGM10)
                     ori   AL    ,(@0&0b0011)|@2
                 
                     mIn   AH    ,TCCR1B
                     .if @1>7
                       ; Ignore PREDIV
                       cbr   AH  ,(1<<WGM13)|(1<<WGM12)
                       ori   AH  ,((@0&0b1100)<<1)
                     .else       
                       cbr   AH  ,(1<<WGM13)|(1<<WGM12)|(1<<CS12)|(1<<CS11)|(1<<CS10)
                       ori   AH  ,((@0&0b1100)<<1)|@1
                     .endif
                 
                     mOut  TCCR1A  ,AL
                     mOut  TCCR1B  ,AH
                 
                 
                 
                     mPinOut PWM1A
                     mPinSET PWM1A
                 
                   .endmacro
                 
                   .macro mT3SetMode ;MODE,PREDIV,PWM1TYPE
                 
                     mIn   AL,     TCCR3A
                     cbr   AL,     0xff;(1<<WGM11)|(1<<WGM10)
                     ori   AL,     (@0&0b0011)|@2
                 
                     mIn   AH,     TCCR3B
                     .if @1>7
                       ; Ignore PREDIV
                       cbr   AH,     (1<<WGM33)|(1<<WGM32)
                       ori AH,     ((@0&0b1100)<<1)
                     .else
                       cbr   AH,     (1<<WGM33)|(1<<WGM32)|(1<<CS32)|(1<<CS31)|(1<<CS30)
                       ori   AH,     ((@0&0b1100)<<1)|@1|(1<<ICNC3)|(1<<ICES3)
                     .endif
                 
                     mOut  TCCR3A, AL
                     mOut  TCCR3B, AH
                 
                   .endmacro
                 
                 
                 
                   ;> >>>
                 
                 #else
                 #endif
                 
                 #endif
                 ;###############################################################################
                 ;#ifndef AL
                 ; #define AL r16
                 ;#else
                 ; #message "Info: AL already defined"
                 ;#endif
                 
                 ;###############################################################################
MacroEX.asm(45): warning: 
RTOSA/RTOSA.inc(24): macro 'alignD' called here
TankDemo.asm(67): 'RTOSA/RTOSA.inc' included form here
MacroEX.asm(46): +---------------------------------------+
MacroEX.asm(47): | Not used DATA. See NoUse in map file. |
MacroEX.asm(48): +---------------------------------------+
                 .list
                 ;###############################################################################
                 ;###############################################################################
                 
                 ;###############################################################################
                 .def  r_RND     = r7
                 .def  r_TaskS   = r2  ;Регистр состояния очереди задач
                 .def  r_CNTTASK = r10
                 ;###############################################################################
                 ;######Not ..."
                 ;#########################################################################
                 
                 ;###############################################################################
                 ;######################## Макросы ядра РТОС ####################################
                 ;###############################################################################
                 #define TicFreq 100 ; Частота таймерной службы
                 
                 #define GetTaskID(func) TP_ ## func - TaskProcs;
                 #define Task(func) TP_ ## func: .dw  func
                 #define ms * TicFreq/1000
                 #define s *TicFreq
                 
                 ;#define  Tpod  7500ms
                 ;#define  Tkz   50ms
                 ;#define  Tstick  2000ms
                 ;#define  TReklama  2000ms
                 ;#define  TMenu   2000ms
                 
                 ;mSetTimerTask {ProcName},{Time (min: 1; max: 65535)}
                 ;Example: mSetTimerTask fInitRisCurrentI,50ms
                 .macro mSetTimerTask
                   .if @1>(1<<16) || (@1==0)
                     .error "Time out range!!!"
                   .else
                     ldi   AL  ,GetTaskID(@0)
                     ldi   XL  ,low(@1)      ;
                     ldi   XH  ,high(@1)   ; ЗАдержка в милисекундах
                     rcall krSetTimer
                   .endif
                 .endmacro
                 
                 ;mSetTimerTaskID {GetTaskID(ProcName)},{Time (min: 1; max: 65535)}
                 ;Example: mSetTimerTaskID GetTaskID(fInitRisCurrentI),50ms
                 .macro mSetTimerTaskID
                   .if @1>(1<<16) || (@1==0)
                     .error "Time out range!!!"
                   .else
                     ldi   AL  ,@0
                     ldi   XL  ,low(@1)      ;
                     ldi   XH  ,high(@1)   ; ЗАдержка в милисекундах
                     rcall krSetTimer
                   .endif
                 .endmacro
                 
                 ;mClrTimer {GetTaskID(ProcName)}
                 ;Example: mClrTimerID GetTaskID(fInitRisCurrentI)
                 .macro mClrTimerID
                   ldi   AL  ,@0
                   rcall krClrTimer
                   ;
                 .endmacro
                 
                 ;mClrTimer {ProcName}
                 ;Example: mClrTimer fInitRisCurrentI
                 .macro mClrTimer
                   ldi   AL  ,GetTaskID(@0)
                   rcall krClrTimer
                   ;
                 .endmacro
                 
                 
                 ;==========================================================================
                 .macro mSendTask
                   push  AL
                   ldi   AL  ,GetTaskID(@0)  ; Обращение к процедуре через событийный диспетчер
                   rcall krSendTask        ;
                   pop   AL
                 .endmacro
                 
                 .macro mSendTask_AL
                   rcall krSendTask        ;
                 .endmacro
                 
                 .macro  mSendTaskIfSET
                   push  AL
                   ldi   AL          ,GetTaskID(@1)  ; Обращение к процедуре через событийный диспетчер
                   .if @0<8
                     sbrc  r_Flags   ,@0
                   .else
                     sbrc  r_FlagsH  ,@0&0b111
                   .endif
                   rcall krSendTask
                   pop   AL
                 .endmacro
                 
                 .macro  mSendTaskIfSET_AL
                   .if @0<8
                     sbrc  r_Flags   ,@0
                   .else
                     sbrc  r_FlagsH  ,@0&0b111
                   .endif
                   rcall krSendTask
                 .endmacro
                 
                 .macro  mSendTaskIfSETC
                   push  AL
                   ldi   AL          ,GetTaskID(@1)  ; Обращение к процедуре через событийный диспетчер
                   .if @0<8
                     sbrc  r_Flags   ,@0
                     rcall krSendTask
                     sbrc  r_Flags   ,@0
                     cbr   r_Flags   ,(1<<@0)
                   .else
                     sbrc  r_FlagsH  ,@0&0b111
                     rcall krSendTask
                     sbrc  r_FlagsH  ,@0&0b111
                     cbr   r_FlagsH  ,1<<(@0&0b111)
                   .endif
                   pop   AL
                 .endmacro
                 
                 .macro  mSendTaskIfSETC_AL
                   .if @0<8
                     sbrc  r_Flags   ,@0
                     rcall krSendTask
                     sbrc  r_Flags   ,@0
                     cbr   r_Flags   ,(1<<@0)
                   .else
                     sbrc  r_FlagsH  ,@0&0b111
                     rcall krSendTask
                     sbrc  r_FlagsH  ,@0&0b111
                     cbr   r_FlagsH  ,1<<(@0&0b111)
                   .endif
                 .endmacro
                 
                 .macro  mSendTaskIfCLR
                   push  AL
                   ldi   AL          ,GetTaskID(@1)  ; Обращение к процедуре через событийный диспетчер
                   .if @0<8
                     sbrs  r_Flags   ,@0
                   .else
                     sbrs  r_FlagsH  ,@0&0b111
                   .endif
                   rcall krSendTask
                   pop   AL
                 .endmacro
                 
                 .macro  mSendTaskIfCLR_AL
                   .if @0<8
                     sbrs  r_Flags   ,@0
                   .else
                     sbrs  r_FlagsH  ,@0&0b111
                   .endif
                   rcall krSendTask
                 .endmacro
                 
                 .macro  mSendTaskIfCLRS
                   push  AL
                   ldi   AL          ,GetTaskID(@1)  ; Обращение к процедуре через событийный диспетчер
                   .if @0<8
                     sbrs  r_Flags   ,@0
                     rcall krSendTask
                     sbrs  r_Flags   ,@0
                     sbr   r_Flags   ,(1<<@0)
                   .else
                     sbrs  r_FlagsH  ,@0&0b111
                     rcall krSendTask
                     sbrs  r_FlagsH  ,@0&0b111
                     sbr   r_FlagsH  ,1<<(@0&0b111)
                   .endif
                   pop   AL
                 .endmacro
                 
                 .macro  mSendTaskIfCLRS_AL
                   .if @0<8
                     sbrs  r_Flags   ,@0
                     rcall krSendTask
                     sbrs  r_Flags   ,@0
                     sbr   r_Flags   ,(1<<@0)
                   .else
                     sbrs  r_FlagsH  ,@0&0b111
                     rcall krSendTask
                     sbrs  r_FlagsH  ,@0&0b111
                     sbr   r_FlagsH  ,1<<(@0&0b111)
                   .endif
                 .endmacro
                 
                 .macro mSetTask
                   ldi   AL  ,@0     ; Обращение к процедуре через событийный диспетчер
                   rcall krSendTask    ;
                 .endmacro
                 
                 ;==========================================================================
                 
                 .macro mTimerService
                 #define Counter r18
                 ; in    TmpSREG,  SREG
                 ; push  AL        ; Сохранение регистра AL
                   mPUSHw  Z         ; сохранение Регистра Z
                   push  Counter     ; сохранение Регистра Counter
                 
                   ldi   ZL      ,low(TimersPool)    ; Загрузка с регистр Z адреса RAM,
                   ldi   ZH      ,high(TimersPool)   ; по которому находится информация о таймерах
                   ldi   Counter ,TIMERSPOOLSIZE  ; максимальное количество таймеров
                 
                  lTimerService_Loop:
                   ld    AL  ,z        ; AL = [Z] ; Получить номер события
                   cpi   AL  ,0xFF        ; Проверить на "NOP"
                   breq lTimerService_Next   ; Если NOP то переход к следующей позиции
                 
                   ;<
                   push  AH
                   ldd   AL  ,z+1      ;Чтение младшей части счётчика
                   ldd   AH  ,z+2      ;Чтение старшей части счётчика
                   subi  AL  ,low(1)   ;Уменьшение младшей части счётчика на 1
                   sbci  AH  ,high(1)    ;Уменьшение старшей части счётчика на 1
                   std   z+1 ,AL
                   std   z+2 ,AH
                   or    AL  ,AH
                   pop   AH
                   brne lTimerService_Next   ; Счёт не окончен
                   ;>
                 
                   ld    AL  ,z        ; Получить номер события
                   rcall krSendTask      ; послать в системную очередь задач
                 
                   ldi   AL  ,0xFF       ; = NOP (задача выполнена, таймер самоудаляется)
                   st    z   ,AL       ; Clear Event
                 
                  lTimerService_Next:
                 ;   subi  ZL,low(-3)      ; Skip Counter
                 ; sbci  ZH,high(-3)     ; Z+=3 - переход к следующему таймеру
                   adiw  ZL  ,3
                   dec   Counter       ; счетчик таймеров
                   brne lTimerService_Loop   ; Loop
                 
                   pop   Counter       ; восстанавливаем переменные
                   mPOPw   Z
                 ; pop   AL          ; Восстанавливаем регистры
                 ; out   SREG,   TmpSREG
                 #undef  Counter
                 .endmacro
                 
                 ;======================================================================================
                 .macro  mINIT_RTOS
                   out   SREG  ,ZERO     ; Инициализация SREG
                   clr   r_TaskS
                   rcall fClearTimers    ; Очистить список таймеров РТОС
                   rcall fClearTaskQueue ; Очистить очередь событий РТОС
                 ;< Настройка TC0 ;T/C 0 - Init
                   ldi   AL    ,T0Div1024 ;Freq/1024 (From prescaler)
                   out   TCCR0 ,AL
                   in    AL    ,TIMSK
                   ori   AL    ,(1<<TOIE0);Bit 0 - TOIE0: Timer/Counter0 Overflow Interrupt Enable
                   out   TIMSK ,AL
                 ;> Настройка TC0
                 .endmacro
                 
                 ;###############################################################################
                 ;###############################################################################
                 
                 ;
                 ;.set Fn  = ((1<<N_Cnt)*PreDiv*F_T0_Ovf  - Fclk) / (PreDiv * F_T0_Ovf)
                 
                 .macro mInitTicOS ;
                   .set  F_T0_Ovf  = @0;100
                   .set  N_Cnt     = 8
                   .set  FnMin     = 0
                   .set  FnMax     = (1<<N_Cnt) - 1
                 
                   .set  PreDivMin = Fclk / ( F_T0_Ovf * ((1<<N_Cnt) - FnMin))
                   .set  PreDivMax = Fclk / ( F_T0_Ovf * ((1<<N_Cnt) - FnMax))
                 
                 #if defined(__ATmega8__)||defined(__ATmega64__)
                  #message "PreDiv for ATmega8"
                   .message  " +--------------+"
                   .message  " |PreDiv for TC0|"
                 
                   .if PreDivMin < 1
                     .message " |   Div1       |"
                     .set PreDiv = 1
                     .set Val_TCCR0 = T0Div1
                   .elif PreDivMin < 8
                     .message " |   Div8       |"
                     .set PreDiv = 8
                     .set Val_TCCR0 = T0Div8
                   .elif PreDivMin < 64
                     .message " |   Div64      |"
                     .set PreDiv = 64
                     .set Val_TCCR0 = T0Div64
                   .elif PreDivMin < 256
                     .message " |   Div256     |"
                     .set PreDiv = 256
                     .set Val_TCCR0 = T0Div256
                   .elif PreDivMin < 1024
                     .message " |   Div1024    |"
                     .set PreDiv = 1024
                     .set Val_TCCR0 = T0Div1024
                   .else
                     .error "Timer 0 not config"
                   .endif
                   .message  " +--------------+"
                 
                   ldi   AL    ,Val_TCCR0
                   out   TCCR0 ,AL
                 #else
                 #endif
                 
                   .set  Fn  = Fclk/(PreDiv * F_T0_Ovf)
                 
                 ; .set  Fn  = ((1<<N_Cnt)*PreDiv*F_T0_Ovf  - Fclk) / (PreDiv * F_T0_Ovf)
                   .set  Re_TCNT0  = 256-Fn
                 
                 .endmacro
                 
                 ;F_T0_Ovf = Fclk / (PreDiv * (2^n - Fn))
                 ;PreDiv  = Fclk / ( F_T0_Ovf * (2^n - Fn))
                 
                 .macro  mINIT_RTOSA
                   out   SREG,   ZERO      ; Инициализация SREG
                   clr   r_TaskS
                   clr   r_CNTTASK
                   rcall krClearTimers   ; Очистить список таймеров РТОС
                   rcall krClearTaskQueue  ; Очистить очередь событий РТОС
                 
                   #if defined(__ATmega8__)
                   #elif defined(__ATmega64__)
                     ;< Настройка TC0 ;T/C 0 - Init
                     
                     ; ldi   AL,   T0Div1024 ;Freq/1024 (From prescaler)
                     ; out   TCCR0,    AL
                       mInitTicOS  TicFreq
                     
                       in    AL    ,TIMSK
                       ori   AL    ,(1<<OCIE0);Bit 1 - OCIE0: Timer/Counter0 Output Compare Match Interrupt Enable
                       
                       out   TIMSK ,AL
                     
                       rjmp  mINIT_RTOSA_Ret
                     
                     ;< Interrupt
                       .set  OldPC = pc
                       .org  OC0addr ; Timer/Counter0 Compare Match
                         rjmp INT_OC0  ;Timer/Counter0 Compare Match Handler
                       .org  OldPC
                     ;> Interrupt
                     
                     
                     
                     INT_OC0:  ;Timer/Counter0 Compare Match Handler
                       in    TmpSREG,  SREG
                       push  AL
                       push  AH
                       ;Place your code here
                       ldi   AL    ,Fn
                       in    AH    ,OCR0
                       add   AL    ,AH
                       out   OCR0  ,AL
                       
                       mTimerService
                       pop   AH
                       pop   AL
                       out   SREG  ,TmpSREG
                     reti
                     ;> Настройка TC0
                 
                 
                   #endif
                 
                 
                  mINIT_RTOSA_Ret:
                 .endmacro
                 
                 ; mkrMemFill v_LCDBuf,' ',LCDBUFFSIZE
                 .macro  mkrMemFill
                   LDW   Y   ,@0
                   ldi   AL  ,@1
                   ldi   AH  ,@2
                   rcall krMemFill
                 .endmacro
                 
                 ;.include "RTOSA/TimerCntrs.inc"
                 .include  "ADC.inc" ;
                 
                 ;Updated: "2010-10-02" "00:13"
                 ;Updated: "2010-12-14" "18:52"
                 
                 	.list
                 	.listmac
                 	;##########################################################
                 	;##########################################################
                 
                 	;###############################################################################
                +
                +.equ fADCInit = ( pc )
                 	PROC fADCInit
000178 2700      		clr		AL
                +
                +.if PORTF - 1 > ( 0x3f )
000179 9300 0061+sts PORTF - 1 , AL
                +.else 
                +out PORTF - 1 , AL
                 		mOut		PORTF-1,	AL
                +
                +.if PORTF > ( 0x3f )
00017b 9300 0062+sts PORTF , AL
                +.else 
                +out PORTF , AL
                 		mOut		PORTF,		AL
                 
                 ;		ldi		AL,		Aref_AREF<<REFS0|1<<ADLAR|ADC0	;Опорное напряжение AREF
00017d e600      		ldi		AL,		Aref_AVCC<<REFS0|1<<ADLAR|ADC0	;Опорное напряжение AVCC
                 ;		ldi		AL,		Aref_256<<REFS0|1<<ADLAR|ADC0	;Опорное напряжение 2.56 V
00017e b907      		out		ADMUX,		AL
                 
00017f ea0f      		ldi		AL,		(1<<ADEN)|ADCFR<<ADATE|ADCIE<<ADIE|(log2(DivADC)<<ADPS0)
000180 b906      		out		ADCSRA,		AL
                +
                +.if ADCSRB > ( 0x3f )
000181 9230 008e+sts ADCSRB , ZERO
                +.else 
                +out ADCSRB , ZERO
                 		mOut	ADCSRB,		ZERO	;ADC Free Running Select
                 
                 	;	cbi		ADCSRA,		ADSC	;ADC Start Conversion
000183 9a36      		sbi		ADCSRA,		ADSC	;ADC Start Conversion
                 	;	cbi		ADCSRA,		ADIF
                 
000184 9508      		ret
                 ;.equ ADC0		= 0b00000
                 ;.equ ADC1		= 0b00001
                 ;.equ ADC2		= 0b00010
                 ;.equ ADC3		= 0b00011
                 ;.equ ADC4		= 0b00100
                 ;.equ ADC5		= 0b00101
                 ;.equ ADC6		= 0b00110
                 ;.equ ADC7		= 0b00111
                 ;.equ ADCVBG	= 0b11110	;1.22V (VBG)
                 ;.equ ADCGND	= 0b11111	;0V (GND)
                 ;	 ADCListCanal:
                 ;	 	.db	ADC0,ADC1,ADC2,ADC3,
                 	 	
                +
                +.equ SizeOf_fADCInit = ( pc - fADCInit )
                 	ENDP fADCInit
                 	;###############################################################################
                 	;###############################################################################
                 
                 
                 	;###############################################################################
                 	;Interrupting routine the ADC change meagering canal
                +
                +.equ fADCInt = ( pc )
                 	PROC fADCInt
                 	#define	TmpADMUX	AH
                 	#define	CurCanal	AL
                 	#define	CurVal		TmpADMUX
                 
000185 b66f      		in		TmpSREG,	SREG
                 		;< Place your code here
                 
000186 930f      		push	CurCanal
000187 931f      		push	TmpADMUX
                 
                 		;< Gets value from the current canal
                +
000188 93df     +push YH
000189 93cf     +push YL
                 		mPUSHw	Y
00018a b107      		in		CurCanal,	ADMUX
00018b 950a      		dec		AL
00018c 7007      		andi	AL,	(ADC_NCanal-1);
                 
                +
00018d e0d1     +ldi YH , high ( ( v_ADC ) )
00018e e8c0     +ldi YL , low ( ( v_ADC ) )
                 		LDW		Y,	(v_ADC)
                 ;		lsl		CurCanal	;CurCanal = CurCanal*2
00018f 0fc0      		add		YL,			CurCanal
000190 1dd3      		adc		YH,			ZERO
                 	;	;< Сохраним предыдущее значение в памяти
                 	;	ld		CurVal,		Y
                 	;	std		y+1,		CurVal
                 	;	;> Сохраним предыдущее значение в памяти
                 		;< Reading and Saving the current value into RAM
000191 b114      		in		CurVal,		ADCL
                 	;	sbrc	CurCanal,	3
                 	;	st		y+,			CurVal
000192 b115      		in		CurVal,		ADCH
000193 8318      		st		y,			CurVal
                 		;> Reading and Saving the current value into RAM
                +
000194 91cf     +pop YL
000195 91df     +pop YH
                 		mPOPw	Y
                 		;> Gets value from the current canal
                 
                 		;< Calculating the next canal
000196 b117      		in		TmpADMUX,	ADMUX
000197 2f01      		mov		AL,		TmpADMUX
000198 9503      		inc		AL
000199 7007      		andi	AL,	(ADC_NCanal-1)	;
00019a f409      		brne (pc+1)+1
                +
                +
                +.if flg_ADC < 8
00019b 6064     +ori r_Flags , 1 << flg_ADC
                +.else 
                +ori r_FlagsH , 1 << ( flg_ADC & 0b111 )
                 		  mFlgSet flg_ADC ;Converting complete. For all ADC canals
00019c 7f18      		cbr		TmpADMUX,	(ADC_NCanal-1);
00019d 2b10      		or		TmpADMUX,	AL
                 		;> Calculating the next canal
                 
                 		;< Sets next canal
00019e b917      		out		ADMUX,		TmpADMUX
                 		;> Sets next canal
                 
                 		;< Fix Bug AVRStudio
                 	;	sbi		ADCSRA,		ADSC	;ADC Start Conversion
                 		;> Fix Bug AVRStudio
                 
00019f 911f      		pop		TmpADMUX
0001a0 910f      		pop		CurCanal
                 
                 	;	mStop	;Debug into Proteus
                 		;> Place your code here
                 
0001a1 be6f      		out		SREG,		TmpSREG
0001a2 9518      		reti
                 	#undef		TmpADMUX
                 	#undef		CurCanal
                +
                +.equ SizeOf_fADCInt = ( pc - fADCInt )
                 	ENDP fADCInt
                 
                 
                 ;< Interrupt
                 	.set	OldPC	=	pc
                 .org	ADCCaddr	;ADC Interrupt Vector Address
00002a c15a      	rjmp fADCInt		;ADC Conversion Complete Handler
                 	.org	OldPC
                 ;> Interrupt
                 
                 #else
                 #endif
                 ;###############################################################################
                 ;###############################################################################
                 
                 ;###############################################################################
                 
                 ;S_Alex
                 .include  "KBD_3x1.inc" ;
                 
                 ;Updated: "2011-03-07" "11:36"
                 
                 
                 
                 
                 	.list
                 	.listmac
                 	;##########################################################
                 	;##########################################################
                 
                 	
                 	.include	"KBD_3x1.asm"
                 
                 ;Updated: "2011-03-07" "19:41"
                 
                +
                +.equ fKBDInit = ( pc )
                 PROC fKBDInit
0001a3 9230 0188 	sts		(v_KBD_LK),	ZERO
0001a5 9508      	ret
                 
                +
                +.equ SizeOf_fKBDInit = ( pc - fKBDInit )
                 ENDP fKBDInit
                 
                +
                +.equ fKBDScan = ( pc )
                 PROC fKBDScan
                 #define SREG_ r19
0001a6 933f        push  SREG_
                   ;< critical section
0001a7 b73f        in    SREG_,  SREG  ; Critical Section
0001a8 94f8        cli
                 
                 
                +
0001a9 930f     +push r16
                +.if ( P_SB2 - 1 ) > ( 0x3f )
                +lds r16 , P_SB2 - 1
0001aa b304     +.else 
                +in r16 , P_SB2 - 1
0001ab fb00     +.endif 
0001ac 910f     +bst r16 , SB2
                 	mPinGetDir	SB2
0001ad f910      	bld		AH,	bit0
                +
0001ae 930f     +push r16
                +.if ( P_SB3 - 1 ) > ( 0x3f )
                +lds r16 , P_SB3 - 1
0001af b304     +.else 
                +in r16 , P_SB3 - 1
0001b0 fb01     +.endif 
0001b1 910f     +bst r16 , SB3
                 	mPinGetDir	SB3
0001b2 f911      	bld		AH,	bit1
                +
0001b3 930f     +push r16
                +.if ( P_SB4 - 1 ) > ( 0x3f )
                +lds r16 , P_SB4 - 1
0001b4 b304     +.else 
                +in r16 , P_SB4 - 1
0001b5 fb02     +.endif 
0001b6 910f     +bst r16 , SB4
                 	mPinGetDir	SB4
0001b7 f912      	bld		AH,	bit2
                 
                +
                +.if ( P_SB2 - 1 ) > ( 0x3f )
                +push r16
0001b8 98a0     +lds r16 , P_SB2 - 1
                +cbr r16 , ( 1 << SB2 )
                 	mPinIn	SB2
                +
                +.if ( P_SB3 - 1 ) > ( 0x3f )
                +push r16
0001b9 98a1     +lds r16 , P_SB3 - 1
                +cbr r16 , ( 1 << SB3 )
                 	mPinIn	SB3
                +
                +.if ( P_SB4 - 1 ) > ( 0x3f )
                +push r16
0001ba 98a2     +lds r16 , P_SB4 - 1
                +cbr r16 , ( 1 << SB4 )
                 	mPinIn	SB4
                +
                +.if P_SB2 > ( 0x3f )
                +push r16
0001bb 9aa8     +push r17
                +in r17 , SREG
                 	mPinSET	SB2
                +
                +.if P_SB3 > ( 0x3f )
                +push r16
0001bc 9aa9     +push r17
                +in r17 , SREG
                 	mPinSET	SB3
                +
                +.if P_SB4 > ( 0x3f )
                +push r16
0001bd 9aaa     +push r17
                +in r17 , SREG
                 	mPinSET	SB4
                 	
0001be e000      	ldi AL, 0
0001bf 950a      	  dec AL
0001c0 f7f1        brne (pc)-1
                 
0001c1 ef0f      	ser		AL
                +
0001c2 930f     +push r16
                +.if ( P_SB2 - 2 ) > ( 0x3f )
                +lds r16 , P_SB2 - 2
0001c3 b303     +.else 
                +in r16 , P_SB2 - 2
0001c4 fb00     +.endif 
0001c5 910f     +bst r16 , SB2
                 	mPinState	SB2
0001c6 f900      	bld		AL,	bit0
                +
0001c7 930f     +push r16
                +.if ( P_SB3 - 2 ) > ( 0x3f )
                +lds r16 , P_SB3 - 2
0001c8 b303     +.else 
                +in r16 , P_SB3 - 2
0001c9 fb01     +.endif 
0001ca 910f     +bst r16 , SB3
                 	mPinState	SB3
0001cb f901      	bld		AL,	bit1
                +
0001cc 930f     +push r16
                +.if ( P_SB4 - 2 ) > ( 0x3f )
                +lds r16 , P_SB4 - 2
0001cd b303     +.else 
                +in r16 , P_SB4 - 2
0001ce fb02     +.endif 
0001cf 910f     +bst r16 , SB4
                 	mPinState	SB4
0001d0 f902      	bld		AL,	bit2
0001d1 9500      	com		AL
                 	
0001d2 fb10      	bst		AH,	bit0
                +
                +.if ( P_SB2 - 1 ) > ( 0x3f )
                +push r16
0001d3 f40e     +lds r16 , P_SB2 - 1
0001d4 9aa0     +brtc ( pc + 1 ) + 1
0001d5 f00e     +sbr r16 , ( 1 << SB2 )
0001d6 98a0     +brts ( pc + 1 ) + 1
                +cbr r16 , ( 1 << SB2 )
                +sts P_SB2 - 1 , r16
                 	mPinSetDir	SB2
0001d7 f911      	bld		AH,	bit1
                +
                +.if ( P_SB3 - 1 ) > ( 0x3f )
                +push r16
0001d8 f40e     +lds r16 , P_SB3 - 1
0001d9 9aa1     +brtc ( pc + 1 ) + 1
0001da f00e     +sbr r16 , ( 1 << SB3 )
0001db 98a1     +brts ( pc + 1 ) + 1
                +cbr r16 , ( 1 << SB3 )
                +sts P_SB3 - 1 , r16
                 	mPinSetDir	SB3
0001dc f912      	bld		AH,	bit2
                +
                +.if ( P_SB4 - 1 ) > ( 0x3f )
                +push r16
0001dd f40e     +lds r16 , P_SB4 - 1
0001de 9aa2     +brtc ( pc + 1 ) + 1
0001df f00e     +sbr r16 , ( 1 << SB4 )
0001e0 98a2     +brts ( pc + 1 ) + 1
                +cbr r16 , ( 1 << SB4 )
                +sts P_SB4 - 1 , r16
                 	mPinSetDir	SB4
                 	
0001e1 bf3f        out   SREG, SREG_ ; leave Critical Section
                   ;> critical section
0001e2 913f        pop   SREG_
0001e3 9508      	ret
                 #undef  SREG_
                 
                +
                +.equ SizeOf_fKBDScan = ( pc - fKBDScan )
                 ENDP fKBDScan
                 
                 ;PROC fKBDGetKey
                 ;  rcall fKBDScan
                 ;  tst		AL
                 ;  breq LfKBDGetKeyNoK
                 ;  
                 ;  lds		AH,					(v_KBD_LK)
                 ;  cp		AL,					AH
                 ;  brne LfKBDGetKeyEnd
                 ;  sts		(v_KBD_LK), AL
                 ;  
                 ;  lds		AH,					(v_KBD_TK)
                 ;  dec		AH
                 ;  sts   (v_KBD_TK), AH
                 ;  
                 ;;
                 ;	brne LfKBDGetKeyEnd
                 ;  mFlgSet	flg_AnyKey
                 ;  lds		AH,					(v_KBD_AR)
                 ;  dec		AH
                 ;  cpi		AH,					KEYAUTOREP
                 ;  brsh (pc+1)+1
                 ;  	ldi	AH,	KEYAUTOREP
                 ;  sts   (v_KBD_TK), AH
                 ;;    
                 ;  rjmp     LfKBDGetKeyEnd
                 ;LfKBDGetKeyNoK:
                 ;  mFlgClr	flg_AnyKey
                 ;  ldi		AL,	KEYREPTIME
                 ;  sts   (v_KBD_TK), AL
                 ;  clr		AL
                 ;LfKBDGetKeyEnd:    
                 ;  
                 ;  sts   (v_KBD_LK), AL
                 ;  
                 ;NoFun:
                 ;  ret
                 ;	
                 ;	ret
                 ;
                 ;ENDP fKBDGetKey
                 
                 
                 ;S_Alex
                 ;>
                 #else
                 #endif
                 .list
                 .listmac
                 .include  "NCod.inc"  ;
                 
                 ;Updated: "2011-03-06" "21:44"
                 
                 #ifndef  NCOD_INC
                 	#define	NCOD_INC 1
                 	;< 
                 	;###############################################################################
                 	#define	NCLEFT    0x0F
                 	#define	NCRIGHT   0xF0
                 	
                 	;###############################################################################
                 	.macro	mInitEnCoder
                 		rcall fInitEnCoder
                 	.endmacro
                 	;###############################################################################
                 	;###############################################################################
                 	
                 	;###############################################################################
                 		.include  "NCod.asm"
                 
                 ;Updated: "2010-11-01" "00:31"
                 
                 
                 .list
                 .listmac
                 
                +
                +.equ fNCodInit = ( pc )
                 PROC fNCodInit
                +
                +.if ( P_NCodL - 1 ) > ( 0x3f )
                +push r16
0001e4 9813     +lds r16 , P_NCodL - 1
                +cbr r16 , ( 1 << NCodL )
                 	mPinIn	NCodL
                +
                +.if ( P_NCodR - 1 ) > ( 0x3f )
                +push r16
0001e5 9814     +lds r16 , P_NCodR - 1
                +cbr r16 , ( 1 << NCodR )
                 	mPinIn	NCodR
                +
                +.if P_NCodL > ( 0x3f )
                +push r16
0001e6 981b     +push r17
                +in r17 , SREG
                 	mPinCLR NCodL	;Off PullUp resistor
                +
                +.if P_NCodR > ( 0x3f )
                +push r16
0001e7 981c     +push r17
                +in r17 , SREG
                 	mPinCLR NCodR	;Off PullUp resistor
                 
0001e8 2700      	clr		AL
0001e9 9300 018b 	sts		(v_ENLast),		AL
0001eb 9300 018c 	sts		(v_ENState),	AL
0001ed 9300 018d 	sts		(v_ENInput),	AL
                 
                 	
                +
0001ef 930f     +push AL
0001f0 e005     +ldi AL , TP_fENGet - TaskProcs
0001f1 d71e     +rcall krSendTask
0001f2 910f     +pop AL
                 	mSendTask fENGet
                 
0001f3 9508      	ret
                 	
                 ;< Interrupt
                 	
                +
                +.equ SizeOf_fNCodInit = ( pc - fNCodInit )
                 ENDP fNCodInit
                 ;################################## FUNCTION ###################################
                 ;Name of function:
                  ; fENGet
                 ;Input:
                  ; -
                 ;Return:
                  ; -
                 ;Description:
                 ;
                 
                +
                +.equ fENGet = ( pc )
                 PROC fENGet
                 #define	rvTmp	r19
0001f4 933f      	push		rvTmp
0001f5 931f      	push		AH
                 
                 
                 	;< Get current state of encoder
0001f6 9100 018b 	lds		AL,	(v_ENLast)
0001f8 0f00      	lsl		AL
                +
0001f9 930f     +push r16
                +.if ( P_NCodL - 2 ) > ( 0x3f )
                +lds r16 , P_NCodL - 2
0001fa b101     +.else 
                +in r16 , P_NCodL - 2
0001fb fb03     +.endif 
0001fc 910f     +bst r16 , NCodL
                 	mPinState	NCodL
0001fd f900      	bld		AL,	bit0
                +
0001fe 930f     +push r16
                +.if ( P_NCodR - 2 ) > ( 0x3f )
                +lds r16 , P_NCodR - 2
0001ff b101     +.else 
                +in r16 , P_NCodR - 2
000200 fb04     +.endif 
000201 910f     +bst r16 , NCodR
                 	mPinState	NCodR
000202 f904      	bld		AL,	bit4
000203 9300 018b 	sts		(v_ENLast),	AL
                 	;> Get current state of encoder
                 
                 	;<	Contact bounce suppression.
000205 9130 018c 	lds		rvTmp,	(v_ENState)
000207 2f10      	mov		AH,	AL
                 	
                 	;< For NCodL
000208 700f      	andi	AL,	0x0F
000209 f409      	brne	(pc+1)+1
00020a 7f3e      		cbr	rvTmp,	(1<<bit0)
00020b 9500      	com		AL
00020c 700f      	andi	AL,	0x0F
00020d f409      	brne	(pc+1)+1
00020e 6031      		ori	rvTmp,	(1<<bit0)
                 	;> For NCodL
                 
                 	;< For NCodR
00020f 7f10      	andi	AH,	0xF0
000210 f409      	brne	(pc+1)+1
000211 7e3f      		cbr	rvTmp,	(1<<bit4)
000212 9510      	com		AH
000213 7f10      	andi	AH,	0xF0
000214 f409      	brne	(pc+1)+1
000215 6130      		ori	rvTmp,	(1<<bit4)
                 	;> For NCodR
                 	;>	Contact bounce suppression
                 	
                 	
                 	
000216 9100 018c 	lds		AL,	(v_ENState)
000218 2703      	eor		AL,	rvTmp
000219 f111      	breq	lENGet_NoChange	;	AL = 0
00021a 7131      		andi	rvTmp,	(1<<bit4)|(1<<bit0) ;
00021b 9330 018c 		sts		(v_ENState),	rvTmp
                 		
00021d 2f10      		mov		AH,	AL
                 		
00021e 700f      		andi	AL,	0x0F
00021f f069      		breq NoMoveL
                 	 L_Left:
000220 9100 010e 		lds		AL								,(v_CrawlerCurPosL)
000222 9503      		inc		AL
000223 9300 010e 		sts		(v_CrawlerCurPosL),AL
                 		
                 		;< Checking the left crawler position
000225 9130 010f 		lds		rvTmp	,(v_CrawlerPosL)
000227 1730      		cp		rvTmp	,AL
000228 f421      		brne (pc+1)+1+2+1
                +
                +
                +.if flg_StepL < 8
000229 6160     +ori r_Flags , 1 << flg_StepL
                +.else 
                +ori r_FlagsH , 1 << ( flg_StepL & 0b111 )
                 			mFlgSet flg_StepL					;1b
00022a 9100 012a 			lds	AL	,(v_Event_StepL)	;2b
00022c d6e3      			rcall krSendTask					;1b
                 ;			andi	rvSpeedLR,	0x0F
                 
                 		;> Checking the left crawler position
                 		 
                  NoMoveL:
                  	
00022d 7f10      		andi	AH,	0xF0
00022e f069      		breq NoMoveR
                 	 L_Right:
00022f 9100 0110 		lds		AL								,(v_CrawlerCurPosR)
000231 9503      		inc		AL
000232 9300 0110 		sts		(v_CrawlerCurPosR),AL
                 		
                 		;< Checking the right crawler position
000234 9130 0111 		lds		rvTmp	,(v_CrawlerPosR)
000236 1730      		cp		rvTmp	,AL
000237 f421      		brne (pc+1)+1+2+1
                +
                +
                +.if flg_StepR < 8
000238 6260     +ori r_Flags , 1 << flg_StepR
                +.else 
                +ori r_FlagsH , 1 << ( flg_StepR & 0b111 )
                 			mFlgSet flg_StepR					;1b
000239 9100 012b 			lds	AL	,(v_Event_StepR)	;2b
00023b d6d4      			rcall krSendTask					;1b
                 ;			andi	rvSpeedLR,	0xF0
                 
                 		;> Checking the right crawler position
                 
                  NoMoveR:
                  
                  lENGet_NoChange:
                 
                  lENGet_Exit:
                  ;
                  
                +
00023c 930f     +push AL
00023d e005     +ldi AL , TP_fENGet - TaskProcs
00023e d6d1     +rcall krSendTask
00023f 910f     +pop AL
                 	mSendTask fENGet
000240 911f      	pop		AH
000241 913f      	pop		rvTmp
000242 9508      	ret
                 #undef	rvTmp
                +
                +.equ SizeOf_fENGet = ( pc - fENGet )
                 ENDP fENGet
                 
                 
                 
                 
                 	;###############################################################################
                 	;>
                 #else
                 #endif
                 .list
                 .listmac
                 .include  "Drive.asm" ;
                 
                 ;Updated: "2010-11-01" "00:31"
                 
                +
                +.equ fDrvInit = ( pc )
                 PROC fDrvInit
                 	;< Sets the directions of Pin 
                +
                +.if P_DrvRF > ( 0x3f )
                +push r16
000243 98d9     +push r17
                +in r17 , SREG
                   	mPinCLR	DrvRF	;	Right Crawler motor
                +
                +.if P_DrvRR > ( 0x3f )
                +push r16
000244 98d8     +push r17
                +in r17 , SREG
                   	mPinCLR	DrvRR	;	Right Crawler motor
                +
                +.if P_DrvLR > ( 0x3f )
                +push r16
000245 98de     +push r17
                +in r17 , SREG
                   	mPinCLR	DrvLR	;	Left Crawler motor
                +
                +.if P_DrvLF > ( 0x3f )
                +push r16
000246 98df     +push r17
                +in r17 , SREG
                   	mPinCLR	DrvLF	;	Left Crawler motor
                   
                +
                +.if ( P_DrvRF - 1 ) > ( 0x3f )
                +push r16
000247 9ad1     +lds r16 , P_DrvRF - 1
                +sbr r16 , ( 1 << DrvRF )
                   	mPinOut	DrvRF	;	Right Crawler motor
                +
                +.if ( P_DrvRR - 1 ) > ( 0x3f )
                +push r16
000248 9ad0     +lds r16 , P_DrvRR - 1
                +sbr r16 , ( 1 << DrvRR )
                   	mPinOut	DrvRR	;	Right Crawler motor
                +
                +.if ( P_DrvLR - 1 ) > ( 0x3f )
                +push r16
000249 9ad6     +lds r16 , P_DrvLR - 1
                +sbr r16 , ( 1 << DrvLR )
                   	mPinOut	DrvLR	;	Left Crawler motor
                +
                +.if ( P_DrvLF - 1 ) > ( 0x3f )
                +push r16
00024a 9ad7     +lds r16 , P_DrvLF - 1
                +sbr r16 , ( 1 << DrvLF )
                   	mPinOut	DrvLF	;	Left Crawler motor
                 	;> Sets the directions of Pin
                 
                 
                +
                +.if ETIMSK > ( 0x3f )
00024b 9100 007d+lds AL , ETIMSK
                +.else 
                +in AL , ETIMSK
                 	mIn		AL,			ETIMSK
00024d 610c      	ori		AL,			(1<<OCIE3A)|(1<<OCIE3B)|(1<<TOIE3)
                +
                +.if ETIMSK > ( 0x3f )
00024e 9300 007d+sts ETIMSK , AL
                +.else 
                +out ETIMSK , AL
                 	mOut	ETIMSK,	AL
                 
000250 e080      	ldi		rvSpeedLR,	0x00	; "СТОП МАШИНА"
                 
000251 9508      	ret
                 	;< Interrupt
                 		.set	OldPC	=	pc
                 		.org	OVF3addr				;Overflow3 Interrupt Vector Address
00003a c221      			rjmp fIntTC3_OVF		;Timer3 Overflow Handler
                 		.org	OC3Aaddr				; Timer/Counter1 Compare Match B
000034 c21d      			rjmp fIntTC3_COMPA	;
                 		.org	OC3Baddr				; Timer/Counter1 Compare Match B
000036 c220      			rjmp fIntTC3_COMPB	;
                 ;		.org	OC1Caddr				; Timer/Counter1 Compare Match C
                 ;			rjmp fIntTC1_COMPC	;
                 		.org	OldPC
                 	;> Interrupt
                 
                +
                +.equ SizeOf_fDrvInit = ( pc - fDrvInit )
                 ENDP fDrvInit
                 
                 
                 
                +
                +.equ fIntTC3_COMPA = ( pc )
                 PROC fIntTC3_COMPA;Timer3 CompareA Handler
000252 b66f      	in		TmpSREG,	SREG
                 	;< Stop Left Crawler motor
                +
                +.if P_DrvLF > ( 0x3f )
                +push r16
000253 98df     +push r17
                +in r17 , SREG
                 	mPinCLR	DrvLF	;	Left Crawler motor
                +
                +.if P_DrvLR > ( 0x3f )
                +push r16
000254 98de     +push r17
                +in r17 , SREG
                 	mPinCLR	DrvLR	;	Left Crawler motor
                 	;> Stop Left Crawler motor
000255 be6f      	out		SREG,		TmpSREG
000256 9518      	reti
                +
                +.equ SizeOf_fIntTC3_COMPA = ( pc - fIntTC3_COMPA )
                 ENDP fIntTC3_COMPA
                 
                +
                +.equ fIntTC3_COMPB = ( pc )
                 PROC fIntTC3_COMPB;Timer3 CompareB Handler
000257 b66f      	in		TmpSREG,	SREG
                 	;< Stop Right Crawler motor
                +
                +.if P_DrvRR > ( 0x3f )
                +push r16
000258 98d8     +push r17
                +in r17 , SREG
                   	mPinCLR	DrvRR	;	Right Crawler motor
                +
                +.if P_DrvRF > ( 0x3f )
                +push r16
000259 98d9     +push r17
                +in r17 , SREG
                   	mPinCLR	DrvRF	;	Right Crawler motor
                 	;> Stop Right Crawler motor
00025a be6f      	out		SREG,		TmpSREG
00025b 9518      	reti
                +
                +.equ SizeOf_fIntTC3_COMPB = ( pc - fIntTC3_COMPB )
                 ENDP fIntTC3_COMPB
                 
                +
                +.equ fIntTC3_OVF = ( pc )
                 PROC fIntTC3_OVF	;Timer1 Overflow Handler
00025c b66f      	in		TmpSREG ,SREG
00025d 930f      	push	AL
                 	;Place your code here
00025e d004      	rcall	fDrvOnLeft
00025f d015      	rcall	fDrvOnRight
000260 910f      	pop		AL
000261 be6f      	out		SREG    ,TmpSREG
000262 9518      	reti
                +
                +.equ SizeOf_fIntTC3_OVF = ( pc - fIntTC3_OVF )
                 ENDP fIntTC3_OVF
                 
                 ;###############################################################################
                 
                +
                +.equ fDrvOnLeft = ( pc )
                 PROC fDrvOnLeft
                 ;	mIfFlgSET	flg_BlockL,	rjmp L_DrvL_Stop
                 	;< Проверка на нулевую скорость левой гусеницы
000263 2f08      	mov		AL,	rvSpeedLR
000264 7700      	andi	AL,	0b01110000
                 	;> Проверка на нулевую скорость левой гусеницы
000265 f071      	breq L_DrvL_Stop				; Скорость равна 0 двигатель не включаем.
                 	
                 		;< Setting speed for Left Crawler
000266 fd87      		sbrc	rvSpeedLR	,bit7
000267 9501      			neg	AL
000268 0f00      		lsl		AL
                +
                +.if OCR3AH > ( 0x3f )
000269 9300 0087+sts OCR3AH , AL
                +.else 
                +out OCR3AH , AL
                 		mOut	OCR3AH		,AL
                +
                +.if OCR3AL > ( 0x3f )
00026b 9230 0086+sts OCR3AL , ZERO
                +.else 
                +out OCR3AL , ZERO
                 		mOut	OCR3AL		,ZERO
                 		;> Setting speed for Left Crawler
                 
                 		;< Enable Left Crawler motor
                 			;< Stop Left Crawler motor
                +
                +.if P_DrvLR > ( 0x3f )
                +push r16
00026d 98de     +push r17
                +in r17 , SREG
                 			mPinCLR	DrvLR		;	Left Crawler motor
                +
                +.if P_DrvLF > ( 0x3f )
                +push r16
00026e 98df     +push r17
                +in r17 , SREG
                 			mPinCLR	DrvLF		;	Left Crawler motor
                 			;> Stop Left Crawler motor
00026f fd87      		sbrc rvSpeedLR,	bit7
000270 c002      		rjmp L_DrvOnLeftRear
                +
                +.if P_DrvLF > ( 0x3f )
                +push r16
000271 9adf     +push r17
                +in r17 , SREG
                 			mPinSET	DrvLF	;	Forward
000272 9508      			ret
                 		L_DrvOnLeftRear:
                +
                +.if P_DrvLR > ( 0x3f )
                +push r16
000273 9ade     +push r17
                +in r17 , SREG
                 		mPinSET	DrvLR		;	Rear
                 		;> Enable Left Crawler motor
                 	L_DrvL_Stop:
000274 9508      	ret
                +
                +.equ SizeOf_fDrvOnLeft = ( pc - fDrvOnLeft )
                 ENDP fDrvOnLeft
                 
                 
                +
                +.equ fDrvOnRight = ( pc )
                 PROC fDrvOnRight
                 ;	mIfFlgSET	flg_BlockR,	rjmp L_DrvR_Stop
                 	;< Проверка на нулевую скорость правой гусеницы
000275 2f08      	mov		AL,	rvSpeedLR
000276 7007      	andi	AL,	0b00000111
                 	;> Проверка на нулевую скорость правой гусеницы
000277 f079      	breq L_DrvR_Stop				; Скорость равна 0 двигатель не включаем.
                 
                 		;< Setting speed for Right Crawler
000278 9502      		swap	AL
000279 fd83      		sbrc	rvSpeedLR	,bit3
00027a 9501      			neg	AL
00027b 0f00      		lsl		AL
                +
                +.if OCR3BH > ( 0x3f )
00027c 9300 0085+sts OCR3BH , AL
                +.else 
                +out OCR3BH , AL
                 		mOut	OCR3BH		,AL
                +
                +.if OCR3BL > ( 0x3f )
00027e 9230 0084+sts OCR3BL , ZERO
                +.else 
                +out OCR3BL , ZERO
                 		mOut	OCR3BL		,ZERO
                 		;> Setting speed for Right Crawler
                 
                 		;< Enable Right Crawler motor
                 			;< Stop Right Crawler motor
                +
                +.if P_DrvRR > ( 0x3f )
                +push r16
000280 98d8     +push r17
                +in r17 , SREG
                 			mPinCLR	DrvRR	;	Right Crawler motor
                +
                +.if P_DrvRF > ( 0x3f )
                +push r16
000281 98d9     +push r17
                +in r17 , SREG
                 			mPinCLR	DrvRF	;	Right Crawler motor
                 			;> Stop Right Crawler motor
000282 fd83      		sbrc rvSpeedLR,	bit3
000283 c002      		rjmp L_DrvOnRightRear
                +
                +.if P_DrvRF > ( 0x3f )
                +push r16
000284 9ad9     +push r17
                +in r17 , SREG
                 			mPinSET	DrvRF	;	Forward
000285 9508      			ret
                 		L_DrvOnRightRear:
                +
                +.if P_DrvRR > ( 0x3f )
                +push r16
000286 9ad8     +push r17
                +in r17 , SREG
                 		mPinSET	DrvRR	;	Rear
                 		;> Enable Right Crawler motor
                 	L_DrvR_Stop:
000287 9508      	ret
                +
                +.equ SizeOf_fDrvOnRight = ( pc - fDrvOnRight )
                 ENDP fDrvOnRight
                 
                 
                +
                +.equ fMoveEX_Run = ( pc )
                 PROC fMoveEX_Run
                +
                +
                +.if flg_StepL < 8
000288 6160     +ori r_Flags , 1 << flg_StepL
                +.else 
                +ori r_FlagsH , 1 << ( flg_StepL & 0b111 )
                   mFlgSet flg_StepL
                +
                +
                +.if flg_StepR < 8
000289 6260     +ori r_Flags , 1 << flg_StepR
                +.else 
                +ori r_FlagsH , 1 << ( flg_StepR & 0b111 )
                   mFlgSet flg_StepR
00028a 93c0 0112   sts   (v_fptrMoveEX+0),YL
00028c 93d0 0113   sts   (v_fptrMoveEX+1),YH
                 ;  rcall fMoveEX
                 ;  ret
                 
                +
                +.equ SizeOf_fMoveEX_Run = ( pc - fMoveEX_Run )
                 ENDP fMoveEX_Run
                 
                 
                +
                +.equ fMoveEX = ( pc )
                 PROC fMoveEX
                 
00028e 91e0 0112 	lds		ZL,(v_fptrMoveEX+0)
000290 91f0 0113 	lds		ZH,(v_fptrMoveEX+1)
                 
                +
                +
                +
                +.if flg_StepL < 8
000292 ff64     +sbrs r_Flags , flg_StepL
000293 c021     +rjmp LMoveListEX_ret
                +.else 
                +sbrs r_FlagsH , ( flg_StepL & 0b111 )
                 	mIfFlgCLR	flg_StepL,rjmp LMoveListEX_ret
                +
                +
                +
                +.if flg_StepR < 8
000294 ff65     +sbrs r_Flags , flg_StepR
000295 c01f     +rjmp LMoveListEX_ret
                +.else 
                +sbrs r_FlagsH , ( flg_StepR & 0b111 )
                 	mIfFlgCLR	flg_StepR,rjmp LMoveListEX_ret
                 
                 	;< Read speed LR
000296 9185      	lpm		rvSpeedLR,	z+
                 	;> Read speed LR
                 
                 	;< if SpeedL == 0 then no clear flag flg_StepL
000297 ef00      	ldi		AL  ,0xF0
000298 2308      	and		AL  ,rvSpeedLR
000299 f009      	breq (pc+1)+1
                +
                +
                +.if flg_StepL < 8
00029a 7e6f     +cbr r_Flags , ( 1 << flg_StepL )
                +.else 
                +cbr r_FlagsH , 1 << ( flg_StepL & 0b111 )
                 		mFlgClr	flg_StepL
                 	;> if SpeedL == 0 then no clear flag flg_StepL
                 	
                 	;< if SpeedR == 0 then no clear flag flg_StepR
00029b e00f      	ldi		AL  ,0x0F
00029c 2308      	and		AL  ,rvSpeedLR
00029d f009      	breq (pc+1)+1
                +
                +
                +.if flg_StepR < 8
00029e 7d6f     +cbr r_Flags , ( 1 << flg_StepR )
                +.else 
                +cbr r_FlagsH , 1 << ( flg_StepR & 0b111 )
                 		mFlgClr	flg_StepR
                 	;> if SpeedR == 0 then no clear flag flg_StepR
                 
                 
                 
00029f 9105      	lpm		AL  ,z+
0002a0 9110 010e 	lds		AH  ,(v_CrawlerCurPosL)
0002a2 0f10      	add		AH  ,AL
0002a3 9310 010f 	sts		(v_CrawlerPosL),	AH
                 
0002a5 9105      	lpm		AL  ,z+
0002a6 9110 0110 	lds		AH  ,(v_CrawlerCurPosR)
0002a8 0f10      	add		AH  ,AL
0002a9 9310 0111 	sts		(v_CrawlerPosR),	AH
                 
0002ab 91b5      	lpm		XH  ,z+
0002ac 27aa      	clr		XL  
0002ad e100      	ldi		AL  ,GetTaskID(fDrvStop)
0002ae d67d      	rcall	krSetTimer
                 
0002af 23bb      	tst		XH
0002b0 f421      	brne (pc+1)+2+1+1
                   ;< ### записать событие по окончанию плейлиста
0002b1 9100 012c   	lds	AL			        ,(v_Event_EndMov)
0002b3 d65c        	rcall krSendTask
                   ;> 
0002b4 9508      	ret
                 
                  LMoveListEX_ret:
0002b5 93e0 0112 	sts		(v_fptrMoveEX+0),ZL
0002b7 93f0 0113 	sts		(v_fptrMoveEX+1),ZH
                 	
                +
                +.if 155 * 100 / 1000 > ( 1 << 16 ) || ( 155 * 100 / 1000 == 0 )
                +.error "Time out range!!!"
0002b9 e102     +.else 
0002ba e0af     +ldi AL , TP_fMoveEX - TaskProcs
0002bb e0b0     +ldi XL , low ( 155 * 100 / 1000 )
0002bc d66f     +ldi XH , high ( 155 * 100 / 1000 )
                +rcall krSetTimer
                 	mSetTimerTask fMoveEX,155ms
                 
0002bd 9508      	ret
                 
                +
                +.equ SizeOf_fMoveEX = ( pc - fMoveEX )
                 ENDP fMoveEX
                 
                +
                +.equ fDrvStopL = ( pc )
                 PROC fDrvStopL
0002be 708f      	andi	rvSpeedLR,0x0F
0002bf 9508      	ret
                +
                +.equ SizeOf_fDrvStopL = ( pc - fDrvStopL )
                 ENDP fDrvStopL
                 
                +
                +.equ fDrvStopR = ( pc )
                 PROC fDrvStopR
0002c0 7f80      	andi	rvSpeedLR,0xF0
0002c1 9508      	ret
                +
                +.equ SizeOf_fDrvStopR = ( pc - fDrvStopR )
                 ENDP fDrvStopR
                 
                +
                +.equ fDrvStop = ( pc )
                 PROC fDrvStop
0002c2 e080      	ldi	rvSpeedLR,0x00
                +
0002c3 e102     +ldi AL , TP_fMoveEX - TaskProcs
0002c4 d693     +rcall krClrTimer
                +
                 	mClrTimer fMoveEX
                +
0002c5 e100     +ldi AL , TP_fDrvStop - TaskProcs
0002c6 d691     +rcall krClrTimer
                +
                 	mClrTimer fDrvStop
0002c7 9508      	ret
                +
                +.equ SizeOf_fDrvStop = ( pc - fDrvStop )
                 ENDP fDrvStop
                 
                 
                 
                 
                 .include  "LCD_uni.inc" ;
                 
                 ;HD44780-based Character-LCD
                 ;Updated: "2010-09-02" "20:13"
                 ;Updated: "2011-03-14" "20:01"
                 
                 .list
                 .listmac
                 
                 
LCD_uni.inc(86): +----------------------+
LCD_uni.inc(87): | LCD: 4-bit interface |
LCD_uni.inc(88): +----------------------+
MacroEX.asm(45): warning: 
LCD_uni.inc(163): macro 'alignD' called here
TankDemo.asm(73): 'LCD_uni.inc' included form here
MacroEX.asm(46): +---------------------------------------+
MacroEX.asm(47): | Not used DATA. See NoUse in map file. |
MacroEX.asm(48): +---------------------------------------+
                 #endif
                 .list
                 .listmac
                 
                 ;< in process
                 ;PROC fLCD_Shuffle
                 ;;  .equ  LCD_D0 = 0
                 ;;  .equ  LCD_D1 = 1
                 ;;  .equ  LCD_D2 = 2
                 ;;  .equ  LCD_D3 = 3
                 ;;  .equ  LCD_D4 = 4
                 ;;  .equ  LCD_D5 = 5
                 ;;  .equ  LCD_D6 = 6
                 ;;  .equ  LCD_D7 = 7
                 ;#define rCnt r17
                 ;#define rTmp r18
                 ;#define rTemp r19
                 ;
                 ; push  rCnt
                 ; push  rTmp
                 ; push  rTemp
                 ;
                 ; clr   rTemp
                 ;   LDW   Z,  (Shuffle<<1)
                 ; ldi   rCnt, 8
                 ; L_fLCD_Shuffle:
                 ;   clr   rTmp
                 ;     lpm   rTmp, z+
                 ;     sbrc  AL,   bit0
                 ;     add   rTemp, rTmp
                 ;     ror   AL
                 ;   dec   rCnt
                 ; brne L_fLCD_Shuffle
                 ; mov   AL, rTemp
                 ;
                 ; pop   rTemp
                 ; pop   rTmp
                 ; pop   rCnt
                 ;
                 ; ret
                 ;#undef rCnt
                 ;#undef rTmp
                 ;#undef rTemp
                 ;Shuffle:
                 ; .db (1<<LCD_D0),(1<<LCD_D1),(1<<LCD_D2),(1<<LCD_D3),(1<<LCD_D4),(1<<LCD_D5),(1<<LCD_D6),(1<<LCD_D7)
                 ;ENDP fLCD_Shuffle
                 ;> in process
                +
                +.equ fLCD_WR8 = ( pc )
                 PROC fLCD_WR8
0002c8 bb05        out   P_LCD,  AL
0002c9 d012        rcall fLCD_Strob
0002ca 9508        ret
                +
                +.equ SizeOf_fLCD_WR8 = ( pc - fLCD_WR8 )
                 ENDP fLCD_WR8
                 
                 
                +
                +.equ fLCD_WR4 = ( pc )
                 PROC fLCD_WR4
0002cb 931f        push  AH
                     .if (LCDMODE == LCDLOW)
0002cc 930f            push  AL
0002cd b315            in    AH, P_LCD
0002ce 7f10            cbr   AH, LCDMODE
                       ;< 4-7 bits
0002cf 9502            swap  AL
0002d0 700f            andi  AL, LCDMODE
0002d1 2b01            or    AL, AH
0002d2 bb05            out   P_LCD,  AL
0002d3 d008            rcall fLCD_Strob
                       ;> 4-7 bits
0002d4 910f            pop   AL
                       ;< 0-3 bits
0002d5 700f            andi  AL, LCDMODE
0002d6 2b01            or    AL, AH
0002d7 bb05            out   P_LCD,  AL
0002d8 d003            rcall fLCD_Strob
                       ;> 0-3 bits
0002d9 d070            rcall fLCDWait
                     .elif (LCDMODE == LCDHI)
                     .else
                     .endif
                 
0002da 911f        pop   AH
0002db 9508        ret
                +
                +.equ SizeOf_fLCD_WR4 = ( pc - fLCD_WR4 )
                 ENDP fLCD_WR4
                 ;################################## FUNCTION ###################################
                 ;Name of function:
                  ; fLCD_WR3
                 ;Input:
                  ; AL - byte
                 ;Return:
                  ; -
                 ;Description:
                  ; Write byte to LCD
                 ;
                 ;< ################################# R-chart ###################################
                 ;
                 ; +---------->+---------->+---------------------->+(ret)->
                 ;                         !                       !
                 ;                         !---------------------->!
                 ;
                 ;> ################################# R-chart ###################################
                 .if LCDTYPE == 3
                 .endif
                 
                +
                +.equ fLCD_Strob = ( pc )
                 PROC fLCD_Strob
                +
                +.if P_LCDE > ( 0x3f )
                +push r16
0002dc 98ac     +push r17
                +in r17 , SREG
                   mPinCLR LCDE
0002dd 0000        nop
                +
                +.if P_LCDE > ( 0x3f )
                +push r16
0002de 9aac     +push r17
                +in r17 , SREG
                   mPinSET LCDE
0002df 0000        nop
                +
                +.if P_LCDE > ( 0x3f )
                +push r16
0002e0 98ac     +push r17
                +in r17 , SREG
                   mPinCLR LCDE
0002e1 9508        ret
                +
                +.equ SizeOf_fLCD_Strob = ( pc - fLCD_Strob )
                 ENDP fLCD_Strob
                 
                +
                +.equ fLCDInit = ( pc )
                 PROC fLCDInit
                   ;< Init LCD PORTs
                +
                +.if P_LCDE > ( 0x3f )
                +push r16
0002e2 98ac     +push r17
                +in r17 , SREG
                   mPinCLR LCDE
                +
                +.if P_LCDRS > ( 0x3f )
                +push r16
0002e3 98ae     +push r17
                +in r17 , SREG
                   mPinCLR LCDRS
                +
                +.if ( P_LCDE - 1 ) > ( 0x3f )
                +push r16
0002e4 9aa4     +lds r16 , P_LCDE - 1
                +sbr r16 , ( 1 << LCDE )
                   mPinOut LCDE
                +
                +.if ( P_LCDRS - 1 ) > ( 0x3f )
                +push r16
0002e5 9aa6     +lds r16 , P_LCDRS - 1
                +sbr r16 , ( 1 << LCDRS )
                   mPinOut LCDRS
                   .ifdef LCDRW
                +
                +.if P_LCDRW > ( 0x3f )
                +push r16
0002e6 98ad     +push r17
                +in r17 , SREG
                     mPinCLR LCDRW
                +
                +.if ( P_LCDRW - 1 ) > ( 0x3f )
                +push r16
0002e7 9aa5     +lds r16 , P_LCDRW - 1
                +sbr r16 , ( 1 << LCDRW )
                     mPinOut LCDRW
                   .endif
                   ;> Init LCD PORTs
                 
                   .if LCDTYPE == 3
                   .elif LCDTYPE == 4
                     ;< Set 4 bit interface
                     .if (LCDMODE == LCDLOW) ||(LCDMODE == LCDHI)
0002e8 b304            in    AL,     P_LCD-1
0002e9 600f            ori   AL,     LCDMODE
0002ea bb04            out   P_LCD-1,AL
                     .else
                     .endif
                 
                 
0002eb e300          ldi AL, FunctionSet|Interface8bit
                     .if (LCDMODE == LCDLOW)
0002ec 9502            swap  AL
                     .elif (LCDMODE == LCDHI)
                     .else
                     .endif
0002ed b315          in    AH, P_LCD
0002ee 7f10          cbr   AH, LCDMODE
0002ef 700f          andi  AL, LCDMODE
0002f0 2b01          or    AL, AH
0002f1 bb05          out   P_LCD,  AL
                 
0002f2 dfe9          rcall fLCD_Strob
                +
                +.if ( ( 5000 * Fclk / 10000 ) - ( 5000 * Fclk / 1000000 ) * 100 ) >= 50
                +.set Cycles = ( 5000 * Fclk / 1000000 ) + 1
                +.else 
                +.set Cycles = ( 5000 * Fclk / 1000000 )
                +
                +.if Cycles == 0
                +.message "No left cycles"
                +.elif Cycles == 1
                +nop
                +.elif Cycles == 2
                +rjmp ( pc + 1 )
                +
                +.elif Cycles == 3
                +rjmp pc + 1
                +nop
                +
                +.elif Cycles == 4
0002f3 e1ef     +rjmp pc + 1
0002f4 e4fe     +rjmp pc + 1
0002f5 9731     +
0002f6 f7f1     +.elif Cycles == 5
                +rjmp pc + 1
                +
                +.if Cyc_Left == 0
                +.message "No left cycles"
                +.elif Cyc_Left == 1
                +nop
0002f7 c000     +.elif Cyc_Left == 2
0002f8 0000     +rjmp ( pc + 1 )
                +
                +.elif Cyc_Left == 3
                +rjmp pc + 1
                +nop
                +
                +.elif Cyc_Left == 4
                +rjmp pc + 1
                +rjmp pc + 1
                +
                +.elif Cyc_Left == 5
                +rjmp pc + 1
                +rjmp pc + 1
                +nop
                +
                +.elif Cycles == 6
                +rjmp pc + 1
                +rjmp pc + 1
                +.endif 
                     mDelay_Us 5000;4100
0002f9 dfe2          rcall fLCD_Strob
                +
                +.if ( ( 200 * Fclk / 10000 ) - ( 200 * Fclk / 1000000 ) * 100 ) >= 50
                +.set Cycles = ( 200 * Fclk / 1000000 ) + 1
                +.else 
                +.set Cycles = ( 200 * Fclk / 1000000 )
                +
                +.if Cycles == 0
                +.message "No left cycles"
                +.elif Cycles == 1
                +nop
                +.elif Cycles == 2
                +rjmp ( pc + 1 )
                +
                +.elif Cycles == 3
                +rjmp pc + 1
                +nop
                +
                +.elif Cycles == 4
0002fa e1ef     +rjmp pc + 1
0002fb e0f3     +rjmp pc + 1
0002fc 9731     +
0002fd f7f1     +.elif Cycles == 5
                +rjmp pc + 1
                +
                +.if Cyc_Left == 0
                +.message "No left cycles"
                +.elif Cyc_Left == 1
                +nop
0002fe c000     +.elif Cyc_Left == 2
0002ff 0000     +rjmp ( pc + 1 )
                +
                +.elif Cyc_Left == 3
                +rjmp pc + 1
                +nop
                +
                +.elif Cyc_Left == 4
                +rjmp pc + 1
                +rjmp pc + 1
                +
                +.elif Cyc_Left == 5
                +rjmp pc + 1
                +rjmp pc + 1
                +nop
                +
                +.elif Cycles == 6
                +rjmp pc + 1
                +rjmp pc + 1
                +.endif 
                     mDelay_Us 200;100
000300 dfdb          rcall fLCD_Strob
000301 d048          rcall fLCDWait
                 
000302 e200          ldi AL, FunctionSet|Interface4bit
                     .if (LCDMODE == LCDLOW)
000303 9502            swap  AL
                     .elif (LCDMODE == LCDHI)
                     .else
                     .endif
000304 b315          in    AH, P_LCD
000305 7f10          cbr   AH, LCDMODE
000306 700f          andi  AL, LCDMODE
000307 2b01          or    AL, AH
000308 bb05          out   P_LCD,  AL
                 
000309 dfd2          rcall fLCD_Strob
00030a d03f          rcall fLCDWait
00030b e20c          ldi   AL, FunctionSet|Interface4bit|DisplayLine2|Font5_10Dot
                +
                +.if LCDTYPE == 3
                +
                +rcall fLCD_WR3
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                +
                +.if P_LCDRS > ( 0x3f )
                +push r16
00030c 98ae     +push r17
                +in r17 , SREG
                +.error "Botva BATENKA!!!"
                +.endif 
                +rcall fLCD_Strob
                +rcall fLCDWait
00030d dfbd     +
                +.elif LCDTYPE == 4
                +
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                     mLCD_WR LCD_CMD
                     ;> Set 4 bit interface
                 
                   .elif LCDTYPE == 8
                   .endif
                 
                 
                 
00030e e00e        ldi   AL, DispControl|DisplayON|CursorON|CursorNoFlash
00030f 9300 01a0   sts   (v_LCDCtrl),  AL
                +
                +.if LCDTYPE == 3
                +
                +rcall fLCD_WR3
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                +
                +.if P_LCDRS > ( 0x3f )
                +push r16
000311 98ae     +push r17
                +in r17 , SREG
                +.error "Botva BATENKA!!!"
                +.endif 
                +rcall fLCD_Strob
                +rcall fLCDWait
000312 dfb8     +
                +.elif LCDTYPE == 4
                +
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                   mLCD_WR LCD_CMD
000313 e006        ldi   AL, EntryMode|IncCurPos|NoDispShift
                +
                +.if LCDTYPE == 3
                +
                +rcall fLCD_WR3
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                +
                +.if P_LCDRS > ( 0x3f )
                +push r16
000314 98ae     +push r17
                +in r17 , SREG
                +.error "Botva BATENKA!!!"
                +.endif 
                +rcall fLCD_Strob
                +rcall fLCDWait
000315 dfb5     +
                +.elif LCDTYPE == 4
                +
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                   mLCD_WR LCD_CMD
000316 e001        ldi   AL, ClearDisplay
                +
                +.if LCDTYPE == 3
                +
                +rcall fLCD_WR3
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                +
                +.if P_LCDRS > ( 0x3f )
                +push r16
000317 98ae     +push r17
                +in r17 , SREG
                +.error "Botva BATENKA!!!"
                +.endif 
                +rcall fLCD_Strob
                +rcall fLCDWait
000318 dfb2     +
                +.elif LCDTYPE == 4
                +
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                   mLCD_WR LCD_CMD
                +
                +.if ( ( 2000 * Fclk / 10000 ) - ( 2000 * Fclk / 1000000 ) * 100 ) >= 50
                +.set Cycles = ( 2000 * Fclk / 1000000 ) + 1
                +.else 
                +.set Cycles = ( 2000 * Fclk / 1000000 )
                +
                +.if Cycles == 0
                +.message "No left cycles"
                +.elif Cycles == 1
                +nop
                +.elif Cycles == 2
                +rjmp ( pc + 1 )
                +
                +.elif Cycles == 3
                +rjmp pc + 1
                +nop
                +
                +.elif Cycles == 4
000319 e3ef     +rjmp pc + 1
00031a e1ff     +rjmp pc + 1
00031b 9731     +
00031c f7f1     +.elif Cycles == 5
                +rjmp pc + 1
                +
                +.if Cyc_Left == 0
                +.message "No left cycles"
                +.elif Cyc_Left == 1
                +nop
00031d c000     +.elif Cyc_Left == 2
00031e 0000     +rjmp ( pc + 1 )
                +
                +.elif Cyc_Left == 3
                +rjmp pc + 1
                +nop
                +
                +.elif Cyc_Left == 4
                +rjmp pc + 1
                +rjmp pc + 1
                +
                +.elif Cyc_Left == 5
                +rjmp pc + 1
                +rjmp pc + 1
                +nop
                +
                +.elif Cycles == 6
                +rjmp pc + 1
                +rjmp pc + 1
                +.endif 
                   mDelay_Us 2000
                 
00031f e800        ldi   AL,   SetDDRAM|Line1|Pos0
000320 9300 01a1   sts   (v_LCDPos), AL
                 
000322 9508        ret
                +
                +.equ SizeOf_fLCDInit = ( pc - fLCDInit )
                 ENDP fLCDInit
                 
                 ;##########################################################
                +
                +.equ fLCD_Char = ( pc )
                 PROC  fLCD_Char
000323 fd07        sbrc  AL,7
000324 d004          rcall fLCDReCode
                +
                +.if LCDTYPE == 3
                +
                +rcall fLCD_WR3
                +.if LCD_DATA == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_DATA == LCD_DATA
                +mPinSET LCDRS
                +.else 
                +.error "Botva BATENKA!!!"
                +
                +.if P_LCDRS > ( 0x3f )
                +push r16
000325 9aae     +push r17
                +in r17 , SREG
                +.endif 
                +rcall fLCD_Strob
                +rcall fLCDWait
000326 dfa4     +
                +.elif LCDTYPE == 4
                +
                +.if LCD_DATA == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_DATA == LCD_DATA
                +mPinSET LCDRS
                +.else 
                   mLCD_WR LCD_DATA
000327 d022        rcall fLCDWait
000328 9508        ret
                +
                +.equ SizeOf_fLCD_Char = ( pc - fLCD_Char )
                 ENDP fLCD_Char
                 ;##########################################################
                +
                +.equ fLCDReCode = ( pc )
                 PROC fLCDReCode
                +
000329 93ff     +push ZH
00032a 93ef     +push ZL
                   mPUSHw Z
00032b 770f        andi  AL, $7F
                +
00032c e1fe     +ldi ZH , high ( ( ReCode_ANSI << 1 ) )
00032d e8e6     +ldi ZL , low ( ( ReCode_ANSI << 1 ) )
                   LDW   Z,    (ReCode_ANSI<<1)
00032e 0fe0        add   ZL,   AL
00032f 1df3        adc   ZH,   ZERO
000330 9104        lpm   AL, z
                +
000331 91ef     +pop ZL
000332 91ff     +pop ZH
                   mPOPw Z
000333 9508        ret
                +
                +.equ SizeOf_fLCDReCode = ( pc - fLCDReCode )
                 ENDP fLCDReCode
                 
                 
                 ;##########################################################
                +
                +.equ fLCDszY = ( pc )
                 PROC fLCDszY
000334 9109          ld    AL, y+
000335 dfed          rcall fLCD_Char   ;,Data
000336 8108          ld    AL, y
000337 2300          tst   AL
000338 f7d9        brne  fLCDszY
000339 9508        ret
                +
                +.equ SizeOf_fLCDszY = ( pc - fLCDszY )
                 ENDP fLCDszY
                 
                +
                +.equ fLCDszZ = ( pc )
                 PROC fLCDszZ
00033a 9105          lpm   AL, z+
00033b dfe7          rcall fLCD_Char   ;,Data
00033c 9104          lpm   AL, z
00033d 2300          tst   AL
00033e f7d9        brne  fLCDszZ
00033f 9508        ret
                +
                +.equ SizeOf_fLCDszZ = ( pc - fLCDszZ )
                 ENDP fLCDszZ
                 
                 ;##########################################################
                 ; AH - длина строки
                +
                +.equ fLCDsZ = ( pc )
                 PROC fLCDsZ
000340 9105          lpm   AL, z+
000341 dfe1          rcall fLCD_Char   ;,Data
000342 951a          dec   AH
000343 f7e1        brne  fLCDsZ
000344 9508        ret
                +
                +.equ SizeOf_fLCDsZ = ( pc - fLCDsZ )
                 ENDP fLCDsZ
                 
                 ; AH - длина строки
                +
                +.equ fLCDsY = ( pc )
                 PROC fLCDsY
000345 9109          ld    AL, y+
000346 dfdc          rcall fLCD_Char   ;,Data
000347 951a          dec   AH
000348 f7e1        brne  fLCDsY
000349 9508        ret
                +
                +.equ SizeOf_fLCDsY = ( pc - fLCDsY )
                 ENDP fLCDsY
                 
                 
                +
                +.equ fLCDWait = ( pc )
                 PROC fLCDWait
                +
                +.if ( ( DelayLCD1 * Fclk / 10000 ) - ( DelayLCD1 * Fclk / 1000000 ) * 100 ) >= 50
                +.set Cycles = ( DelayLCD1 * Fclk / 1000000 ) + 1
                +.else 
                +.set Cycles = ( DelayLCD1 * Fclk / 1000000 )
                +
                +.if Cycles == 0
                +.message "No left cycles"
                +.elif Cycles == 1
                +nop
                +.elif Cycles == 2
                +rjmp ( pc + 1 )
                +
                +.elif Cycles == 3
                +rjmp pc + 1
                +nop
                +
00034a 930f     +.elif Cycles == 4
00034b ee0e     +rjmp pc + 1
00034c 950a     +rjmp pc + 1
00034d f7f1     +
00034e 910f     +.elif Cycles == 5
                +rjmp pc + 1
                +
                +.if Cyc_Left == 0
                +.message "No left cycles"
                +.elif Cyc_Left == 1
00034f c000     +nop
                +.elif Cyc_Left == 2
                +rjmp ( pc + 1 )
                +
                +.elif Cyc_Left == 3
                +rjmp pc + 1
                +nop
                +
                +.elif Cyc_Left == 4
                +rjmp pc + 1
                +rjmp pc + 1
                +
                +.elif Cyc_Left == 5
                +rjmp pc + 1
                +nop
                +
                +.elif Cycles == 6
                +rjmp pc + 1
                +rjmp pc + 1
                +rjmp pc + 1
                +.endif 
                   mDelay_Us DelayLCD1
000350 9508        ret
                +
                +.equ SizeOf_fLCDWait = ( pc - fLCDWait )
                 ENDP fLCDWait
                 
                +
                +.equ fLCDPageZ = ( pc )
                 PROC fLCDPageZ
000351 e018        ldi   AH, LCDCHARS
                +
000352 e800     +ldi AL , SetDDRAM | Line1 | Pos0
                +
                +.if LCDTYPE == 3
                +
                +rcall fLCD_WR3
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                +
                +.if P_LCDRS > ( 0x3f )
                +push r16
000353 98ae     +push r17
                +in r17 , SREG
                +.error "Botva BATENKA!!!"
                +.endif 
                +rcall fLCD_Strob
                +rcall fLCDWait
000354 df76     +
                +.elif LCDTYPE == 4
                +
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                +mLCD_WR LCD_CMD
                +
                   mLCDSetPos  Line1,Pos0
000355 dfea        rcall fLCDsZ
                +
000356 ec00     +ldi AL , SetDDRAM | Line2 | Pos0
                +
                +.if LCDTYPE == 3
                +
                +rcall fLCD_WR3
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                +
                +.if P_LCDRS > ( 0x3f )
                +push r16
000357 98ae     +push r17
                +in r17 , SREG
                +.error "Botva BATENKA!!!"
                +.endif 
                +rcall fLCD_Strob
                +rcall fLCDWait
000358 df72     +
                +.elif LCDTYPE == 4
                +
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                +mLCD_WR LCD_CMD
                +
                   mLCDSetPos  Line2,Pos0
000359 e018        ldi   AH, LCDCHARS
00035a dfe5        rcall fLCDsZ
00035b 9508        ret
                +
                +.equ SizeOf_fLCDPageZ = ( pc - fLCDPageZ )
                 ENDP fLCDPageZ
                 
                +
                +.equ fLCDPageY = ( pc )
                 PROC fLCDPageY
00035c e018        ldi   AH, LCDCHARS
                +
00035d e800     +ldi AL , SetDDRAM | Line1 | Pos0
                +
                +.if LCDTYPE == 3
                +
                +rcall fLCD_WR3
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                +
                +.if P_LCDRS > ( 0x3f )
                +push r16
00035e 98ae     +push r17
                +in r17 , SREG
                +.error "Botva BATENKA!!!"
                +.endif 
                +rcall fLCD_Strob
                +rcall fLCDWait
00035f df6b     +
                +.elif LCDTYPE == 4
                +
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                +mLCD_WR LCD_CMD
                +
                   mLCDSetPos  Line1,Pos0
000360 dfe4        rcall fLCDsY
                +
000361 ec00     +ldi AL , SetDDRAM | Line2 | Pos0
                +
                +.if LCDTYPE == 3
                +
                +rcall fLCD_WR3
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                +
                +.if P_LCDRS > ( 0x3f )
                +push r16
000362 98ae     +push r17
                +in r17 , SREG
                +.error "Botva BATENKA!!!"
                +.endif 
                +rcall fLCD_Strob
                +rcall fLCDWait
000363 df67     +
                +.elif LCDTYPE == 4
                +
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                +mLCD_WR LCD_CMD
                +
                   mLCDSetPos  Line2,Pos0
000364 e018        ldi   AH, LCDCHARS
000365 dfdf        rcall fLCDsY
000366 9508        ret
                +
                +.equ SizeOf_fLCDPageY = ( pc - fLCDPageY )
                 ENDP fLCDPageY
                 
                 
                 
                +
                +.equ fLCDPrint = ( pc )
                 PROC fLCDPrint
                +
000367 e0d1     +ldi YH , high ( ( v_LCDBuf ) )
000368 e9c0     +ldi YL , low ( ( v_LCDBuf ) )
                   LDW   Y,(v_LCDBuf)
000369 dff2        rcall fLCDPageY
00036a 9100 01a0   lds   AL, (v_LCDCtrl);, DispControl|DisplayON|CursorOFF|CursorFlash
                +
                +.if LCDTYPE == 3
                +
                +rcall fLCD_WR3
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                +
                +.if P_LCDRS > ( 0x3f )
                +push r16
00036c 98ae     +push r17
                +in r17 , SREG
                +.error "Botva BATENKA!!!"
                +.endif 
                +rcall fLCD_Strob
                +rcall fLCDWait
00036d df5d     +
                +.elif LCDTYPE == 4
                +
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                   mLCD_WR LCD_CMD
00036e 9100 01a1   lds   AL, (v_LCDPos);,  SetDDRAM|Line2|Pos3
                +
                +.if LCDTYPE == 3
                +
                +rcall fLCD_WR3
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                +
                +.if P_LCDRS > ( 0x3f )
                +push r16
000370 98ae     +push r17
                +in r17 , SREG
                +.error "Botva BATENKA!!!"
                +.endif 
                +rcall fLCD_Strob
                +rcall fLCDWait
000371 df59     +
                +.elif LCDTYPE == 4
                +
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                   mLCD_WR LCD_CMD
000372 9508        ret
                +
                +.equ SizeOf_fLCDPrint = ( pc - fLCDPrint )
                 ENDP fLCDPrint
                 
                +
                +.equ fLCDBuffCLR = ( pc )
                 PROC fLCDBuffCLR
000373 e110        ldi   AH, LCDBUFFSIZE
000374 e200        ldi   AL, ' '
                 ;  LDW   Y,(v_LCDBuf)
000375 9309         st   y+,   AL
000376 951a         dec    AH
000377 f7e9        brne  (pc-1-1)
000378 9508        ret
                +
                +.equ SizeOf_fLCDBuffCLR = ( pc - fLCDBuffCLR )
                 ENDP fLCDBuffCLR
                 
                 ;Вывод ASCIIZ строки из Flash в RAM
                 ;Z - адресс начала ASCIIZ строки во Flash памяти
                 ;Y - адресс начальной ячейки в RAM памяти
                +
                +.equ fLCDsz2BuffZ = ( pc )
                 PROC fLCDsz2BuffZ
000379 9105        lpm   AL, z+
00037a 9309        st    y+,   AL
00037b 9104        lpm   AL, z
00037c 2300        tst   AL
00037d f7d9        brne  fLCDsz2BuffZ
00037e 9508        ret
                +
                +.equ SizeOf_fLCDsz2BuffZ = ( pc - fLCDsz2BuffZ )
                 ENDP fLCDsz2BuffZ
                 ;##########################################################
                 
                 
                +
                +.equ fLCDLightOn = ( pc )
                 PROC fLCDLightOn
                   ;< Включим подсветку LCD
                +
                +.if ( P_LCDLight - 1 ) > ( 0x3f )
00037f 930f     +push r16
000380 9100 0064+lds r16 , P_LCDLight - 1
000382 6004     +sbr r16 , ( 1 << LCDLight )
000383 9300 0064+sts P_LCDLight - 1 , r16
000385 910f     +pop r16
                +.else 
                +sbi P_LCDLight - 1 , LCDLight
                     mPinOut LCDLight
                +
                +.if P_LCDLight > ( 0x3f )
000386 930f     +push r16
000387 931f     +push r17
000388 b71f     +in r17 , SREG
000389 9100 0065+lds r16 , P_LCDLight
00038b 6004     +sbr r16 , ( 1 << LCDLight )
00038c 9300 0065+sts P_LCDLight , r16
00038e bf1f     +out SREG , r17
00038f 911f     +pop r17
000390 910f     +pop r16
                +.else 
                +sbi P_LCDLight , LCDLight
                     mPinSET LCDLight
                   ;> Включим подсветку LCD
000391 9508        ret
                +
                +.equ SizeOf_fLCDLightOn = ( pc - fLCDLightOn )
                 ENDP fLCDLightOn
                 
                +
                +.equ fLCDLightOff = ( pc )
                 PROC fLCDLightOff
                   ;< Включим подсветку LCD
                +
                +.if ( P_LCDLight - 1 ) > ( 0x3f )
000392 930f     +push r16
000393 9100 0064+lds r16 , P_LCDLight - 1
000395 6004     +sbr r16 , ( 1 << LCDLight )
000396 9300 0064+sts P_LCDLight - 1 , r16
000398 910f     +pop r16
                +.else 
                +sbi P_LCDLight - 1 , LCDLight
                     mPinOut LCDLight
                +
                +.if P_LCDLight > ( 0x3f )
000399 930f     +push r16
00039a 931f     +push r17
00039b b71f     +in r17 , SREG
00039c 9100 0065+lds r16 , P_LCDLight
00039e 7f0b     +cbr r16 , ( 1 << LCDLight )
00039f 9300 0065+sts P_LCDLight , r16
0003a1 bf1f     +out SREG , r17
0003a2 911f     +pop r17
0003a3 910f     +pop r16
                +.else 
                +cbi P_LCDLight , LCDLight
                     mPinCLR LCDLight
                   ;> Включим подсветку LCD
0003a4 9508        ret
                +
                +.equ SizeOf_fLCDLightOff = ( pc - fLCDLightOff )
                 ENDP fLCDLightOff
                 
                 
                 ;###############################################################################
                 
                 
                 
                 ;S_Alex
                 
                 ;>
                 #else
                 #endif
                 .list
                 .listmac
                 .include  "Soft_RTC.inc" ;
                 
                 ;Updated: "2010-11-01" "00:31"
                 
                 .ifndef  SOFT_RTC_INC
                 	.equ	SOFT_RTC_INC	= 1
                 ;###############################################################################
                 ;###############################################################################
                 .macro	mRTC_Init
                 	rcall fRTC_Init
                 .endmacro
                 ;###############################################################################
                 ;###############################################################################
                 
                 ;###############################################################################
                 	.include  "Soft_RTC.asm"
                 
                 ;Updated: "2010-11-01" "00:31"
                 
MacroEX.asm(45): warning: 
TankDemo.asm(78): macro 'alignD' called here
MacroEX.asm(46): +---------------------------------------+
MacroEX.asm(47): | Not used DATA. See NoUse in map file. |
MacroEX.asm(48): +---------------------------------------+
                 .list
                 .listmac
                 ;###############################################################################
                 ;############################## Code ###########################################
                 ;###############################################################################
                 ;< Список адресов задач
                 TaskProcs:  ; !!! Имя метки должно быть неизменным !!! Используется в макросе
000400 04ba        Task(Idle)  ;Always 1st   ;0
000401 04bb        Task(f1sec)               ;1
000402 08b5        Task(fReklama)            ;2
000403 0263        Task(fDrvOnLeft)          ;3
000404 0275        Task(fDrvOnRight)         ;4
000405 01f4        Task(fENGet)              ;5
000406 07ce        Task(fGNDMinMax)          ;6
000407 07aa        Task(fGNDGetMidLevel)     ;7
000408 0a05        Task(fMelodyPlay)         ;8
000409 05e9        Task(fInit_FM_LS)         ;9
00040a 0bf7        Task(fShowSensorsState)   ;10
00040b 0747        Task(fSetLineFlg)         ;11
00040c 0783        Task(fRefreshLCD)         ;12
00040d 0aaf        Task(fIRTimeOut)          ;13
00040e 0afc        Task(fIR_Command)         ;14
00040f 0670        Task(fAdjustAtMonet)      ;15
000410 02c2        Task(fDrvStop)            ;16
000411 0597        Task(fEvent)              ;17
000412 028e        Task(fMoveEX)             ;18
000413 0730        Task(fFinish)             ;19
000414 02be        Task(fDrvStopL)           ;20
000415 02c0        Task(fDrvStopR)           ;21
000416 06f0        Task(fRL_90)              ;22
000417 06ed        Task(fRR_90)              ;23
000418 06f3        Task(fRR_360_2)           ;24
000419 06fe        Task(fSearch_Finish)      ;25
00041a 0711        Task(fGo_Finish)          ;26
00041b 06c1        Task(fScanMonet)          ;27
00041c 06a9        Task(fSearchMove)         ;28
00041d 06df        Task(fRotate)             ;29
00041e 053a        Task(fGoGoGo)             ;30
00041f 054f        Task(fSearchLampLR)       ;31
000420 0666        Task(fCoverMonet)         ;32
000421 09f5        Task(fMelodyMoneta)       ;33
000422 088a        Task(fInfoSets)           ;34
000423 0722        Task(fDrvStopAtFinish_L)  ;35
000424 0729        Task(fDrvStopAtFinish_R)  ;36
000425 0523        Task(fBeginShow)          ;37
000426 04ec        Task(fInitAllSensor)      ;38
000427 04d4        Task(fMenuInfo)           ;39
000428 0690        Task(fOutLine)            ;40
000429 0574        Task(fkrSetEvent)         ;41
00042a 04c1        Task(fFlashLed)           ;42
00042b 0392        Task(fLCDLightOff)        ;42
00042c 06a8        Task(fChengeLampLR)       ;43
                 
                 ; Task(fServoInc)
                 ; Task(fServoLR)
                 
                 
                 ;> Список адресов задач
                 ;###############################################################################
                 
                 ;< ##################### Initialization Code ###################################
                 RESET:
                 ;< Config Pin for Proteus debug
                 .if PROTEUS
                +
                +.if ( P_Stop - 1 ) > ( 0x3f )
                +push r16
00042d 9ad4     +lds r16 , P_Stop - 1
                +sbr r16 , ( 1 << Stop )
                   mPinOut Stop
                 .endif
                 ;> Config Pin for Proteus debug
                 
                 
                +
00042e ef0f     +ldi r16 , low ( ( RAMEND ) )
00042f bf0d     +out SPL , r16
000430 e100     +ldi r16 , high ( ( RAMEND ) )
000431 bf0e     +out SPH , r16
                   SetStack (RAMEND)
000432 2433        clr   ZERO
                +
000433 e1cc     +ldi YL , 28
000434 27dd     +clr YH
000435 27ee     +clr ZL
000436 27ff     +clr ZH
                +L_AllRegZero :
000437 93ea     +st - y , ZL
000438 23cc     +tst YL
000439 f7e9     +brne L_AllRegZero
                   mAllRegZero
                +
                +.if SRAM_START < SRAM_START || RAMEND > RAMEND
                +.error "mMemFill: Parameter(s) out of range!"
MacroEX.asm(499): Ok
                +.else 
00043a e0c0     +.message "Ok"
00043b e0d1     +ldi YL , low ( SRAM_START )
00043c e0e0     +ldi YH , high ( SRAM_START )
                +ldi ZL , 0x00
00043d 93e9     +LMemClr_Loop :
00043e 3fcf     +st y + , ZL
00043f e100     +cpi YL , low ( RAMEND )
000440 07d0     +ldi r16 , high ( RAMEND )
000441 f3d8     +cpc YH , r16
                +brlo LMemClr_Loop
                +
                +.endif 
                   mMemFill SRAM_START,RAMEND,0x00
                 
                +
000442 be3f     +out SREG , ZERO
000443 2422     +clr r_TaskS
000444 24aa     +clr r_CNTTASK
000445 d49c     +rcall krClearTimers
000446 d48f     +rcall krClearTaskQueue
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +
                +.set F_T0_Ovf = 100
                +.set N_Cnt = 8
                +.set FnMin = 0
                +.set FnMax = ( 1 << N_Cnt ) - 1
                +
                +.set PreDivMin = Fclk / ( F_T0_Ovf * ( ( 1 << N_Cnt ) - FnMin ) )
                +.set PreDivMax = Fclk / ( F_T0_Ovf * ( ( 1 << N_Cnt ) - FnMax ) )
                +
                +
                +
RTOSA/RTOSA.inc(305):  +--------------+
                +.message " +--------------+"
RTOSA/RTOSA.inc(306):  |PreDiv for TC0|
                +.message " |PreDiv for TC0|"
                +
                +.if PreDivMin < 1
                +.message " |   Div1       |"
                +.set PreDiv = 1
                +.set Val_TCCR0 = T0Div1
                +.elif PreDivMin < 8
RTOSA/RTOSA.inc(325):  |   Div1024    |
                +.message " |   Div8       |"
                +.set PreDiv = 8
                +.set Val_TCCR0 = T0Div8
                +.elif PreDivMin < 64
                +.message " |   Div64      |"
RTOSA/RTOSA.inc(331):  +--------------+
                +.set PreDiv = 64
                +.set Val_TCCR0 = T0Div64
000447 e007     +.elif PreDivMin < 256
000448 bf03     +.message " |   Div256     |"
                +.set PreDiv = 256
                +.set Val_TCCR0 = T0Div256
                +.elif PreDivMin < 1024
                +.message " |   Div1024    |"
                +.set PreDiv = 1024
                +.set Val_TCCR0 = T0Div1024
                +.else 
                +mInitTicOS 100
                +
000449 b707     +in AL , TIMSK
00044a 6002     +ori AL , ( 1 << OCIE0 )
                +
00044b bf07     +out TIMSK , AL
                +
00044c c028     +rjmp mINIT_RTOSA_Ret
                +
                +
                +.set OldPC = pc
                +.org OC0addr
00001e c42e     +rjmp INT_OC0
                +.org OldPC
                +
                +
                +
                +
                +INT_OC0 :
00044d b66f     +in TmpSREG , SREG
00044e 930f     +push AL
00044f 931f     +push AH
                +
000450 e90c     +ldi AL , Fn
000451 b711     +in AH , OCR0
000452 0f01     +add AL , AH
000453 bf01     +out OCR0 , AL
                +
                +
                +
                +
                +
                +
000454 93ff     +push ZH
000455 93ef     +push ZL
                +mPUSHw Z
000456 932f     +push r18
                +
000457 e5e0     +ldi ZL , low ( TimersPool )
000458 e0f1     +ldi ZH , high ( TimersPool )
000459 e120     +ldi r18 , TIMERSPOOLSIZE
                +
                +lTimerService_Loop :
00045a 8100     +ld AL , z
00045b 3f0f     +cpi AL , 0xFF
00045c f071     +breq lTimerService_Next
                +
                +
00045d 931f     +push AH
00045e 8101     +ldd AL , z + 1
00045f 8112     +ldd AH , z + 2
000460 5001     +subi AL , low ( 1 )
000461 4010     +sbci AH , high ( 1 )
000462 8301     +std z + 1 , AL
000463 8312     +std z + 2 , AH
000464 2b01     +or AL , AH
000465 911f     +pop AH
000466 f421     +brne lTimerService_Next
                +
                +
000467 8100     +ld AL , z
000468 d4a7     +rcall krSendTask
                +
000469 ef0f     +ldi AL , 0xFF
00046a 8300     +st z , AL
                +
                +lTimerService_Next :
                +
                +
00046b 9633     +adiw ZL , 3
00046c 952a     +dec r18
00046d f761     +brne lTimerService_Loop
                +
00046e 912f     +pop r18
                +
00046f 91ef     +pop ZL
000470 91ff     +pop ZH
                +mPOPw Z
                +
                +
                +
                +mTimerService
000471 911f     +pop AH
000472 910f     +pop AL
000473 be6f     +out SREG , TmpSREG
000474 9518     +reti
                +
                +
                +
                +
                +
                +
                +mINIT_RTOSA_Ret :
                   mINIT_RTOSA
                 
                 
                 ;###############################################################################
                 
                 
                   ;< Init LED
                +
                +.if ( P_LedRed - 1 ) > ( 0x3f )
000475 930f     +push r16
000476 9100 0064+lds r16 , P_LedRed - 1
000478 6001     +sbr r16 , ( 1 << LedRed )
000479 9300 0064+sts P_LedRed - 1 , r16
00047b 910f     +pop r16
                +.else 
                +sbi P_LedRed - 1 , LedRed
                     mPinOut LedRed
                +
                +.if ( P_LedGrn - 1 ) > ( 0x3f )
00047c 930f     +push r16
00047d 9100 0064+lds r16 , P_LedGrn - 1
00047f 6002     +sbr r16 , ( 1 << LedGrn )
000480 9300 0064+sts P_LedGrn - 1 , r16
000482 910f     +pop r16
                +.else 
                +sbi P_LedGrn - 1 , LedGrn
                     mPinOut LedGrn
                +
                +.if P_LedRed > ( 0x3f )
000483 930f     +push r16
000484 931f     +push r17
000485 b71f     +in r17 , SREG
000486 9100 0065+lds r16 , P_LedRed
000488 7f0e     +cbr r16 , ( 1 << LedRed )
000489 9300 0065+sts P_LedRed , r16
00048b bf1f     +out SREG , r17
00048c 911f     +pop r17
00048d 910f     +pop r16
                +.else 
                +cbi P_LedRed , LedRed
                     mPinCLR LedRed
                +
                +.if P_LedGrn > ( 0x3f )
00048e 930f     +push r16
00048f 931f     +push r17
000490 b71f     +in r17 , SREG
000491 9100 0065+lds r16 , P_LedGrn
000493 6002     +sbr r16 , ( 1 << LedGrn )
000494 9300 0065+sts P_LedGrn , r16
000496 bf1f     +out SREG , r17
000497 911f     +pop r17
000498 910f     +pop r16
                +.else 
                +sbi P_LedGrn , LedGrn
                     mPinSET LedGrn
                   ;> Init LED
                 
                   ;< Отключим подсветку LCD
000499 def8          rcall fLCDLightOff
                   ;> Отключим подсветку LCD
                 
00049a de47        rcall fLCDInit
                 
                 ;  mSetTimerTask f1sec              ,1 ;1
                 ;  mSetTimerTask fReklama           ,1 ;2
                 ;  mSetTimerTask fDrvOnLeft         ,1 ;3
                 ;  mSetTimerTask fDrvOnRight        ,1 ;4
                 ;  mSetTimerTask fENGet             ,1 ;5
                 ;  mSetTimerTask fGNDMinMax         ,1 ;6
                 ;  mSetTimerTask fGNDGetMidLevel    ,1 ;7
                 ;  mSetTimerTask fMelodyPlay        ,1 ;8
                 ;  mSetTimerTask fInit_FM_LS        ,1 ;9
                 ;  mSetTimerTask fShowSensorsState  ,1 ;10
                 ;  mSetTimerTask fSetLineFlg        ,1 ;11
                 ;  mSetTimerTask fRefreshLCD        ,1 ;12
                 ;  mSetTimerTask fIRTimeOut         ,1 ;13
                 ;  mSetTimerTask fIR_Command        ,1 ;14
                 ;  mSetTimerTask fAdjustAtMonet     ,1 ;15
                 ;  mSetTimerTask fDrvStop           ,1 ;16
                 
00049b d025        rcall fFlashLed
                 
                 ; rcall fReklama
00049c d52f        rcall fBuzerInit
00049d d5ad        rcall fIRInit
00049e d65d        rcall fIR_Command
                 
00049f d364        rcall fLSInit
0004a0 d3f9        rcall fFM_Init
                 
                 ; rcall fBampInit ;
                 
0004a1 d511        rcall fServoInit
0004a2 dda0        rcall fDrvInit
                 
0004a3 dd40        rcall fNCodInit
                 
                 
0004a4 d2de        rcall fRefreshLCD
0004a5 d0d6        rcall fEvent_CLR ; очистка всех событий
0004a6 e00c        ldi   AL, DispControl|DisplayON|CursorOFF|CursorNoFlash
0004a7 9300 01a0   sts   (v_LCDCtrl),  AL
                 
                 
                   ;< For InitAllSensor
                +
                +
                +.if flg_AnyKey < 8
0004a9 7f6d     +cbr r_Flags , ( 1 << flg_AnyKey )
                +.else 
                +cbr r_FlagsH , 1 << ( flg_AnyKey & 0b111 )
                     mFlgClr flg_AnyKey ; show page1 or page2
0004aa 2499          clr     rvInitFlag
                   ;> For InitAllSensor
                 
                 ;
                 
                 ;
0004ab dcfa          rcall fKBDScan
                   ;< Push button "SB2" for EmuInit !"СБРОС НАСТРОЕК"!
0004ac fd00          sbrc  AL, SB2
0004ad d054           rcall fEmuInit ;
0004ae fd00          sbrc  AL, SB2
0004af c007           rjmp L_End_Init ;
                   ;> Push button "SB2" for EmuInit
                 
                   ;< Push button "SB3" for fInitAllSensor !"МЕНЮ"!
0004b0 fd01          sbrc  AL, SB3
0004b1 d03a           rcall fInitAllSensor ;
0004b2 fd01          sbrc  AL, SB3
0004b3 d020           rcall fMenuInfo ;
0004b4 fd01          sbrc  AL, SB3
0004b5 c001           rjmp L_End_Init ;
                   ;> Push button "SB3" for fInitAllSensor
                 
0004b6 d06c           rcall fBeginShow ;
                 
                 L_End_Init:
0004b7 9478        sei
                 
                 ;> ##################### Initialization Code ###################################
                 
                 ;> ########################### Main Code #######################################
                +
                +.equ MainLoop = ( pc )
                 PROC  MainLoop
0004b8 d437        rcall krProcessTaskQueue  ;Обработка очереди задач
0004b9 cffe        rjmp  MainLoop
                +
                +.equ SizeOf_MainLoop = ( pc - MainLoop )
                 ENDP MainLoop
                 ;> ########################## Main Code ########################################
                 
                +
                +.equ Idle = ( pc )
                 PROC Idle
0004ba 9508        ret
                +
                +.equ SizeOf_Idle = ( pc - Idle )
                 ENDP Idle
                 
                +
                +.equ f1sec = ( pc )
                 PROC f1sec
0004bb def2      	rcall fRTC_Inc		      ;
                +
                +.if 1 * 100 > ( 1 << 16 ) || ( 1 * 100 == 0 )
                +.error "Time out range!!!"
0004bc e001     +.else 
0004bd e6a4     +ldi AL , TP_f1sec - TaskProcs
0004be e0b0     +ldi XL , low ( 1 * 100 )
0004bf d46c     +ldi XH , high ( 1 * 100 )
                +rcall krSetTimer
                 	mSetTimerTask f1sec,1s  ;
0004c0 9508      	ret
                +
                +.equ SizeOf_f1sec = ( pc - f1sec )
                 ENDP f1sec
                 
                +
                +.equ fFlashLed = ( pc )
                 PROC fFlashLed
                +
0004c1 930f     +push r16
0004c2 931f     +push r17
0004c3 932f     +push r18
0004c4 b72f     +in r18 , SREG
                +.if P_LedGrn > ( 0x3f )
0004c5 9100 0065+lds r16 , P_LedGrn
0004c7 e012     +ldi r17 , 1 << LedGrn
0004c8 2701     +eor r16 , r17
0004c9 9300 0065+sts P_LedGrn , r16
                +.else 
                +in r16 , P_LedGrn
0004cb bf2f     +ldi r17 , 1 << LedGrn
0004cc 912f     +eor r16 , r17
0004cd 911f     +out P_LedGrn , r16
0004ce 910f     +.endif 
                   mPinCpl LedGrn
                +
                +.if 510 * 100 / 1000 > ( 1 << 16 ) || ( 510 * 100 / 1000 == 0 )
                +.error "Time out range!!!"
0004cf e20a     +.else 
0004d0 e3a3     +ldi AL , TP_fFlashLed - TaskProcs
0004d1 e0b0     +ldi XL , low ( 510 * 100 / 1000 )
0004d2 d459     +ldi XH , high ( 510 * 100 / 1000 )
                +rcall krSetTimer
                 	mSetTimerTask fFlashLed,510ms
0004d3 9508        ret
                +
                +.equ SizeOf_fFlashLed = ( pc - fFlashLed )
                 ENDP fFlashLed
                 
                +
                +.equ fMenuInfo = ( pc )
                 PROC fMenuInfo
0004d4 930f        push  AL
                +
0004d5 e1fe     +ldi ZH , high ( ( sz_ButtonLSFM_1 << 1 ) )
0004d6 e5e6     +ldi ZL , low ( ( sz_ButtonLSFM_1 << 1 ) )
                     LDW   Z   ,(sz_ButtonLSFM_1<<1)
                +
                +
                +
                +.if flg_AnyKey < 8
0004d7 ff61     +sbrs r_Flags , flg_AnyKey
0004d8 c002     +rjmp L_fMenuInfo_1
                +.else 
                +sbrs r_FlagsH , ( flg_AnyKey & 0b111 )
                   mIfFlgCLR flg_AnyKey,rjmp L_fMenuInfo_1
                +
0004d9 e1fe     +ldi ZH , high ( ( sz_ButtonLSFM_2 << 1 ) )
0004da e6e6     +ldi ZL , low ( ( sz_ButtonLSFM_2 << 1 ) )
                     LDW   Z   ,(sz_ButtonLSFM_2<<1)
                 
                  L_fMenuInfo_1:
                +
0004db e0d1     +ldi YH , high ( ( v_InfoBuf ) )
0004dc ebc0     +ldi YL , low ( ( v_InfoBuf ) )
                     LDW   Y   ,(v_InfoBuf)
0004dd e100          ldi   AL  ,LCDBUFFSIZE
0004de d4a4          rcall krMemCopyF2R
                +
                +.if 1800 * 100 / 1000 > ( 1 << 16 ) || ( 1800 * 100 / 1000 == 0 )
                +.error "Time out range!!!"
0004df e207     +.else 
0004e0 eba4     +ldi AL , TP_fMenuInfo - TaskProcs
0004e1 e0b0     +ldi XL , low ( 1800 * 100 / 1000 )
0004e2 d449     +ldi XH , high ( 1800 * 100 / 1000 )
                +rcall krSetTimer
                   mSetTimerTask fMenuInfo,1800ms
0004e3 910f        pop   AL
                 
0004e4 2099        tst   rvInitFlag
0004e5 f409        brne  (pc+1)+1
0004e6 9508          ret
                +
0004e7 930f     +push r16
                +.if flg_AnyKey < 8
0004e8 e002     +ldi r16 , 1 << flg_AnyKey
0004e9 2760     +eor r_Flags , r16
                +.else 
                +ldi r16 , 1 << ( flg_AnyKey & 0b111 )
0004ea 910f     +eor r_FlagsH , r16
                   mFlgCpl flg_AnyKey
0004eb 9508        ret
                +
                +.equ SizeOf_fMenuInfo = ( pc - fMenuInfo )
                 ENDP fMenuInfo
                 
                +
                +.equ fInitAllSensor = ( pc )
                 PROC fInitAllSensor
0004ec 930f        push  AL
                 
                +
                +.if 300 * 100 / 1000 > ( 1 << 16 ) || ( 300 * 100 / 1000 == 0 )
                +.error "Time out range!!!"
0004ed e206     +.else 
0004ee e1ae     +ldi AL , TP_fInitAllSensor - TaskProcs
0004ef e0b0     +ldi XL , low ( 300 * 100 / 1000 )
0004f0 d43b     +ldi XH , high ( 300 * 100 / 1000 )
                +rcall krSetTimer
                   mSetTimerTask fInitAllSensor,300ms
                 
                +
0004f1 e0f1     +ldi ZH , high ( ( v_InfoBuf ) )
0004f2 ebe0     +ldi ZL , low ( ( v_InfoBuf ) )
                   LDW   Z   ,(v_InfoBuf)
                +
0004f3 e0d1     +ldi YH , high ( ( v_LCDBuf ) )
0004f4 e9c0     +ldi YL , low ( ( v_LCDBuf ) )
                   LDW   Y   ,(v_LCDBuf)
0004f5 e100        ldi   AL  ,LCDBUFFSIZE
0004f6 d483        rcall krMemCopyR2R
                 
0004f7 dcae        rcall fKBDScan
                   ;< Push button "SB2" for fInit_FM_LS
0004f8 fd00          sbrc  AL, SB2
0004f9 d0ef            rcall fInit_FM_LS ;
                   ;> Push button "SB2" for fInit_FM_LS
                 
                   ;< Push button "SB4" for fGNDDetect
0004fa fd02          sbrc  AL, SB4
0004fb d2a1            rcall fGNDDetect ;
                   ;> Push button "SB4" for fGNDDetect
                 
0004fc 2099        tst   rvInitFlag
                 
0004fd f011        breq L_fInitAllSensor
                     ;< Push button "SB3" for fBeginShow
0004fe fd01            sbrc  AL, SB3
0004ff d023              rcall fBeginShow ;
                     ;> Push button "SB3" for fBeginShow
                  L_fInitAllSensor:
                 
000500 910f        pop   AL
000501 9508        ret
                 
                +
                +.equ SizeOf_fInitAllSensor = ( pc - fInitAllSensor )
                 ENDP fInitAllSensor
                 
                 
                 
                +
                +.equ fEmuInit = ( pc )
                 PROC fEmuInit
                 
000502 930f        push  AL
                   ;< Emu fGNDDetect
                     ;< Sets v_GNDMin value
000503 e800            ldi   AL      ,GNDMIN ;
                +
000504 e0d1     +ldi YH , high ( ( v_GNDMin ) )
000505 e1ca     +ldi YL , low ( ( v_GNDMin ) )
                       LDW   Y       ,(v_GNDMin)
000506 e014            ldi   AH      ,4
                       ;< loop
000507 9309              st    y+    ,AL
000508 951a              dec   AH
000509 f7e9            brne (pc)-1-1
                       ;> Loop
                     ;> Sets v_GNDMin value
                 
                     ;< Sets v_GNDMax value
00050a ef0f            ldi   AL      ,255
00050b e014            ldi   AH      ,4
                       ;< loop
00050c 9309              st    y+    ,AL
00050d 951a              dec   AH
00050e f7e9            brne (pc)-1-1
                       ;> Loop
                     ;> Sets v_GNDMax value
                 
                   ;> Emu fGNDDetect
                 
00050f d12b        rcall fSaveGNDSensorLevel
                 
                +
000510 e0d2     +ldi YH , high ( ( TMONET ) )
000511 e6c6     +ldi YL , low ( ( TMONET ) )
                   LDW   Y          ,(TMONET)
000512 93c0 0104   sts   (v_FMMidL) ,YL
000514 93d0 0105   sts   (v_FMMidH) ,YH
                 
                +
000516 e9dc     +ldi YH , high ( ( 2000000 / FLAMP ) )
000517 e4c0     +ldi YL , low ( ( 2000000 / FLAMP ) )
                   LDW   Y          ,(2000000/FLAMP)
000518 93c0 010b   sts   (v_LSMidL) ,YL
00051a 93d0 010c   sts   (v_LSMidH) ,YH
                 
00051c d109        rcall fSaveFMLSSensorLevel
                +
00051d 930f     +push AL
00051e e205     +ldi AL , TP_fBeginShow - TaskProcs
00051f d3f0     +rcall krSendTask
000520 910f     +pop AL
                   mSendTask fBeginShow ;
                 
000521 910f        pop   AL
000522 9508        ret
                 
                +
                +.equ SizeOf_fEmuInit = ( pc - fEmuInit )
                 ENDP fEmuInit
                 
                +
                +.equ fBeginShow = ( pc )
                 PROC fBeginShow
000523 d265        rcall fGNDInit
                +
000524 e206     +ldi AL , TP_fInitAllSensor - TaskProcs
000525 d432     +rcall krClrTimer
                +
                   mClrTimer fInitAllSensor; отключает сенсоры
                +
000526 e207     +ldi AL , TP_fMenuInfo - TaskProcs
000527 d430     +rcall krClrTimer
                +
                   mClrTimer fMenuInfo; отключает меню
                 
000528 d11d        rcall fReadFMLSSensorLevel ; читают настройки из памяти
000529 d131        rcall fReadGNDSensorLevel
                 
00052a d051        rcall fEvent_CLR ; очишаются все задачи
00052b d06b        rcall fEvent ; запуск диспетчера событий
                 
                 
                   ;< v_CntMonet = 5
00052c e001          ldi AL          ,1 ; стави счетчик на 5 монет
00052d 9300 0106     sts (v_CntMonet),AL
                   ;> v_CntMonet = 5
                 
                   ;< Sets fGoGoGo on the "Lamp" event
                +
                +
                +.if flg_Lamp < 8
                +cbr r_Flags , ( 1 << flg_Lamp )
00052f 7b7f     +.else 
                +cbr r_FlagsH , 1 << ( flg_Lamp & 0b111 )
                     mFlgClr flg_Lamp; очищаем флаг лампы
000530 e10e          ldi AL    ,GetTaskID(fGoGoGo)
000531 e016          ldi AH    ,GetEventID(v_Event,Lamp)
000532 d03a          rcall fSendEvent
                   ;> Sets fGoGoGo on the "Lamp" event
                 
                 
                +
000533 930f     +push AL
000534 e202     +ldi AL , TP_fInfoSets - TaskProcs
000535 d3da     +rcall krSendTask
000536 910f     +pop AL
                   mSendTask fInfoSets; вывод настроек на экран
                 
                   ;< Clear all FLAGS
000537 2766          clr r_Flags
000538 2777          clr r_FlagsH
                   ;> Clear all FLAGS
                 
                 
000539 9508        ret
                 
                +
                +.equ SizeOf_fBeginShow = ( pc - fBeginShow )
                 ENDP fBeginShow
                 
                 
                +
                +.equ fGoGoGo = ( pc )
                 PROC fGoGoGo
                +
00053a e202     +ldi AL , TP_fInfoSets - TaskProcs
00053b d41c     +rcall krClrTimer
                +
                   mClrTimer fInfoSets
                 
                +
                +.if ( 5 * 60 ) * 100 > ( 1 << 16 ) || ( ( 5 * 60 ) * 100 == 0 )
                +.error "Time out range!!!"
00053c e109     +.else 
00053d e3a0     +ldi AL , TP_fSearch_Finish - TaskProcs
00053e e7b5     +ldi XL , low ( ( 5 * 60 ) * 100 )
00053f d3ec     +ldi XH , high ( ( 5 * 60 ) * 100 )
                +rcall krSetTimer
                   mSetTimerTask fSearch_Finish,(TIMEOUT)s
                   ;< Run  RTC
                +
000540 de64     +rcall fRTC_Init
                     mRTC_Init
000541 df79          rcall f1sec
                   ;> Run  RTC
                 
                +
000542 930f     +push AL
000543 e00a     +ldi AL , TP_fShowSensorsState - TaskProcs
000544 d3cb     +rcall krSendTask
000545 910f     +pop AL
                   mSendTask fShowSensorsState
                 
                   ;< Clear Lamp event
000546 9230 0128     sts   (v_Event_Lamp),ZERO ;Idle
                   ;> Clear Lamp event
                 
000548 e686        ldi   rvSpeedLR   ,0x66
                 
                   ;< Lamp on the Right
                +
                +
                +.if flg_LS_LR < 8
000549 7f67     +cbr r_Flags , ( 1 << flg_LS_LR )
                +.else 
                +cbr r_FlagsH , 1 << ( flg_LS_LR & 0b111 )
                     mFlgClr  flg_LS_LR    ; 1 - Left; 0 - Right
                   ;> Lamp on the Right
                 
                   ;< Searching a lamp on the left or right side
                +
                +.if 1000 * 100 / 1000 > ( 1 << 16 ) || ( 1000 * 100 / 1000 == 0 )
                +.error "Time out range!!!"
00054a e10f     +.else 
00054b e6a4     +ldi AL , TP_fSearchLampLR - TaskProcs
00054c e0b0     +ldi XL , low ( 1000 * 100 / 1000 )
00054d d3de     +ldi XH , high ( 1000 * 100 / 1000 )
                +rcall krSetTimer
                     mSetTimerTask fSearchLampLR,  1000ms
                   ;> Searching a lamp on the left or right side
                 
00054e 9508        ret
                 
                +
                +.equ SizeOf_fGoGoGo = ( pc - fGoGoGo )
                 ENDP fGoGoGo
                 
                 
                 
                +
                +.equ fSearchLampLR = ( pc )
                 PROC fSearchLampLR
                 
00054f dd72        rcall fDrvStop
                 
                   ;< Clear Lamp event
000550 9230 0128     sts   (v_Event_Lamp),ZERO ;Idle
                   ;> Clear Lamp event
                 
                   ;< Stop servo scan
                +
000552 e10b     +ldi AL , TP_fScanMonet - TaskProcs
000553 d404     +rcall krClrTimer
                +
                     mClrTimer    fScanMonet; скинирует монеты
                   ;> Stop servo scan
                 
                   ;< v_CntMonet check at the mission complete
000554 9100 0106     lds AL            ,(v_CntMonet)
000556 2300          tst AL
000557 f411          brne (pc+1)+1+1
000558 d1a5            rcall fSearch_Finish
000559 9508            ret
                   ;> v_CntMonet check at the mission complete
                 
                   
                   ;< Lamp on the right
                +
                +.if flg_LS_LR < 8
00055a ff63     +sbrs r_Flags , flg_LS_LR
                +.else 
                +sbrs r_FlagsH , flg_LS_LR & 0b111
                     mFlgSkipSet  flg_LS_LR    ; 1 - Left; 0 - Right
00055b e099            ldi   rvIndxServo   ,9 ;Sets the Servo into right Max position
                   ;> Lamp on the right
                 
                   ;< Lamp on the left
                +
                +.if flg_LS_LR < 8
00055c fd63     +sbrc r_Flags , flg_LS_LR
                +.else 
                +sbrc r_FlagsH , flg_LS_LR & 0b111
                     mFlgSkipClr  flg_LS_LR    ; 1 - Left; 0 - Right
00055d e09a            ldi   rvIndxServo   ,10 ;Sets the Servo into left Max position
                   ;> Lamp on the left
                 
                 
                   ;< Sets fChengeLampLR on the "Lamp" event
                +
                +
                +.if flg_Lamp < 8
                +cbr r_Flags , ( 1 << flg_Lamp )
00055e 7b7f     +.else 
                +cbr r_FlagsH , 1 << ( flg_Lamp & 0b111 )
                     mFlgClr flg_Lamp
00055f e10c          ldi AL    ,GetTaskID(fSearchMove)
000560 e016          ldi AH    ,GetEventID(v_Event,Lamp)
000561 d00b          rcall fSendEvent
                   ;> Sets fChengeLampLR on the "Lamp" event
                 
                   ;< Sets fSearchLampLR on the "EndMov" event
000562 e10f          ldi AL              ,GetTaskID(fSearchLampLR)
000563 9300 012c     sts (v_Event_EndMov),AL
                   ;> Sets fSearchLampLR on the "EndMov" event
                 
                 
                +
000565 e1dc     +ldi YH , high ( ( ct_Rotate2R << 1 ) )
000566 eac0     +ldi YL , low ( ( ct_Rotate2R << 1 ) )
                   LDW   Y     ,(ct_Rotate2R<<1)
                +
                +
                +
                +.if flg_LS_LR < 8
000567 fd63     +sbrc r_Flags , flg_LS_LR
000568 c002     +rjmp L_fSearchLampLR_Skip
                +.else 
                +sbrc r_FlagsH , flg_LS_LR & 0b111
                   mIfFlgSET flg_LS_LR, rjmp L_fSearchLampLR_Skip
                +
000569 e1dc     +ldi YH , high ( ( ct_Rotate2L << 1 ) )
00056a eacc     +ldi YL , low ( ( ct_Rotate2L << 1 ) )
                     LDW   Y     ,(ct_Rotate2L<<1)
                  L_fSearchLampLR_Skip:  
00056b dd1c        rcall fMoveEX_Run
                 
00056c 9508        ret
                 
                +
                +.equ SizeOf_fSearchLampLR = ( pc - fSearchLampLR )
                 ENDP fSearchLampLR
                 
                 ; ldi AL    ,GetTaskID(fSearchMove)
                 ; ldi AH    ,GetEventID(v_Event,Lamp)
                 ; rcall fSendEvent
                +
                +.equ fSendEvent = ( pc )
                 PROC fSendEvent
00056d 2eb1        mov rvIDEvent ,AH
00056e 2ec0        mov rvIDTask  ,AL
                +
                +.if 400 * 100 / 1000 > ( 1 << 16 ) || ( 400 * 100 / 1000 == 0 )
                +.error "Time out range!!!"
00056f e209     +.else 
000570 e2a8     +ldi AL , TP_fkrSetEvent - TaskProcs
000571 e0b0     +ldi XL , low ( 400 * 100 / 1000 )
000572 d3b9     +ldi XH , high ( 400 * 100 / 1000 )
                +rcall krSetTimer
                   mSetTimerTask fkrSetEvent,400ms
000573 9508        ret
                +
                +.equ SizeOf_fSendEvent = ( pc - fSendEvent )
                 ENDP fSendEvent
                 
                 
                +
                +.equ fkrSetEvent = ( pc )
                 PROC fkrSetEvent
                 .ifdef	PROTEUS
                +
                +
                +.if P_Stop > ( 0x3f )
                +push r16
000574 98dc     +push r17
                +in r17 , SREG
                +mPinCLR Stop
                +
                +.if P_Stop > ( 0x3f )
                +push r16
000575 9adc     +push r17
                +in r17 , SREG
                +mPinSET Stop
                +
                +
                   	mStop
                   .endif
                +
000576 e0d1     +ldi YH , high ( ( v_Event ) )
000577 e2c2     +ldi YL , low ( ( v_Event ) )
                     LDW   Y       ,(v_Event)
000578 0dcb        add   YL      ,rvIDEvent
000579 1dd3        adc   YH      ,ZERO
00057a 82c8        st    y       ,rvIDTask
00057b 9508        ret
                +
                +.equ SizeOf_fkrSetEvent = ( pc - fkrSetEvent )
                 ENDP fkrSetEvent
                 
                 
                +
                +.equ fEvent_CLR = ( pc )
                 PROC fEvent_CLR
                   ;< Idle for all events
00057c 9230 0122   sts (v_Event_LFL)   ,ZERO ; LINE FRONT-L
00057e 9230 0123   sts (v_Event_LRL)   ,ZERO ; LINE REAR-L
000580 9230 0124   sts (v_Event_LFR)   ,ZERO ; LINE FRONT-R
000582 9230 0125   sts (v_Event_LRR)   ,ZERO ; LINE REAR-R
000584 9230 0126   sts (v_Event_BampF) ,ZERO ; Препятствие спереди
000586 9230 0127   sts (v_Event_BampR) ,ZERO ; Препятствие сзади
000588 9230 0128   sts (v_Event_Lamp)  ,ZERO ;
00058a 9230 0129   sts (v_Event_Monet) ,ZERO ;
00058c 9230 012c   sts (v_Event_EndMov),ZERO ; Task at THE END of current MOVE LIST
00058e 9230 012d   sts (v_Event_Melody),ZERO ; Task at THE END of current MELODY
                   ;> Idle for all events
                 
000590 e105        ldi AL              ,GetTaskID(fDrvStopR)
000591 9300 012b   sts (v_Event_StepR) ,AL  ;
000593 e104        ldi AL              ,GetTaskID(fDrvStopL)
000594 9300 012a   sts (v_Event_StepL) ,AL  ;
000596 9508        ret
                 
                +
                +.equ SizeOf_fEvent_CLR = ( pc - fEvent_CLR )
                 ENDP fEvent_CLR
                 
                +
                +.equ fEvent = ( pc )
                 PROC fEvent
000597 930f        push  AL
                 
                +
                +.if flg_ADC < 8
000598 fd62     +sbrc r_Flags , flg_ADC
                +.else 
                +sbrc r_FlagsH , flg_ADC & 0b111
                   mFlgSkipClr flg_ADC ;Converting complete. For all ADC canals
000599 d1ad          rcall fSetLineFlg
                 
                   ;< Check event "LINE xxx"
                 
                     ;< Check event "LINE FRONT-L"
00059a 9100 0122       lds AL      ,(v_Event_LFL)
                 ;      tst AL
                 ;      breq (pc+1)+4
                +
                +.if flg_LFL < 8
                +sbrc r_Flags , flg_LFL
00059c fd70     +rcall krSendTask
00059d d372     +sbrc r_Flags , flg_LFL
00059e fd70     +cbr r_Flags , ( 1 << flg_LFL )
00059f 7f7e     +.else 
                +sbrc r_FlagsH , flg_LFL & 0b111
                         mSendTaskIfSETC_AL flg_LFL
                     ;> Check event "LINE FRONT-L"
                 
                     ;< Check event "LINE REAR-L"
0005a0 9100 0123       lds AL      ,(v_Event_LRL)
                 ;      tst AL
                 ;      breq (pc+1)+4
                +
                +.if flg_LRL < 8
                +sbrc r_Flags , flg_LRL
0005a2 fd72     +rcall krSendTask
0005a3 d36c     +sbrc r_Flags , flg_LRL
0005a4 fd72     +cbr r_Flags , ( 1 << flg_LRL )
0005a5 7f7b     +.else 
                +sbrc r_FlagsH , flg_LRL & 0b111
                         mSendTaskIfSETC_AL flg_LRL
                     ;> Check event "LINE REAR-L"
                 
                     ;< Checking event "LINE FRONT-R"
0005a6 9100 0124       lds AL      ,(v_Event_LFR)
                 ;      tst AL
                 ;      breq (pc+1)+4
                +
                +.if flg_LFR < 8
                +sbrc r_Flags , flg_LFR
0005a8 fd71     +rcall krSendTask
0005a9 d366     +sbrc r_Flags , flg_LFR
0005aa fd71     +cbr r_Flags , ( 1 << flg_LFR )
0005ab 7f7d     +.else 
                +sbrc r_FlagsH , flg_LFR & 0b111
                         mSendTaskIfSETC_AL flg_LFR
                     ;> Checking event "LINE FRONT-R"
                 
                     ;< Check event "LINE REAR-R"
0005ac 9100 0125       lds AL      ,(v_Event_LRR)
                 ;      tst AL
                 ;      breq (pc+1)+4
                +
                +.if flg_LRR < 8
                +sbrc r_Flags , flg_LRR
0005ae fd73     +rcall krSendTask
0005af d360     +sbrc r_Flags , flg_LRR
0005b0 fd73     +cbr r_Flags , ( 1 << flg_LRR )
0005b1 7f77     +.else 
                +sbrc r_FlagsH , flg_LRR & 0b111
                         mSendTaskIfSETC_AL flg_LRR
                     ;> Check event "LINE REAR-R"
                 
                   ;> Check event "LINE xxx"
                 
                 ;  ;< Check event "BampF"
                 ;    lds AL      ,(v_Event_BampF)
                 ;    tst AL
                 ;    breq (pc+1)+4
                 ;      mSendTaskIfSETC_AL flg_BampF  ; 4b
                 ;  ;> Check event "BampF"
                 
                 ;  ;< Check event "BampR"
                 ;    lds AL      ,(v_Event_BampR)
                 ;    tst AL
                 ;    breq (pc+1)+4
                 ;      mSendTaskIfSETC_AL flg_BampR
                 ;  ;> Check event "BampR"
                 
                   ;< Check event "Lamp"
0005b2 9100 0128     lds AL      ,(v_Event_Lamp)
                 ;    tst AL
                 ;    breq (pc+1)+4
                +
                +.if flg_Lamp < 8
                +sbrc r_Flags , flg_Lamp
0005b4 fd76     +rcall krSendTask
0005b5 d35a     +sbrc r_Flags , flg_Lamp
0005b6 fd76     +cbr r_Flags , ( 1 << flg_Lamp )
0005b7 7b7f     +.else 
                +sbrc r_FlagsH , flg_Lamp & 0b111
                       mSendTaskIfSETC_AL flg_Lamp
                   ;> Check event "Lamp"
                 
                   ;< Check event "Monet"
0005b8 9100 0129   lds AL      ,(v_Event_Monet)
                 ;    tst AL
                 ;    breq (pc+1)+4
                +
                +.if flg_Monet < 8
                +sbrc r_Flags , flg_Monet
0005ba fd77     +rcall krSendTask
0005bb d354     +sbrc r_Flags , flg_Monet
0005bc fd77     +cbr r_Flags , ( 1 << flg_Monet )
0005bd 777f     +.else 
                +sbrc r_FlagsH , flg_Monet & 0b111
                     mSendTaskIfSETC_AL flg_Monet
                   ;> Check event "Monet"
                 
                +
                +.if 50 * 100 / 1000 > ( 1 << 16 ) || ( 50 * 100 / 1000 == 0 )
                +.error "Time out range!!!"
0005be e101     +.else 
0005bf e0a5     +ldi AL , TP_fEvent - TaskProcs
0005c0 e0b0     +ldi XL , low ( 50 * 100 / 1000 )
0005c1 d36a     +ldi XH , high ( 50 * 100 / 1000 )
                +rcall krSetTimer
                   mSetTimerTask fEvent,50ms
                 
0005c2 910f        pop AL
0005c3 9508        ret
                 
                +
                +.equ SizeOf_fEvent = ( pc - fEvent )
                 ENDP fEvent
                 
                +
                +.equ fCalcMid_FM_LS = ( pc )
                 PROC fCalcMid_FM_LS
                   ;< v_FMMid = (v_FMMid + v_FMCur)/2
0005c4 9100 0104   lds   AL        ,(v_FMMidL)
0005c6 9110 0100   lds   AH        ,(v_FMCurL)
0005c8 0f01        add   AL        ,AH
0005c9 930f        push  AL
0005ca 9100 0101   lds   AL        ,(v_FMCurH)
0005cc 9110 0105   lds   AH        ,(v_FMMidH)
0005ce 1f10        adc   AH        ,AL
0005cf 9517        ror   AH
0005d0 910f        pop   AL
0005d1 9507        ror   AL
0005d2 9300 0104   sts   (v_FMMidL),AL
0005d4 9310 0105   sts   (v_FMMidH),AH
                   ;> v_FMMid = (v_FMMid + v_FMCur)/2
                 
                    ;< v_LSMid = (v_LSMid + v_LSCur)/2
0005d6 9100 0107   lds   AL        ,(v_LSCurL)
0005d8 9110 010b   lds   AH        ,(v_LSMidL)
0005da 0f01        add   AL        ,AH
                 
0005db 930f        push  AL
0005dc 9110 0108   lds   AH        ,(v_LSCurH)
0005de 9100 010c   lds   AL        ,(v_LSMidH)
0005e0 1f10        adc   AH        ,AL
0005e1 9517        ror   AH
                 
0005e2 910f        pop   AL
0005e3 9507        ror   AL
                 
0005e4 9300 010b   sts   (v_LSMidL),AL
0005e6 9310 010c   sts   (v_LSMidH),AH
                   ;> v_LSMid = (v_LSMid + v_LSCur)/2
                 
0005e8 9508        ret
                +
                +.equ SizeOf_fCalcMid_FM_LS = ( pc - fCalcMid_FM_LS )
                 ENDP fCalcMid_FM_LS
                 
                +
                +.equ fInit_FM_LS = ( pc )
                 PROC fInit_FM_LS
0005e9 930f        push  AL
                 
                +
0005ea e206     +ldi AL , TP_fInitAllSensor - TaskProcs
0005eb d36c     +rcall krClrTimer
                +
                   mClrTimer fInitAllSensor
                 
0005ec 9493        inc   rvInitFlag
                 
0005ed dfd6        rcall fCalcMid_FM_LS
                 
                +
                +
0005ee e0d1     +ldi YH , high ( ( v_LCDBuf ) )
0005ef e9c0     +ldi YL , low ( ( v_LCDBuf ) )
                +LDW Y , ( v_LCDBuf )
0005f0 dd82     +rcall fLCDBuffCLR
                   mLCDBuffCLR (v_LCDBuf)
                 
                 
                +
0005f1 e0d1     +ldi YH , high ( ( v_LCDBuf1 ) )
0005f2 e9c0     +ldi YL , low ( ( v_LCDBuf1 ) )
                   LDW Y   ,(v_LCDBuf1)
0005f3 e40c        ldi AL  ,'L'
0005f4 9309        st  y+  ,AL
0005f5 e503        ldi AL  ,'S'
0005f6 9309        st  y+  ,AL
0005f7 e30a        ldi AL  ,':'
0005f8 9309        st  y+  ,AL
                 
                +
0005f9 e0d1     +ldi YH , high ( ( v_LCDBuf + 3 ) )
0005fa e9c3     +ldi YL , low ( ( v_LCDBuf + 3 ) )
                   LDW Y   ,(v_LCDBuf+3)
0005fb 9100 010b   lds AL  ,(v_LSMidL)
0005fd 9110 010c   lds AH  ,(v_LSMidH)
0005ff d5c6        rcall fw2a
                 
                +
000600 e0d1     +ldi YH , high ( ( v_LCDBuf2 ) )
000601 e9c8     +ldi YL , low ( ( v_LCDBuf2 ) )
                   LDW Y   ,(v_LCDBuf2)
000602 9100 0104   lds AL  ,(v_FMMidL)
000604 9110 0105   lds AH  ,(v_FMMidH)
000606 d5bf        rcall fw2a
                 
                 
                +
000607 e0d1     +ldi YH , high ( ( v_LCDBuf2 + 4 ) )
000608 e9cc     +ldi YL , low ( ( v_LCDBuf2 + 4 ) )
                   LDW Y   ,(v_LCDBuf2+4)
000609 e503        ldi AL  ,'S'
00060a 9309        st  y+  ,AL
00060b e402        ldi AL  ,'B'
00060c 9309        st  y+  ,AL
00060d e304        ldi AL  ,'4'
00060e 9309        st  y+  ,AL
00060f e70e        ldi AL  ,126
000610 9309        st  y+  ,AL
                 
                 
000611 db94        rcall fKBDScan
000612 fd02        sbrc  AL, SB4
000613 c005          rjmp L_Init_FM_LS_exit ;If Push key "SB4"
                 
                +
                +.if ( 110 * 100 / 1000 ) > ( 1 << 16 ) || ( ( 110 * 100 / 1000 ) == 0 )
                +.error "Time out range!!!"
000614 e009     +.else 
000615 e0ab     +ldi AL , TP_fInit_FM_LS - TaskProcs
000616 e0b0     +ldi XL , low ( ( 110 * 100 / 1000 ) )
000617 d314     +ldi XH , high ( ( 110 * 100 / 1000 ) )
                +rcall krSetTimer
                   mSetTimerTask fInit_FM_LS,(110ms)
000618 c00b        rjmp L_Init_FM_LS_ret
                 
                  L_Init_FM_LS_exit:
000619 d00c        rcall fSaveFMLSSensorLevel
                +
00061a e1fe     +ldi ZH , high ( ( sz_Init_FM_LS_OK << 1 ) )
00061b e7e6     +ldi ZL , low ( ( sz_Init_FM_LS_OK << 1 ) )
                   LDW   Z   ,(sz_Init_FM_LS_OK<<1)
                +
00061c e0d1     +ldi YH , high ( ( v_LCDBuf ) )
00061d e9c0     +ldi YL , low ( ( v_LCDBuf ) )
                   LDW   Y   ,(v_LCDBuf)
00061e e100        ldi   AL  ,LCDBUFFSIZE
00061f d363        rcall krMemCopyF2R
                +
                +.if 3 * 100 > ( 1 << 16 ) || ( 3 * 100 == 0 )
                +.error "Time out range!!!"
000620 e206     +.else 
000621 e2ac     +ldi AL , TP_fInitAllSensor - TaskProcs
000622 e0b1     +ldi XL , low ( 3 * 100 )
000623 d308     +ldi XH , high ( 3 * 100 )
                +rcall krSetTimer
                   mSetTimerTask fInitAllSensor,3s
                 
                  L_Init_FM_LS_ret:
000624 910f        pop   AL
000625 9508        ret
                 
                +
                +.equ SizeOf_fInit_FM_LS = ( pc - fInit_FM_LS )
                 ENDP fInit_FM_LS
                 
                +
                +.equ fSaveFMLSSensorLevel = ( pc )
                 PROC fSaveFMLSSensorLevel
                   ;< Save FM to EEPROM
                +
000626 e0d0     +ldi YH , high ( ( e_FMMid ) )
000627 e1c2     +ldi YL , low ( ( e_FMMid ) )
                   LDW   Y   ,(e_FMMid)
                +
000628 e0b1     +ldi XH , high ( ( v_FMMid ) )
000629 e0a4     +ldi XL , low ( ( v_FMMid ) )
                   LDW   X   ,(v_FMMid)
00062a e012        ldi   AH  ,2
                   ;                  ;-<--------+
00062b 910d          ld  AL  ,x+      ;          |
00062c d29a          rcall fEEWrite   ;          |
00062d 9621          adiw  YL, 1      ;          |
00062e 951a          dec AH           ;          |
00062f f7d9        brne (pc)-1-1-1-1  ;--------->+
                   ;> Save FM to EEPROM
                 
                   ;< Save LS to EEPROM
                +
000630 e0d0     +ldi YH , high ( ( e_LSMid ) )
000631 e1c0     +ldi YL , low ( ( e_LSMid ) )
                   LDW   Y   ,(e_LSMid)
                +
000632 e0b1     +ldi XH , high ( ( v_LSMid ) )
000633 e0ab     +ldi XL , low ( ( v_LSMid ) )
                   LDW   X   ,(v_LSMid)
000634 e012        ldi   AH  ,2
                   ;                  ;-<--------+
000635 910d          ld  AL  ,x+      ;          |
000636 d290          rcall fEEWrite   ;          |
000637 9621          adiw  YL, 1      ;          |
000638 951a          dec AH           ;          |
000639 f7d9        brne (pc)-1-1-1-1  ;--------->+
                   ;> Save LS to EEPROM
00063a 9508        ret
                +
                +.equ SizeOf_fSaveFMLSSensorLevel = ( pc - fSaveFMLSSensorLevel )
                 ENDP fSaveFMLSSensorLevel
                 
                +
                +.equ fSaveGNDSensorLevel = ( pc )
                 PROC fSaveGNDSensorLevel
                +
00063b e0d0     +ldi YH , high ( ( e_GNDMin ) )
00063c e1c4     +ldi YL , low ( ( e_GNDMin ) )
                   LDW   Y   ,(e_GNDMin)
                +
00063d e0b1     +ldi XH , high ( ( v_GNDMin ) )
00063e e1aa     +ldi XL , low ( ( v_GNDMin ) )
                   LDW   X   ,(v_GNDMin)
00063f e018        ldi   AH  ,8
                   ;                  ;-<--------+
000640 910d          ld  AL  ,x+      ;          |
000641 d285          rcall fEEWrite   ;          |
000642 9621          adiw  YL, 1      ;          |
000643 951a          dec AH           ;          |
000644 f7d9        brne (pc)-1-1-1-1  ;--------->+
000645 9508        ret
                +
                +.equ SizeOf_fSaveGNDSensorLevel = ( pc - fSaveGNDSensorLevel )
                 ENDP fSaveGNDSensorLevel
                 
                +
                +.equ fReadFMLSSensorLevel = ( pc )
                 PROC fReadFMLSSensorLevel
                   ;< Read FM from EEPROM
                +
000646 e0d0     +ldi YH , high ( ( e_FMMid ) )
000647 e1c2     +ldi YL , low ( ( e_FMMid ) )
                   LDW   Y   ,(e_FMMid)
                +
000648 e0b1     +ldi XH , high ( ( v_FMMid ) )
000649 e0a4     +ldi XL , low ( ( v_FMMid ) )
                   LDW   X   ,(v_FMMid)
00064a e012        ldi   AH  ,2
                   ;                  ;-<--------+
00064b d283          rcall fEERead    ;          |
00064c 930d          st    x+  ,AL    ;          |
00064d 9621          adiw  YL  ,1     ;          |
00064e 951a          dec AH           ;          |
00064f f7d9        brne (pc)-1-1-1-1  ;--------->+
                   ;> Read FM from EEPROM
                 
                   ;< Read LS from EEPROM
                +
000650 e0d0     +ldi YH , high ( ( e_LSMid ) )
000651 e1c0     +ldi YL , low ( ( e_LSMid ) )
                   LDW   Y   ,(e_LSMid)
                +
000652 e0b1     +ldi XH , high ( ( v_LSMid ) )
000653 e0ab     +ldi XL , low ( ( v_LSMid ) )
                   LDW   X   ,(v_LSMid)
000654 e012        ldi   AH  ,2
                   ;                  ;-<--------+
000655 d279          rcall fEERead    ;          |
000656 930d          st    x+  ,AL    ;          |
000657 9621          adiw  YL  ,1     ;          |
000658 951a          dec AH           ;          |
000659 f7d9        brne (pc)-1-1-1-1  ;--------->+
                   ;> Read LS from EEPROM
00065a 9508        ret
                +
                +.equ SizeOf_fReadFMLSSensorLevel = ( pc - fReadFMLSSensorLevel )
                 ENDP fReadFMLSSensorLevel
                 
                +
                +.equ fReadGNDSensorLevel = ( pc )
                 PROC fReadGNDSensorLevel
                +
00065b e0d0     +ldi YH , high ( ( e_GNDMin ) )
00065c e1c4     +ldi YL , low ( ( e_GNDMin ) )
                   LDW   Y   ,(e_GNDMin)
                +
00065d e0b1     +ldi XH , high ( ( v_GNDMin ) )
00065e e1aa     +ldi XL , low ( ( v_GNDMin ) )
                   LDW   X   ,(v_GNDMin)
00065f e018        ldi   AH  ,8
                   ;                  ;-<--------+
000660 d26e          rcall fEERead    ;          |
000661 930d          st    x+  ,AL    ;          |
000662 9621          adiw  YL  ,1     ;          |
000663 951a          dec AH           ;          |
000664 f7d9        brne (pc)-1-1-1-1  ;--------->+
000665 9508        ret
                +
                +.equ SizeOf_fReadGNDSensorLevel = ( pc - fReadGNDSensorLevel )
                 ENDP fReadGNDSensorLevel
                 
                +
                +.equ fCoverMonet = ( pc )
                 PROC fCoverMonet
                 
                 
                   ;< Sets fRotate on the "Melody" event
000666 e10d          ldi   AL              ,GetTaskID(fRotate)
000667 9300 012d     sts   (v_Event_Melody),AL
                   ;> Sets fRotate on the "Melody" event
                 
                   ;< Sets fCoverMonet on the "EndMov" event
000669 e201          ldi   AL              ,GetTaskID(fMelodyMoneta)
00066a 9300 012c     sts   (v_Event_EndMov),AL
                   ;> Sets fCoverMonet on the "EndMov" event
                +
00066c e1dc     +ldi YH , high ( ( ct_MoveCover << 1 ) )
00066d ebc8     +ldi YL , low ( ( ct_MoveCover << 1 ) )
                   LDW   Y ,(ct_MoveCover<<1)
00066e dc19        rcall fMoveEX_Run
                 
00066f 9508        ret
                 
                +
                +.equ SizeOf_fCoverMonet = ( pc - fCoverMonet )
                 ENDP fCoverMonet
                 
                +
                +.equ fAdjustAtMonet = ( pc )
                 PROC fAdjustAtMonet
                +
000670 e10b     +ldi AL , TP_fScanMonet - TaskProcs
000671 d2e6     +rcall krClrTimer
                +
                   mClrTimer    fScanMonet
                 
                   ;< Clear "Monet" event
000672 9230 0129     sts   (v_Event_Monet),ZERO ;Idle
                   ;> Clear "Monet" event
                 
                   ;< Clear "Lamp" event
000674 9230 0128     sts   (v_Event_Lamp),ZERO ;Idle
                   ;> Clear "Lamp" event
                 
000676 dc4b        rcall fDrvStop
                 
                   ;< Clear "LINE FRONT-L" and "LINE FRONT-R" event
000677 9230 0122     sts   (v_Event_LFL) ,ZERO ;Idle
000679 9230 0124     sts   (v_Event_LFR) ,ZERO ;Idle
                   ;> Clear "LINE FRONT-L" and "LINE FRONT-R" event
                 
                     ;< Sets Y at the ROTATE MOVE LIST for current sector
00067b 2f09            mov   AL              ,rvIndxServo
                +
                +.if flg_ServoDir < 8
00067c fd60     +sbrc r_Flags , flg_ServoDir
                +.else 
                +sbrc r_FlagsH , flg_ServoDir & 0b111
                       mFlgSkipClr           flg_ServoDir  ; ---if set--+ ;1"+";0"-"
00067d 9502              swap  AL                          ;            |
00067e 7007            andi  AL              ,0b00000111   ; <----------+
                +
00067f e0fe     +ldi ZH , high ( ( ct_List_Sec ) )
000680 e8e0     +ldi ZL , low ( ( ct_List_Sec ) )
                       LDW   Z               ,(ct_List_Sec)
000681 0fe0            add   ZL              ,AL
000682 1df3            adc   ZH              ,ZERO
000683 0fee            lsl   ZL
000684 1fff            rol   ZH
000685 91c5            lpm   YL              ,z+
000686 91d4            lpm   YH              ,z
                     ;> Sets Y at the ROTATE MOVE LIST for current sector
                 
                   ;< Sets fCoverMonet on the "EndMov" event
000687 e200          ldi   AL              ,GetTaskID(fCoverMonet)
000688 9300 012c     sts   (v_Event_EndMov),AL
                   ;> Sets fCoverMonet on the "EndMov" event
00068a dbfd        rcall fMoveEX_Run ; Y = MoveList
                 
                 
                   ;< Sets Servo into the starting position
                +
                +.if flg_ServoDir < 8
00068b ff60     +sbrs r_Flags , flg_ServoDir
                +.else 
                +sbrs r_FlagsH , flg_ServoDir & 0b111
                     mFlgSkipSet   flg_ServoDir
00068c e797            ldi rvIndxServo     ,0x77
                +
                +.if flg_ServoDir < 8
00068d fd60     +sbrc r_Flags , flg_ServoDir
                +.else 
                +sbrc r_FlagsH , flg_ServoDir & 0b111
                     mFlgSkipClr   flg_ServoDir
00068e e090            ldi rvIndxServo     ,0x00
                   ;> Sets Servo into the starting position
                 
00068f 9508        ret
                 
                +
                +.equ SizeOf_fAdjustAtMonet = ( pc - fAdjustAtMonet )
                 ENDP fAdjustAtMonet
                 
                +
                +.equ fOutLine = ( pc )
                 PROC fOutLine
                   ;< Stop servo scan
                +
000690 e10b     +ldi AL , TP_fScanMonet - TaskProcs
000691 d2c6     +rcall krClrTimer
                +
                     mClrTimer    fScanMonet
                   ;> Stop servo scan
                 
000692 dc2f        rcall fDrvStop
                 
                   ;< Clear "LINE FRONT-L" and "LINE FRONT-R" event
000693 9230 0122     sts   (v_Event_LFL) ,ZERO ;Idle
000695 9230 0124     sts   (v_Event_LFR) ,ZERO ;Idle
                   ;> Clear "LINE FRONT-L" and "LINE FRONT-R" event
                 
                   ;< Find out line. Move list
                     ;< Lamp on the left
                +
                +
                +
                +.if flg_LS_LR < 8
000697 ff63     +sbrs r_Flags , flg_LS_LR
000698 c002     +rjmp L_fOutLine1
                +.else 
                +sbrs r_FlagsH , ( flg_LS_LR & 0b111 )
                       mIfFlgCLR flg_LS_LR,rjmp L_fOutLine1    ; 1 - Left; 0 - Right
                +
000699 e1dc     +ldi YH , high ( ( ct_OutLineMoveL << 1 ) )
00069a e7cc     +ldi YL , low ( ( ct_OutLineMoveL << 1 ) )
                          LDW   Y  ,(ct_OutLineMoveL<<1)
                     ;> Lamp on the left
                   L_fOutLine1:
                   
                     ;< Lamp on the right
                +
                +
                +
                +.if flg_LS_LR < 8
00069b fd63     +sbrc r_Flags , flg_LS_LR
00069c c002     +rjmp L_fOutLine2
                +.else 
                +sbrc r_FlagsH , flg_LS_LR & 0b111
                       mIfFlgSET flg_LS_LR,rjmp L_fOutLine2    ; 1 - Left; 0 - Right
                +
00069d e1dc     +ldi YH , high ( ( ct_OutLineMoveR << 1 ) )
00069e e6cc     +ldi YL , low ( ( ct_OutLineMoveR << 1 ) )
                          LDW   Y  ,(ct_OutLineMoveR<<1)
                     ;> Lamp on the right
                     L_fOutLine2:
                   ;> Find out line. Move list
                 
                   ;< Toggle the Lamp side
                +
00069f 930f     +push r16
                +.if flg_LS_LR < 8
0006a0 e008     +ldi r16 , 1 << flg_LS_LR
0006a1 2760     +eor r_Flags , r16
                +.else 
                +ldi r16 , 1 << ( flg_LS_LR & 0b111 )
0006a2 910f     +eor r_FlagsH , r16
                     mFlgCpl  flg_LS_LR    ; 1 - Left <=> 0 - Right
                   ;> Toggle the Lamp side
                 
                 
                   ;< Sets fSearchLampLR on the "EndMov" event
0006a3 e10f          ldi   AL              ,GetTaskID(fSearchLampLR)
0006a4 9300 012c     sts   (v_Event_EndMov),AL
                   ;> Sets fSearchLampLR on the "EndMov" event
0006a6 dbe1        rcall fMoveEX_Run ; Y = MoveList
                 
0006a7 9508        ret
                 
                +
                +.equ SizeOf_fOutLine = ( pc - fOutLine )
                 ENDP fOutLine
                 
                 
                +
                +.equ fChengeLampLR = ( pc )
                 PROC fChengeLampLR
                 ;  ;< Toggle the Lamp side
                 ;    mFlgCpl  flg_LS_LR    ; 1 - Left <=> 0 - Right
                 ;  ;> Toggle the Lamp side
                 ;  mSendTask fSearchLampLR
0006a8 9508        ret
                 
                +
                +.equ SizeOf_fChengeLampLR = ( pc - fChengeLampLR )
                 ENDP fChengeLampLR
                 
                +
                +.equ fSearchMove = ( pc )
                 PROC fSearchMove
                 
                +
0006a9 930f     +push AL
0006aa e10b     +ldi AL , TP_fScanMonet - TaskProcs
0006ab d264     +rcall krSendTask
0006ac 910f     +pop AL
                   mSendTask fScanMonet
                 
                 ;  ;< Отключим подсветку LCD
                 ;    rcall fLCDLightOff
                 ;  ;> Отключим подсветку LCD
                 
                   ;< Clear Lamp event
0006ad 9230 0128     sts (v_Event_Lamp),ZERO ;Idle
                   ;> Clear Lamp event
                 
                 
                   ;< Sets fAdjustAtMonet on the "Monet" event
                +
                +
                +.if flg_Monet < 8
                +cbr r_Flags , ( 1 << flg_Monet )
0006af 777f     +.else 
                +cbr r_FlagsH , 1 << ( flg_Monet & 0b111 )
                     mFlgClr flg_Monet
0006b0 e00f          ldi AL             ,GetTaskID(fAdjustAtMonet)
0006b1 9300 0129     sts (v_Event_Monet),AL
                   ;> Sets fAdjustAtMonet on the "Monet" event
                 
                   ;< Sets fOutLine on the "LINE FRONT-L" event
                +
                +
                +.if flg_LFL < 8
                +cbr r_Flags , ( 1 << flg_LFL )
0006b3 7f7e     +.else 
                +cbr r_FlagsH , 1 << ( flg_LFL & 0b111 )
                     mFlgClr flg_LFL
0006b4 e208          ldi AL           ,GetTaskID(fOutLine)
0006b5 9300 0122     sts (v_Event_LFL),AL
                   ;> Sets fOutLine on the "LINE FRONT-L" event
                 
                   ;< Sets fOutLine on the "LINE FRONT-R" event
                +
                +
                +.if flg_LFR < 8
                +cbr r_Flags , ( 1 << flg_LFR )
0006b7 7f7d     +.else 
                +cbr r_FlagsH , 1 << ( flg_LFR & 0b111 )
                     mFlgClr flg_LFR
                     ;ldi   AL           ,GetTaskID(fOutLine)
0006b8 9300 0124     sts (v_Event_LFR),AL
                   ;> Sets fOutLine on the "LINE FRONT-R" event
                 
                   ;< After "Search Move" Send Task "fScanMonet"
0006ba e10b          ldi AL              ,GetTaskID(fScanMonet)
0006bb 9300 012c     sts (v_Event_EndMov),AL
                   ;> After "Search Move" Send Task "fScanMonet"
                 
                   ;< Search move list
                +
0006bd e1dc     +ldi YH , high ( ( ct_SearchMove << 1 ) )
0006be e6c4     +ldi YL , low ( ( ct_SearchMove << 1 ) )
                     LDW   Y             ,(ct_SearchMove<<1)
0006bf dbc8          rcall fMoveEX_Run ; Y = MoveList
                   ;> Search move list
                 
                 
                 
0006c0 9508        ret
                +
                +.equ SizeOf_fSearchMove = ( pc - fSearchMove )
                 ENDP fSearchMove
                 
                +
                +.equ fScanMonet = ( pc )
                 PROC fScanMonet
                 
0006c1 2f09        mov   AL            ,rvIndxServo
0006c2 9502        swap  AL
0006c3 709f        andi  rvIndxServo   ,0b00001111
0006c4 7f00        andi  AL            ,0b11110000
                 
                   ;< Inc/Dec rvIndxServo
0006c5 9593        inc   rvIndxServo
                +
                +.if flg_ServoDir < 8
0006c6 ff60     +sbrs r_Flags , flg_ServoDir
                +.else 
                +sbrs r_FlagsH , flg_ServoDir & 0b111
                   mFlgSkipSet flg_ServoDir  ;--if set---+ ;0"+";1"-"
0006c7 5092          subi  rvIndxServo,2     ;           |
                                        ; <--------------+
                   ;> Inc/Dec rvIndxServo
0006c8 2f19        mov   AH            ,rvIndxServo
0006c9 7097        andi  rvIndxServo   ,0b00000111       ;1b
0006ca 2b90        or    rvIndxServo   ,AL
                 
0006cb 7018        andi  AH, 0b00001000
0006cc f069        breq LfScanMonet_Cont
                   ;< установить махало на начало движения
                +
                +.if flg_ServoDir < 8
0006cd ff60     +sbrs r_Flags , flg_ServoDir
                +.else 
                +sbrs r_FlagsH , flg_ServoDir & 0b111
                     mFlgSkipSet   flg_ServoDir
0006ce e090            ldi rvIndxServo     ,0x00
                +
                +.if flg_ServoDir < 8
0006cf fd60     +sbrc r_Flags , flg_ServoDir
                +.else 
                +sbrc r_FlagsH , flg_ServoDir & 0b111
                     mFlgSkipClr   flg_ServoDir
0006d0 e797            ldi rvIndxServo     ,0x77
                   ;> установить махало на начало движения
                +
0006d1 930f     +push r16
                +.if flg_ServoDir < 8
0006d2 e001     +ldi r16 , 1 << flg_ServoDir
0006d3 2760     +eor r_Flags , r16
                +.else 
                +ldi r16 , 1 << ( flg_ServoDir & 0b111 )
0006d4 910f     +eor r_FlagsH , r16
                   mFlgCpl flg_ServoDir                  ;4b
                +
                +.if 50 * 100 / 1000 > ( 1 << 16 ) || ( 50 * 100 / 1000 == 0 )
                +.error "Time out range!!!"
0006d5 e10c     +.else 
0006d6 e0a5     +ldi AL , TP_fSearchMove - TaskProcs
0006d7 e0b0     +ldi XL , low ( 50 * 100 / 1000 )
0006d8 d253     +ldi XH , high ( 50 * 100 / 1000 )
                +rcall krSetTimer
                   mSetTimerTask fSearchMove,50ms
0006d9 9508        ret
                  LfScanMonet_Cont:
                 
                +
                +.if 50 * 100 / 1000 > ( 1 << 16 ) || ( 50 * 100 / 1000 == 0 )
                +.error "Time out range!!!"
0006da e10b     +.else 
0006db e0a5     +ldi AL , TP_fScanMonet - TaskProcs
0006dc e0b0     +ldi XL , low ( 50 * 100 / 1000 )
0006dd d24e     +ldi XH , high ( 50 * 100 / 1000 )
                +rcall krSetTimer
                   mSetTimerTask fScanMonet,50ms
                 
0006de 9508        ret
                 
                +
                +.equ SizeOf_fScanMonet = ( pc - fScanMonet )
                 ENDP fScanMonet
                 
                +
                +.equ fRotate = ( pc )
                 PROC fRotate
                 
                 
                   ;< Включим подсветку LCD
0006df dc9f          rcall fLCDLightOn
                +
                +.if 150 * 100 / 1000 > ( 1 << 16 ) || ( 150 * 100 / 1000 == 0 )
                +.error "Time out range!!!"
0006e0 e20b     +.else 
0006e1 e0af     +ldi AL , TP_fLCDLightOff - TaskProcs
0006e2 e0b0     +ldi XL , low ( 150 * 100 / 1000 )
0006e3 d248     +ldi XH , high ( 150 * 100 / 1000 )
                +rcall krSetTimer
                     mSetTimerTask fLCDLightOff,150ms
                   ;> Включим подсветку LCD
                 
                 
                   ;< Clear the "Melody" event
0006e4 9230 012d     sts   (v_Event_Melody),ZERO
                   ;> Clear the "Melody' event
                 
                 
                   ;< Sets fSearchLampLR on the "EndMov" event
0006e6 e10f          ldi   AL              ,GetTaskID(fSearchLampLR)
0006e7 9300 012c     sts   (v_Event_EndMov),AL
                   ;> Sets fSearchLampLR on the "EndMov" event
                +
0006e9 e1dc     +ldi YH , high ( ( ct_Rotate << 1 ) )
0006ea e9c8     +ldi YL , low ( ( ct_Rotate << 1 ) )
                   LDW   Y               ,(ct_Rotate<<1)
0006eb db9c        rcall fMoveEX_Run ; Y = MoveList
                 
0006ec 9508        ret
                 
                +
                +.equ SizeOf_fRotate = ( pc - fRotate )
                 ENDP fRotate
                 
                +
                +.equ fRx_xxx = ( pc )
                 PROC fRx_xxx
                 
                +
                +.equ fRR_90 = ( pc )
                 CPROC fRR_90
                   ;<
                +
0006ed e1dc     +ldi YH , high ( ( ct_RR_90 << 1 ) )
0006ee e3c0     +ldi YL , low ( ( ct_RR_90 << 1 ) )
                   LDW   Y               ,(ct_RR_90<<1)
0006ef c008        rjmp fRx_xxx_com
                   ;>
                 
                +
                +.equ fRL_90 = ( pc )
                 CPROC fRL_90
                   ;<
                +
0006f0 e1dc     +ldi YH , high ( ( ct_RL_90 << 1 ) )
0006f1 e3c8     +ldi YL , low ( ( ct_RL_90 << 1 ) )
                   LDW   Y               ,(ct_RL_90<<1)
0006f2 c005        rjmp fRx_xxx_com
                   ;>
                 
                +
                +.equ fRR_360_2 = ( pc )
                 CPROC fRR_360_2
                   ;<
                +
0006f3 e1dc     +ldi YH , high ( ( ct_RR_360_2 << 1 ) )
0006f4 e5c0     +ldi YL , low ( ( ct_RR_360_2 << 1 ) )
                   LDW   Y               ,(ct_RR_360_2<<1)
                 
                   ;< Clear "EndMov" event
0006f5 9230 012c     sts   (v_Event_EndMov),ZERO ;Idle
                   ;> Clear "EndMov" event
                 
0006f7 c000        rjmp fRx_xxx_com
                   ;>
                 
                +
                +.equ fRx_xxx_com = ( pc )
                 CPROC fRx_xxx_com
                 
                   ;< Clear LINE FRONT-L and "LINE FRONT-R" event
0006f8 9230 0122     sts   (v_Event_LFL) ,ZERO ;Idle
0006fa 9230 0124     sts   (v_Event_LFR) ,ZERO ;Idle
                   ;> Clear LINE FRONT-L and "LINE FRONT-R" event
                 
0006fc db8b        rcall fMoveEX_Run ; Y = MoveList
                 
                 
0006fd 9508        ret
                 
                +
                +.equ SizeOf_fRx_xxx = ( pc - fRx_xxx )
                 ENDP fRx_xxx
                 
                +
                +.equ fSearch_Finish = ( pc )
                 PROC fSearch_Finish
                   ;< Stop servo scan
                +
0006fe e10b     +ldi AL , TP_fScanMonet - TaskProcs
0006ff d258     +rcall krClrTimer
                +
                     mClrTimer    fScanMonet
                   ;> Stop servo scan
                 
                   ;< Clear "LINE FRONT-L" and "LINE FRONT-R" event
000700 9230 0122     sts   (v_Event_LFL) ,ZERO ;Idle
000702 9230 0124     sts   (v_Event_LFR) ,ZERO ;Idle
                   ;> Clear "LINE FRONT-L" and "LINE FRONT-R" event
                 
                   ;< Clear "Monet" event
000704 9230 0129     sts   (v_Event_Monet),ZERO ;Idle
                   ;> Clear "Monet" event
                 
                 
                   ;< установить махало в середину
000706 e098          ldi   rvIndxServo,8
                   ;> установить махало в середину
                 
                   ;< Sets fGo_Finish on the "Lamp" event
000707 e10a          ldi AL    ,GetTaskID(fGo_Finish)
000708 e016          ldi AH    ,GetEventID(v_Event,Lamp)
000709 de63          rcall fSendEvent
                   ;> Sets fGo_Finish on the "Lamp" event
                 
                 
                 
                   ;< Sets fSearch_Finish on the "EndMov" event
00070a e109          ldi   AL              ,GetTaskID(fSearch_Finish)
00070b 9300 012c     sts   (v_Event_EndMov),AL
                   ;> Sets fSearch_Finish on the "EndMov" event
                +
00070d e1dc     +ldi YH , high ( ( ct_SearchFinishMove << 1 ) )
00070e e5c8     +ldi YL , low ( ( ct_SearchFinishMove << 1 ) )
                   LDW   Y                 ,(ct_SearchFinishMove<<1)
00070f db78        rcall fMoveEX_Run ; Y = MoveList
                   
000710 9508        ret
                 
                +
                +.equ SizeOf_fSearch_Finish = ( pc - fSearch_Finish )
                 ENDP fSearch_Finish
                 
                +
                +.equ fGo_Finish = ( pc )
                 PROC fGo_Finish
                   ;< Clear "EndMov" event
000711 9230 012c     sts   (v_Event_EndMov),ZERO ;Idle
                   ;> Clear "EndMov" event
                 
000713 dbae       rcall  fDrvStop
                 
                   ;< Clear "Lamp" event
000714 9230 0128     sts   (v_Event_Lamp),ZERO ;Idle
                   ;> Clear "Lamp" event
                 
                   ;< Clear "StepL" event
000716 9230 012a     sts   (v_Event_StepL),ZERO ;Idle
000718 9230 012b     sts   (v_Event_StepR),ZERO ;Idle
                   ;> Clear "StepL" event
                 
00071a e787        ldi rvSpeedLR ,0x77
                 
                   ;< Sets fDrvStopAtFinish_L on the "LINE FRONT-L" event
00071b e203          ldi AL           ,GetTaskID(fDrvStopAtFinish_L)
00071c 9300 0122     sts (v_Event_LFL),AL
                   ;> Sets fDrvStopAtFinish_L on the "LINE FRONT-L" event
                 
                   ;< Sets fDrvStopAtFinish_R on the "LINE FRONT-R" event
00071e e204          ldi AL           ,GetTaskID(fDrvStopAtFinish_R)
00071f 9300 0124     sts (v_Event_LFR),AL
                   ;> Sets fDrvStopAtFinish_R on the "LINE FRONT-R" event
                 
000721 9508        ret
                 
                +
                +.equ SizeOf_fGo_Finish = ( pc - fGo_Finish )
                 ENDP fGo_Finish
                 
                +
                +.equ fDrvStopAtFinish_L = ( pc )
                 PROC fDrvStopAtFinish_L
000722 708f        andi  rvSpeedLR,0x0F
                   ;< Sets fFinish on the "LINE FRONT-R" event
000723 e103          ldi AL           ,GetTaskID(fFinish)
000724 9300 0124     sts (v_Event_LFR),AL
                   ;> Sets fFinish on the "LINE FRONT-R" event
                 
                   ;< Clear "LINE FRONT-L" event
000726 9230 0122     sts   (v_Event_LFL) ,ZERO ;Idle
                   ;> Clear "LINE FRONT-L" event
                 
000728 9508        ret
                +
                +.equ SizeOf_fDrvStopAtFinish_L = ( pc - fDrvStopAtFinish_L )
                 ENDP fDrvStopAtFinish_L
                 
                +
                +.equ fDrvStopAtFinish_R = ( pc )
                 PROC fDrvStopAtFinish_R
000729 7f80        andi  rvSpeedLR,0xF0
                   ;< Sets fFinish on the "LINE FRONT-L" event
00072a e103          ldi AL           ,GetTaskID(fFinish)
00072b 9300 0122     sts (v_Event_LFL),AL
                   ;> Sets fFinish on the "LINE FRONT-L" event
                 
                   ;< Clear "LINE FRONT-R" event
00072d 9230 0124     sts   (v_Event_LFR) ,ZERO ;Idle
                   ;> Clear "LINE FRONT-R" event
00072f 9508        ret
                +
                +.equ SizeOf_fDrvStopAtFinish_R = ( pc - fDrvStopAtFinish_R )
                 ENDP fDrvStopAtFinish_R
                 
                +
                +.equ fFinish = ( pc )
                 PROC fFinish
                +
000730 930f     +push AL
000731 e100     +ldi AL , TP_fDrvStop - TaskProcs
000732 d1dd     +rcall krSendTask
000733 910f     +pop AL
                   mSendTask fDrvStop
                +
000734 e00a     +ldi AL , TP_fShowSensorsState - TaskProcs
000735 d222     +rcall krClrTimer
                +
                   mClrTimer fShowSensorsState
                +
000736 e001     +ldi AL , TP_f1sec - TaskProcs
000737 d220     +rcall krClrTimer
                +
                   mClrTimer f1sec
                 
                 	;< Отображаем время тестирования на LCD
                +
000738 e0d1     +ldi YH , high ( ( v_LCDBuf ) )
000739 e9c0     +ldi YL , low ( ( v_LCDBuf ) )
                 	LDW		Y,	(v_LCDBuf)
00073a dca5      	rcall fRTC2Str	;
                 	;> Отображаем время тестирования на LCD
                 
                   ;< Clear LINE FRONT-L and "LINE FRONT-R" event
00073b 9230 0122     sts   (v_Event_LFL) ,ZERO ;Idle
00073d 9230 0124     sts   (v_Event_LFR) ,ZERO ;Idle
                   ;> Clear LINE FRONT-L and "LINE FRONT-R" event
                 
                +
                +.if 20 * 100 > ( 1 << 16 ) || ( 20 * 100 == 0 )
                +.error "Time out range!!!"
00073f e002     +.else 
000740 eda0     +ldi AL , TP_fReklama - TaskProcs
000741 e0b7     +ldi XL , low ( 20 * 100 )
000742 d1e9     +ldi XH , high ( 20 * 100 )
                +rcall krSetTimer
                   mSetTimerTask fReklama,20s
                 
                   ;< Clear "Melody" event
000743 9230 012d     sts   (v_Event_Melody) ,ZERO ;Idle
                   ;> Clear "Melody" event
                 
000745 d2a4        rcall fMelodyFinish
                 
000746 9508        ret
                 
                +
                +.equ SizeOf_fFinish = ( pc - fFinish )
                 ENDP fFinish
                 
                 
                +
                +.equ fSetLineFlg = ( pc )
                 PROC fSetLineFlg
                +
                +
                +.if flg_ADC < 8
000747 7f6b     +cbr r_Flags , ( 1 << flg_ADC )
                +.else 
                +cbr r_FlagsH , 1 << ( flg_ADC & 0b111 )
                   mFlgClr flg_ADC
                 
000748 9100 0180   lds AL,           (v_ADC+0)
00074a 9300 0116   sts (v_GNDCur+0), AL
00074c 9100 0181   lds AL,           (v_ADC+1)
00074e 9300 0117   sts (v_GNDCur+1), AL
000750 9100 0182   lds AL,           (v_ADC+2)
000752 9300 0118   sts (v_GNDCur+2), AL
000754 9100 0183   lds AL,           (v_ADC+3)
000756 9300 0119   sts (v_GNDCur+3), AL
                  L_fSetSensorFlg:
                   ;< LINE SET_SENSOR_FLGAG
                +
000758 e0d1     +ldi YH , high ( ( v_GND ) )
000759 e1c6     +ldi YL , low ( ( v_GND ) )
                   LDW   Y,  (v_GND) ; Load addr struct v_GND
                 
                   ;< LINE FRONT-R
00075a 8118        ldd AH, y+SOI(v_GND,Cur)
                 
00075b 810c        ldd AL, y+SOI(v_GND,Min)
00075c 1710        cp  AH, AL
00075d f408        brsh (pc+1)+1
                +
                +
                +.if flg_LFR < 8
                +ori r_Flags , 1 << flg_LFR
00075e 6072     +.else 
                +ori r_FlagsH , 1 << ( flg_LFR & 0b111 )
                     mFlgSet flg_LFR     ; LINE FRONT-R
                 
00075f 8508        ldd AL, y+SOI(v_GND,Max)
000760 1701        cp  AL, AH
000761 f408        brsh (pc+1)+1
                +
                +
                +.if flg_LFR < 8
                +ori r_Flags , 1 << flg_LFR
000762 6072     +.else 
                +ori r_FlagsH , 1 << ( flg_LFR & 0b111 )
                     mFlgSet flg_LFR     ; LINE FRONT-R
                   ;> LINE FRONT-R
                 
000763 9621        adiw  YL,1
                 
                   ;< LINE FRONT-L
000764 8118        ldd AH, y+SOI(v_GND,Cur)
                 
000765 810c        ldd AL, y+SOI(v_GND,Min)
000766 1710        cp  AH, AL
000767 f408        brsh (pc+1)+1
                +
                +
                +.if flg_LFL < 8
                +ori r_Flags , 1 << flg_LFL
000768 6071     +.else 
                +ori r_FlagsH , 1 << ( flg_LFL & 0b111 )
                     mFlgSet flg_LFL     ; LINE FRONT-L
                 
000769 8508        ldd AL, y+SOI(v_GND,Max)
00076a 1701        cp  AL, AH
00076b f408        brsh (pc+1)+1
                +
                +
                +.if flg_LFL < 8
                +ori r_Flags , 1 << flg_LFL
00076c 6071     +.else 
                +ori r_FlagsH , 1 << ( flg_LFL & 0b111 )
                     mFlgSet flg_LFL     ; LINE FRONT-L
                   ;> LINE FRONT-L
                 
00076d 9621        adiw  YL,1
                 
                   ;< LINE REAR-R
00076e 8118        ldd AH, y+SOI(v_GND,Cur)
                 
00076f 810c        ldd AL, y+SOI(v_GND,Min)
000770 1710        cp  AH, AL
000771 f408        brsh (pc+1)+1
                +
                +
                +.if flg_LRR < 8
                +ori r_Flags , 1 << flg_LRR
000772 6078     +.else 
                +ori r_FlagsH , 1 << ( flg_LRR & 0b111 )
                     mFlgSet flg_LRR     ; LINE REAR-R
                 
000773 8508        ldd AL, y+SOI(v_GND,Max)
000774 1701        cp  AL, AH
000775 f408        brsh (pc+1)+1
                +
                +
                +.if flg_LRR < 8
                +ori r_Flags , 1 << flg_LRR
000776 6078     +.else 
                +ori r_FlagsH , 1 << ( flg_LRR & 0b111 )
                     mFlgSet flg_LRR     ; LINE REAR-R
                   ;> LINE REAR-R
                 
000777 9621        adiw  YL,1
                 
                   ;< LINE REAR-L
000778 8118        ldd AH, y+SOI(v_GND,Cur)
                 
000779 810c        ldd AL, y+SOI(v_GND,Min)
00077a 1710        cp  AH, AL
00077b f408        brsh (pc+1)+1
                +
                +
                +.if flg_LRL < 8
                +ori r_Flags , 1 << flg_LRL
00077c 6074     +.else 
                +ori r_FlagsH , 1 << ( flg_LRL & 0b111 )
                     mFlgSet flg_LRL     ; LINE REAR-L
                 
00077d 8508        ldd AL, y+SOI(v_GND,Max)
00077e 1701        cp  AL, AH
00077f f408        brsh (pc+1)+1
                +
                +
                +.if flg_LRL < 8
                +ori r_Flags , 1 << flg_LRL
000780 6074     +.else 
                +ori r_FlagsH , 1 << ( flg_LRL & 0b111 )
                     mFlgSet flg_LRL     ; LINE REAR-L
                   ;> LINE REAR-L
                 
                   ;> LINE SET_SENSOR_FLGAG
                 
000781 d4af        rcall fPrintLineInfo
                 
000782 9508        ret
                 
                +
                +.equ SizeOf_fSetLineFlg = ( pc - fSetLineFlg )
                 ENDP fSetLineFlg
                 
                +
                +.equ fRefreshLCD = ( pc )
                 PROC fRefreshLCD
000783 dbe3        rcall fLCDPrint
                +
                +.if 290 * 100 / 1000 > ( 1 << 16 ) || ( 290 * 100 / 1000 == 0 )
                +.error "Time out range!!!"
000784 e00c     +.else 
000785 e1ad     +ldi AL , TP_fRefreshLCD - TaskProcs
000786 e0b0     +ldi XL , low ( 290 * 100 / 1000 )
000787 d1a4     +ldi XH , high ( 290 * 100 / 1000 )
                +rcall krSetTimer
                   mSetTimerTask fRefreshLCD,290ms
000788 9508        ret
                +
                +.equ SizeOf_fRefreshLCD = ( pc - fRefreshLCD )
                 ENDP fRefreshLCD
                 
                 ;< fGND..oOo..
                 ;###############################################################################
                +
                +.equ fGNDInit = ( pc )
                 PROC fGNDInit
000789 d9ee        rcall fADCInit
00078a ef0f        ser   AL
00078b 9300 011a   sts   (v_GNDMin+0), AL
00078d 9300 011b   sts   (v_GNDMin+1), AL
00078f 9300 011c   sts   (v_GNDMin+2), AL
000791 9300 011d   sts   (v_GNDMin+3), AL
000793 2700        clr   AL
000794 9300 011e   sts   (v_GNDMax+0), AL
000796 9300 011f   sts   (v_GNDMax+1), AL
000798 9300 0120   sts   (v_GNDMax+2), AL
00079a 9300 0121   sts   (v_GNDMax+3), AL
00079c 9508        ret
                 
                +
                +.equ SizeOf_fGNDInit = ( pc - fGNDInit )
                 ENDP fGNDInit
                 
                +
                +.equ fGNDDetect = ( pc )
                 PROC fGNDDetect
                 
00079d 930f        push  AL
                 
                +
00079e e206     +ldi AL , TP_fInitAllSensor - TaskProcs
00079f d1b8     +rcall krClrTimer
                +
                   mClrTimer fInitAllSensor
                 
                 
                 
                +
0007a0 e1fc     +ldi ZH , high ( ( ctGNDMoveList << 1 ) )
0007a1 ece0     +ldi ZL , low ( ( ctGNDMoveList << 1 ) )
                   LDW   Z               ,(ctGNDMoveList<<1)
0007a2 93e0 0114   sts   (v_fptrSpeed+0) ,ZL
0007a4 93f0 0115   sts   (v_fptrSpeed+1) ,ZH
                 
0007a6 dfe2        rcall fGNDInit
0007a7 d002        rcall fGNDGetMidLevel
0007a8 910f        pop   AL
0007a9 9508        ret
                 
                +
                +.equ SizeOf_fGNDDetect = ( pc - fGNDDetect )
                 ENDP fGNDDetect
                 
                +
                +.equ fGNDGetMidLevel = ( pc )
                 PROC fGNDGetMidLevel
0007aa 91e0 0114   lds   ZL      ,(v_fptrSpeed+0)
0007ac 91f0 0115   lds   ZH      ,(v_fptrSpeed+1)
0007ae 9185        lpm rvSpeedLR ,z+
0007af 2388        tst rvSpeedLR
0007b0 f481        brne L_fGNDGML
                 
0007b1 9493          inc rvInitFlag
                 
                +
0007b2 e006     +ldi AL , TP_fGNDMinMax - TaskProcs
0007b3 d1a4     +rcall krClrTimer
                +
                     mClrTimer fGNDMinMax
                 
0007b4 d033          rcall fGNDCalcMid
0007b5 de85          rcall fSaveGNDSensorLevel
                 
                +
0007b6 e1fe     +ldi ZH , high ( ( sz_Init_GND_OK << 1 ) )
0007b7 e4e6     +ldi ZL , low ( ( sz_Init_GND_OK << 1 ) )
                     LDW   Z   ,(sz_Init_GND_OK<<1)
                +
0007b8 e0d1     +ldi YH , high ( ( v_LCDBuf ) )
0007b9 e9c0     +ldi YL , low ( ( v_LCDBuf ) )
                     LDW   Y   ,(v_LCDBuf)
0007ba e100          ldi   AL  ,LCDBUFFSIZE
0007bb d1c7          rcall krMemCopyF2R
                +
                +.if 3 * 100 > ( 1 << 16 ) || ( 3 * 100 == 0 )
                +.error "Time out range!!!"
0007bc e206     +.else 
0007bd e2ac     +ldi AL , TP_fInitAllSensor - TaskProcs
0007be e0b1     +ldi XL , low ( 3 * 100 )
0007bf d16c     +ldi XH , high ( 3 * 100 )
                +rcall krSetTimer
                     mSetTimerTask fInitAllSensor,3s
                 
                 
0007c0 9508          ret
                  L_fGNDGML:
0007c1 93e0 0114   sts   (v_fptrSpeed+0),ZL
0007c3 93f0 0115   sts   (v_fptrSpeed+1),ZH
                +
                +.if 1000 * 100 / 1000 > ( 1 << 16 ) || ( 1000 * 100 / 1000 == 0 )
                +.error "Time out range!!!"
0007c5 e007     +.else 
0007c6 e6a4     +ldi AL , TP_fGNDGetMidLevel - TaskProcs
0007c7 e0b0     +ldi XL , low ( 1000 * 100 / 1000 )
0007c8 d163     +ldi XH , high ( 1000 * 100 / 1000 )
                +rcall krSetTimer
                   mSetTimerTask fGNDGetMidLevel,1000ms
                +
0007c9 930f     +push AL
0007ca e006     +ldi AL , TP_fGNDMinMax - TaskProcs
0007cb d144     +rcall krSendTask
0007cc 910f     +pop AL
                   mSendTask fGNDMinMax
0007cd 9508        ret
                 
                 
                +
                +.equ SizeOf_fGNDGetMidLevel = ( pc - fGNDGetMidLevel )
                 ENDP fGNDGetMidLevel
                 
                 
                 
                +
                +.equ fGNDMinMax = ( pc )
                 PROC fGNDMinMax
                 #define   rTmp CL
                 
                +
                +.if flg_ADC < 8
0007ce ff62     +sbrs r_Flags , flg_ADC
0007cf c013     +rjmp L_fGNDMinMax_ret
                +.else 
                +sbrs r_FlagsH , flg_ADC & 0b111
                   mJmpIfCLR flg_ADC,L_fGNDMinMax_ret ;Converting complete. For all ADC canals
                +
                +
                +.if flg_ADC < 8
0007d0 7f6b     +cbr r_Flags , ( 1 << flg_ADC )
                +.else 
                +cbr r_FlagsH , 1 << ( flg_ADC & 0b111 )
                   mFlgClr flg_ADC
                +
0007d1 e0b1     +ldi XH , high ( ( v_ADC ) )
0007d2 e8a0     +ldi XL , low ( ( v_ADC ) )
                   LDW   X   ,(v_ADC)
                +
0007d3 e0d1     +ldi YH , high ( ( v_GND ) )
0007d4 e1c6     +ldi YL , low ( ( v_GND ) )
                   LDW   Y   ,(v_GND)
                 
0007d5 e044        ldi   rTmp, 4
                  L_fGNDMinMax:
0007d6 910d          ld  AL, x+
                 
                     ;< Find Min
0007d7 811c          ldd AH, y+(v_GNDMin-v_GND)
0007d8 1701          cp  AL, AH
0007d9 f408          brsh (pc+1)+1
0007da 830c            std y+(v_GNDMin-v_GND), AL
                     ;> Find Min
                 
                     ;< Find Max
0007db 8518          ldd AH, y+(v_GNDMax-v_GND)
0007dc 1701          cp  AL, AH
0007dd f008          brlo (pc+1)+1
0007de 8708            std y+(v_GNDMax-v_GND), AL
                     ;> Find Max
                 
0007df 9621          adiw  YL,1
                 
0007e0 954a          dec   rTmp
0007e1 f7a1        brne L_fGNDMinMax
                 
0007e2 d08e        rcall fInfoGNDMinMax
                 
                  L_fGNDMinMax_ret:
                 
                +
                +.if 30 * 100 / 1000 > ( 1 << 16 ) || ( 30 * 100 / 1000 == 0 )
                +.error "Time out range!!!"
0007e3 e006     +.else 
0007e4 e0a3     +ldi AL , TP_fGNDMinMax - TaskProcs
0007e5 e0b0     +ldi XL , low ( 30 * 100 / 1000 )
0007e6 d145     +ldi XH , high ( 30 * 100 / 1000 )
                +rcall krSetTimer
                   mSetTimerTask fGNDMinMax, 30ms
0007e7 9508        ret
                 #undef rTmp
                +
                +.equ SizeOf_fGNDMinMax = ( pc - fGNDMinMax )
                 ENDP fGNDMinMax
                 
                +
                +.equ fGNDCalcMid = ( pc )
                 PROC fGNDCalcMid
                  #define    rTmp CL
                 
                +
0007e8 e0d1     +ldi YH , high ( v_GND )
0007e9 e1c6     +ldi YL , low ( v_GND )
                   LDW   Y,  v_GND ; Load addr struct v_GND
                 
0007ea e044        ldi   rTmp, 4
                  L_fGNDCalcMid:
                     ; MaxLevel = (v_GNDMax - v_GNDMin)/8 + v_GNDMax + 1
                     ; MinLevel = v_GNDMin - (v_GNDMax - v_GNDMin)/8 - 1
                     ; MinLevel = if( MaxLevel<0, 0, MinLevel )
                     ; MaxLevel = if( MaxLevel>255, 255, MaxLevel )
                 
                 ;<  -----------Точность позиционирования-----------------------
0007eb 810c          ldd AL, y+SOI(v_GND,Min)
0007ec 8518          ldd AH, y+SOI(v_GND,Max)
0007ed 0f10          add AH, AL                ;(v_GNDMax - v_GNDMin)
0007ee 9517          ror AH                    ;(v_GNDMax + v_GNDMin)/2
0007ef 9516          lsr AH                    ;(v_GNDMax + v_GNDMin)/2/2-->50%
0007f0 9516          lsr AH                    ;(v_GNDMax + v_GNDMin)/2/4-->25%
                 ;   lsr AH                    ;(v_GNDMax + v_GNDMin)/2/8-->12,5%
                 ;>  -----------Точность позиционирования-----------------------
                 
                 
0007f1 1b01          sub   AL, AH
0007f2 f408          brcc (pc+1)+1
0007f3 2700            clr AL
0007f4 5001          subi  AL, 1
0007f5 f408          brcc (pc+1)+1
0007f6 2700            clr AL
0007f7 830c          std y+SOI(v_GND,Min), AL
                 
0007f8 8508          ldd AL, y+SOI(v_GND,Max)
0007f9 0f01          add AL, AH
0007fa f408          brcc (pc+1)+1
0007fb ef0f            ser AL
0007fc 5f0f          subi  AL, (-1)
0007fd f008          brcs (pc+1)+1   ;Inverse CARRY logic
0007fe ef0f            ser AL
0007ff 8708          std y+SOI(v_GND,Max), AL
                 
000800 9621          adiw  YL,1
                 
000801 954a          dec   rTmp
000802 f741        brne L_fGNDCalcMid
000803 9508        ret
                  #undef rTmp
                 
                +
                +.equ SizeOf_fGNDCalcMid = ( pc - fGNDCalcMid )
                 ENDP fGNDCalcMid
                 
                 ;###############################################################################
                 ;> fGND..oOo..
                 
                 ;###############################################################################
                 
                 ;< fLS..oOo..
                +
                +.equ fLSInit = ( pc )
                 PROC fLSInit
                +
                +.if ( P_LightS - 1 ) > ( 0x3f )
                +push r16
000804 988b     +lds r16 , P_LightS - 1
                +cbr r16 , ( 1 << LightS )
                   mPinIn  LightS
                +
                +.if P_LightS > ( 0x3f )
                +push r16
000805 9893     +push r17
                +in r17 , SREG
                   mPinCLR LightS
                 
                +
000806 930f     +push r16
                +.if INT3 > 4
                +mIn r16 , EICRB
                +
                +.if EICRA > ( 0x3f )
000807 9100 006a+lds r16 , EICRA
                +.else 
                +in r16 , EICRA
                +cbr r16 , ( EXTRIS ) << ( ( INT3 & 0b11 ) * 2 )
                +ori r16 , ( EXTRIS ) << ( ( INT3 & 0b11 ) * 2 )
                +mOut EICRB , r16
                +.else 
000809 730f     +mIn r16 , EICRA
00080a 6c00     +
                +
                +.if EICRA > ( 0x3f )
00080b 9300 006a+sts EICRA , r16
                +.else 
                +out EICRA , r16
                +
                +
                +
                +.if EIMSK > ( 0x3f )
                +lds r16 , EIMSK
00080d b709     +.else 
                +in r16 , EIMSK
                +cbr r16 , ( EXTRIS ) << ( ( INT3 & 0b11 ) * 2 )
00080e 6008     +ori r16 , ( EXTRIS ) << ( ( INT3 & 0b11 ) * 2 )
                +
                +.if EIMSK > ( 0x3f )
                +sts EIMSK , r16
00080f bf09     +.else 
                +out EIMSK , r16
                +mOut EICRA , r16
000810 910f     +.endif 
                   mExtIntType INT3,(EXTRIS)
                +
                +
                +.if flg_Lamp < 8
                +cbr r_Flags , ( 1 << flg_Lamp )
000811 7b7f     +.else 
                +cbr r_FlagsH , 1 << ( flg_Lamp & 0b111 )
                   mFlgClr flg_Lamp
000812 9508        ret
                 ;< Interrupt
                   .set  OldPC = pc
                   .org  INT3addr  ;
000008 c062          rjmp INT_3 ;
                   .org  OldPC
                 ;> Interrupt
                 
                +
                +.equ SizeOf_fLSInit = ( pc - fLSInit )
                 ENDP fLSInit
                 
                 ;> fLS..oOo..
                 
                 ;###############################################################################
                 
                 
                 ;###############################################################################
                 
                 ;< fBamp..oOo..
                +
                +.equ fBampState = ( pc )
                 PROC fBampState
                +
000813 930f     +push r16
                +.if ( P_TSOPF - 2 ) > ( 0x3f )
                +lds r16 , P_TSOPF - 2
000814 b101     +.else 
                +in r16 , P_TSOPF - 2
000815 fb05     +.endif 
000816 910f     +bst r16 , TSOPF
                   mPinState TSOPF
                +
                +.if flg_BampF < 8
                +bld r_Flags , flg_BampF
000817 f974     +.else 
                +bld r_FlagsH , flg_BampF & 0b111
                   mFlgLd    flg_BampF
                 ; mPinCpl   BampDir
                 
000818 9508        ret
                +
                +.equ SizeOf_fBampState = ( pc - fBampState )
                 ENDP fBampState
                 
                +
                +.equ fBampInit = ( pc )
                 PROC fBampInit
                +
                +.if ( P_TSOPF - 1 ) > ( 0x3f )
                +push r16
000819 9815     +lds r16 , P_TSOPF - 1
                +cbr r16 , ( 1 << TSOPF )
                   mPinIn  TSOPF ; от датчика переднего бампера  ;INT5
                +
                +.if ( P_TSOPR - 1 ) > ( 0x3f )
                +push r16
00081a 9816     +lds r16 , P_TSOPR - 1
                +cbr r16 , ( 1 << TSOPR )
                   mPinIn  TSOPR ; от датчика заднего бампера  ;INT6(не используется)
                 
                +
                +.if P_TSOPF > ( 0x3f )
                +push r16
00081b 9a1d     +push r17
                +in r17 , SREG
                   mPinSET TSOPF ; от датчика переднего бампера  ;INT5
                +
                +.if P_TSOPR > ( 0x3f )
                +push r16
00081c 9a1e     +push r17
                +in r17 , SREG
                   mPinSET TSOPR ; от датчика заднего бампера  ;INT6(не используется)
                 
                 ; mExtIntType INT5,EXTANY ; BAMP F-TSOP
                 ; mExtIntType INT6,EXTFAL ; BAMP R-TSOP
                 
                   ;< Config T2 for TSOP4836
                +
                +
                +
                +.set F_Ovf = 36000 * 2
                +
                +.set F_Ovf = 36000 * 2
                +.set N_Cnt = 8
                +.set FnMin = 1
                +.set FnMax = ( 1 << N_Cnt ) - 1
                +
                +.set PreDivMin = Fclk / ( F_Ovf * FnMax )
                +.set PreDivMax = Fclk / ( F_Ovf * FnMin )
                +
                +
RTOSA\TimerCntrs.inc(170):  +--------------+
                +.message " +--------------+"
                +.if 2 == 0
                +.message " |PreDiv for TC0|"
RTOSA\TimerCntrs.inc(174):  |PreDiv for TC2|
                +.elif 2 == 2
                +.message " |PreDiv for TC2|"
                +.endif 
RTOSA\TimerCntrs.inc(177):  |   Div1       |
                +.if PreDivMin < 1
                +.message " |   Div1       |"
                +.set PreDiv = 1
                +.set DivMask = T2Div1
                +.elif ( PreDivMin < 8 ) && defined ( T2Div8 )
                +.message " |   Div8       |"
                +.set PreDiv = 8
                +.set DivMask = T2Div8
                +.elif ( PreDivMin < 32 ) && defined ( T2Div32 )
                +.message " |   Div32      |"
                +.set PreDiv = 32
RTOSA\TimerCntrs.inc(207): +--------------+
                +.set DivMask = T2Div32
                +.elif ( PreDivMin < 64 ) && defined ( T2Div64 )
                +.message " |   Div64      |"
                +.set PreDiv = 64
                +.set DivMask = T2Div64
                +.elif ( PreDivMin < 128 ) && defined ( T2Div128 )
                +.message " |   Div128     |"
                +.set PreDiv = 128
                +.set DivMask = T2Div128
                +.elif ( PreDivMin < 256 ) && defined ( T2Div256 )
                +.message " |   Div256     |"
                +.set PreDiv = 256
                +.set DivMask = T2Div256
                +.elif ( PreDivMin < 1024 ) && defined ( T2Div8 )
                +.message " |   Div1024    |"
                +.set PreDiv = 1024
                +.set DivMask = T2Div1024
                +.else 
                +.error "Timer not config"
                +.endif 
                +.message "+--------------+"
                +
                +
                +.set Fn = Fclk / ( PreDiv * F_Ovf )
                +
                +
                +
                +
                +
00081d e109     +
00081e bd05     +
00081f ed0e     +
000820 bd03     +
                +
                +
                +
                +
                +
                   mInitTC8bit 2,36000
                +
                +.if ( P_F0 - 1 ) > ( 0x3f )
                +push r16
000821 9abf     +lds r16 , P_F0 - 1
                +sbr r16 , ( 1 << F0 )
                   mPinOut F0
                   ;> Config T2 for TSOP4836
                 
                +
                +.if ( P_BampEN - 1 ) > ( 0x3f )
                +push r16
000822 9a8a     +lds r16 , P_BampEN - 1
                +sbr r16 , ( 1 << BampEN )
                   mPinOut BampEN
                +
                +.if P_BampEN > ( 0x3f )
                +push r16
000823 9a92     +push r17
                +in r17 , SREG
                   mPinSET BampEN
                 
                +
                +.if ( P_BampDir - 1 ) > ( 0x3f )
                +push r16
000824 9a12     +lds r16 , P_BampDir - 1
                +sbr r16 , ( 1 << BampDir )
                   mPinOut BampDir
                +
                +.if P_BampDir > ( 0x3f )
                +push r16
000825 9a1a     +push r17
                +in r17 , SREG
                   mPinSET BampDir
                 ; mPinCLR BampDir
                 
000826 9508        ret
                 ;< Interrupt
                   .set  OldPC = pc
                   .org  INT5addr  ;External Interrupt Request 5
00000c c0a8          rjmp INT_5
                   .org  INT6addr  ;External Interrupt Request 6
00000e c0cb          rjmp INT_6
                   .org  OldPC
                 ;> Interrupt
                 
                +
                +.equ SizeOf_fBampInit = ( pc - fBampInit )
                 ENDP fBampInit
                 ;> fBamp..oOo..
                 
                 ;###############################################################################
                 
                 ;< fInfo..oOo..
                 
                 ;;----------------+
                 ;    ;|01234567| ;|
                 ; .db "FLx  FRx" ;| max
                 ; .db "RLx  RRx" ;| min
                 ;;----------------+
                 
                +
                +.equ fInfoGND = ( pc )
                 PROC fInfoGND
                 
                +
000827 e0d1     +ldi YH , high ( ( v_LCDBuf ) )
000828 e9c0     +ldi YL , low ( ( v_LCDBuf ) )
                     LDW Y     ,(v_LCDBuf)
000829 9100 011f     lds AL    ,(v_GNDMaxFL)
00082b 2d13          mov AH    ,ZERO
00082c d399          rcall fw2a
                 
                +
00082d e0d1     +ldi YH , high ( ( v_LCDBuf2 ) )
00082e e9c8     +ldi YL , low ( ( v_LCDBuf2 ) )
                     LDW Y     ,(v_LCDBuf2)
00082f 9100 0121     lds AL    ,(v_GNDMaxRL)
000831 2d13          mov AH    ,ZERO
000832 d393          rcall fw2a
                 
                +
000833 e0d1     +ldi YH , high ( ( v_LCDBuf + 5 ) )
000834 e9c5     +ldi YL , low ( ( v_LCDBuf + 5 ) )
                     LDW Y     ,(v_LCDBuf+5)
000835 9100 011e     lds AL    ,(v_GNDMaxFR)
000837 2d13          mov AH    ,ZERO
000838 d38d          rcall fw2a
                 
                +
000839 e0d1     +ldi YH , high ( ( v_LCDBuf2 + 5 ) )
00083a e9cd     +ldi YL , low ( ( v_LCDBuf2 + 5 ) )
                     LDW Y     ,(v_LCDBuf2+5)
00083b 9100 0120     lds AL    ,(v_GNDMaxRR)
00083d 2d13          mov AH    ,ZERO
00083e d387          rcall fw2a
                 
00083f 9508        ret
                +
                +.equ SizeOf_fInfoGND = ( pc - fInfoGND )
                 ENDP fInfoGND
                 
                +
                +.equ fInfoMidLSFM = ( pc )
                 PROC fInfoMidLSFM
                 ;Вывод для отладки LS & FM
000840 d00f        rcall fInfoPrintLSFM
                 
                +
000841 e0d1     +ldi YH , high ( ( v_LCDBuf + 3 ) )
000842 e9c3     +ldi YL , low ( ( v_LCDBuf + 3 ) )
                   LDW Y   ,(v_LCDBuf+3)
000843 9100 010b   lds AL  ,(v_LSMidL)
000845 9110 010c   lds AH  ,(v_LSMidH)
000847 d37e        rcall fw2a
                 
                +
000848 e0d1     +ldi YH , high ( ( v_LCDBuf2 + 3 ) )
000849 e9cb     +ldi YL , low ( ( v_LCDBuf2 + 3 ) )
                   LDW Y   ,(v_LCDBuf2+3)
00084a 9100 0104   lds AL  ,(v_FMMidL)
00084c 9110 0105   lds AH  ,(v_FMMidH)
00084e d377        rcall fw2a
00084f 9508        ret
                +
                +.equ SizeOf_fInfoMidLSFM = ( pc - fInfoMidLSFM )
                 ENDP fInfoMidLSFM
                 
                +
                +.equ fInfoPrintLSFM = ( pc )
                 PROC fInfoPrintLSFM
                +
000850 e0d1     +ldi YH , high ( ( v_LCDBuf ) )
000851 e9c0     +ldi YL , low ( ( v_LCDBuf ) )
                   LDW Y   ,(v_LCDBuf)
000852 e40c        ldi AL  ,'L'
000853 9309        st  y+  ,AL
000854 e503        ldi AL  ,'S'
000855 9309        st  y+  ,AL
000856 e30a        ldi AL  ,':'
000857 9309        st  y+  ,AL
                +
000858 e0d1     +ldi YH , high ( ( v_LCDBuf2 ) )
000859 e9c8     +ldi YL , low ( ( v_LCDBuf2 ) )
                   LDW Y   ,(v_LCDBuf2)
00085a e406        ldi AL  ,'F'
00085b 9309        st  y+  ,AL
00085c e40d        ldi AL  ,'M'
00085d 9309        st  y+  ,AL
00085e e30a        ldi AL  ,':'
00085f 9309        st  y+  ,AL
                 
000860 9508        ret
                 
                +
                +.equ SizeOf_fInfoPrintLSFM = ( pc - fInfoPrintLSFM )
                 ENDP fInfoPrintLSFM
                 
                +
                +.equ fInfoCurLSFM = ( pc )
                 PROC fInfoCurLSFM
                 ;Вывод для отладки LS & FM
                 
000861 dfee        rcall fInfoPrintLSFM
                 
                +
000862 e0d1     +ldi YH , high ( ( v_LCDBuf + 3 ) )
000863 e9c3     +ldi YL , low ( ( v_LCDBuf + 3 ) )
                   LDW Y   ,(v_LCDBuf+3)
000864 9100 0107   lds AL  ,(v_LSCurL)
000866 9110 0108   lds AH  ,(v_LSCurH)
000868 d35d        rcall fw2a
                 
                +
000869 e0d1     +ldi YH , high ( ( v_LCDBuf2 + 3 ) )
00086a e9cb     +ldi YL , low ( ( v_LCDBuf2 + 3 ) )
                   LDW Y   ,(v_LCDBuf2+3)
00086b 9100 0100   lds AL  ,(v_FMCurL)
00086d 9110 0101   lds AH  ,(v_FMCurH)
00086f d356        rcall fw2a
000870 9508        ret
                +
                +.equ SizeOf_fInfoCurLSFM = ( pc - fInfoCurLSFM )
                 ENDP fInfoCurLSFM
                 
                 
                +
                +.equ fInfoGNDMinMax = ( pc )
                 PROC fInfoGNDMinMax
                 #define   rTmp CL
000871 934f        push  rTmp
                +
000872 e0b1     +ldi XH , high ( ( v_GNDMin ) )
000873 e1aa     +ldi XL , low ( ( v_GNDMin ) )
                   LDW   X,  (v_GNDMin)
                +
000874 e0d1     +ldi YH , high ( ( v_LCDBuf ) )
000875 e9c0     +ldi YL , low ( ( v_LCDBuf ) )
                   LDW   Y,  (v_LCDBuf)
                 
000876 e048        ldi   rTmp, 8
                  L_fInfoGNDMinMax:
000877 910d          ld    AL, x+
                 
000878 2f10          mov   AH, AL
000879 700f          cbr   AL, 0xF0
00087a 9512          swap  AH
00087b 701f          cbr   AH, 0xF0
                 
00087c 6300          ori   AL, '0'
00087d 6310          ori   AH, '0'
                 
00087e 330a          cpi   AL, '9'+1
00087f f008          brlo pc+1+1
000880 5f09            subi  AL, -7
000881 331a          cpi   AH, '9'+1
000882 f008          brlo pc+1+1
000883 5f19            subi  AH, -7
                 
000884 9319          st    y+, AH
000885 9309          st    y+, AL
000886 954a          dec   rTmp
000887 f779        brne L_fInfoGNDMinMax
000888 914f        pop rTmp
                 
                 #undef rTmp
                 ;;----------------+
                 ;    ;|01234567| ;|
                 ; .db "01020304" ;| min
                 ; .db "01020304" ;| max
                 ;;----------------+
000889 9508        ret
                 
                +
                +.equ SizeOf_fInfoGNDMinMax = ( pc - fInfoGNDMinMax )
                 ENDP fInfoGNDMinMax
                 
                +
                +.equ fInfoSets = ( pc )
                 PROC fInfoSets
                +
                +
00088a e0d1     +ldi YH , high ( ( v_LCDBuf ) )
00088b e9c0     +ldi YL , low ( ( v_LCDBuf ) )
                +LDW Y , ( v_LCDBuf )
00088c dae6     +rcall fLCDBuffCLR
                   mLCDBuffCLR (v_LCDBuf)
                +
                +.if flg_AnyKey < 8
00088d fd61     +sbrc r_Flags , flg_AnyKey
                +.else 
                +sbrc r_FlagsH , flg_AnyKey & 0b111
                   mFlgSkipClr flg_AnyKey
00088e dfb1          rcall fInfoMidLSFM
                +
                +.if flg_AnyKey < 8
00088f ff61     +sbrs r_Flags , flg_AnyKey
                +.else 
                +sbrs r_FlagsH , flg_AnyKey & 0b111
                   mFlgSkipSet flg_AnyKey
000890 dfe0          rcall fInfoGNDMinMax
                +
000891 930f     +push r16
                +.if flg_AnyKey < 8
000892 e002     +ldi r16 , 1 << flg_AnyKey
000893 2760     +eor r_Flags , r16
                +.else 
                +ldi r16 , 1 << ( flg_AnyKey & 0b111 )
000894 910f     +eor r_FlagsH , r16
                   mFlgCpl flg_AnyKey
                +
                +.if 2500 * 100 / 1000 > ( 1 << 16 ) || ( 2500 * 100 / 1000 == 0 )
                +.error "Time out range!!!"
000895 e202     +.else 
000896 efaa     +ldi AL , TP_fInfoSets - TaskProcs
000897 e0b0     +ldi XL , low ( 2500 * 100 / 1000 )
000898 d093     +ldi XH , high ( 2500 * 100 / 1000 )
                +rcall krSetTimer
                   mSetTimerTask fInfoSets,2500ms
000899 9508        ret
                +
                +.equ SizeOf_fInfoSets = ( pc - fInfoSets )
                 ENDP fInfoSets
                 
                 
                 ;> fInfo..oOo..
                 
                +
                +.equ fFM_Init = ( pc )
                 PROC fFM_Init
                 
                +
                +
                +
                +.if TCCR3A > ( 0x3f )
00089a 9100 008b+lds AL , TCCR3A
                +.else 
                +in AL , TCCR3A
                +mIn AL , TCCR3A
00089c 7000     +cbr AL , 0xff
00089d 6000     +ori AL , ( 0 & 0b0011 ) | 0
                +
                +
                +.if TCCR3B > ( 0x3f )
00089e 9110 008a+lds AH , TCCR3B
                +.else 
                +in AH , TCCR3B
                +mIn AH , TCCR3B
                +.if T3Div8 > 7
                +
0008a0 7e10     +cbr AH , ( 1 << WGM33 ) | ( 1 << WGM32 )
0008a1 6c12     +ori AH , ( ( 0 & 0b1100 ) << 1 )
                +.else 
                +cbr AH , ( 1 << WGM33 ) | ( 1 << WGM32 ) | ( 1 << CS32 ) | ( 1 << CS31 ) | ( 1 << CS30 )
                +
                +.if TCCR3A > ( 0x3f )
0008a2 9300 008b+sts TCCR3A , AL
                +.else 
                +out TCCR3A , AL
                +ori AH , ( ( 0 & 0b1100 ) << 1 ) | T3Div8 | ( 1 << ICNC3 ) | ( 1 << ICES3 )
                +
                +.if TCCR3B > ( 0x3f )
0008a4 9310 008a+sts TCCR3B , AH
                +.else 
                +out TCCR3B , AH
                +.endif 
                +
                   mT3SetMode 0,T3Div8,0
                 
                +
                +.if ETIMSK > ( 0x3f )
0008a6 9100 007d+lds AL , ETIMSK
                +.else 
                +in AL , ETIMSK
                   mIn   AL,     ETIMSK
0008a8 6200        ori   AL,     (1<<TICIE3)
                +
                +.if ETIMSK > ( 0x3f )
0008a9 9300 007d+sts ETIMSK , AL
                +.else 
                +out ETIMSK , AL
                   mOut  ETIMSK, AL
                 
                 
                 ;< Interrupt
                   .set  OldPC = pc
                   .org  ICP3addr  ; Timer/Counter3 Capture Event
000032 c0c4          rjmp INT_ICP3 ;Timer3 Capture Handler
                   .org  OldPC
                 ;> Interrupt
                 
0008ab 9508        ret
                 
                +
                +.equ SizeOf_fFM_Init = ( pc - fFM_Init )
                 ENDP fFM_Init
                 
                 
                 
                +
                +.equ fFMMinMax = ( pc )
                 PROC fFMMinMax
                 
                     ;< Find Min
0008ac 811c          ldd AH, y+(v_GNDMin-v_GND)
0008ad 1701          cp  AL, AH
0008ae f408          brsh (pc+1)+1
0008af 830c            std y+(v_GNDMin-v_GND), AL
                     ;> Find Min
                 
                     ;< Find Max
0008b0 8518          ldd AH, y+(v_GNDMax-v_GND)
0008b1 1701          cp  AL, AH
0008b2 f008          brlo (pc+1)+1
0008b3 8708            std y+(v_GNDMax-v_GND), AL
                     ;> Find Max
                 
0008b4 9508        ret
                 
                +
                +.equ SizeOf_fFMMinMax = ( pc - fFMMinMax )
                 ENDP fFMMinMax
                 
                 
                 
                 
                +
                +.equ fReklama = ( pc )
                 PROC fReklama
                +
0008b5 e1fd     +ldi ZH , high ( ( ListRekPage << 1 ) )
0008b6 e2e6     +ldi ZL , low ( ( ListRekPage << 1 ) )
                   LDW Z,(ListRekPage<<1)
0008b7 d0d4        rcall krRand
0008b8 700f        andi  AL, 0b1111
0008b9 f409        brne pc+1+1
0008ba b672        in  r_RND,  TCNT0
0008bb 0f00        lsl   AL
0008bc 0fe0        add   ZL,   AL
0008bd 1df3        adc   ZH,   ZERO
0008be 9105        lpm   AL, z+
0008bf 91f4        lpm   ZH,   z
0008c0 2fe0        mov   ZL,   AL
0008c1 da8f        rcall fLCDPageZ
                +
                +.if 2000 * 100 / 1000 > ( 1 << 16 ) || ( 2000 * 100 / 1000 == 0 )
                +.error "Time out range!!!"
0008c2 e002     +.else 
0008c3 eca8     +ldi AL , TP_fReklama - TaskProcs
0008c4 e0b0     +ldi XL , low ( 2000 * 100 / 1000 )
0008c5 d066     +ldi XH , high ( 2000 * 100 / 1000 )
                +rcall krSetTimer
                   mSetTimerTask fReklama,TReklama
0008c6 9508        ret
                +
                +.equ SizeOf_fReklama = ( pc - fReklama )
                 ENDP fReklama
                 
                 ;--------------------------------------------------------------------------------
                 ;
                 .include  "EEPROM.ASM"
                 
                 .cseg
                 ;###############################################################################
                 ;###############################################################################
                 
                 ;###############################################################################
                 ;***************************************************************************
                 ;* 
                 ;* fEEWrite
                 ;*
                 ;* This subroutine waits until the EEPROM is ready to be programmed, then
                 ;* programs the EEPROM with register variable "EEdwr" at address "EEawr:EEawr"
                 ;*
                 ;* Number of words  :1200 ; 5 + return
                 ;*      :8515 ; 7 + return
                 ;* Number of cycles :1200 ; 8 + return (if EEPROM is ready)
                 ;*      :8515 ; 11 + return (if EEPROM is ready)
                 ;* Low Registers used :None
                 ;* High Registers used: ;3 (EEdwr,EEawr,EEawrh)
                 ;*
                 ;***************************************************************************
                 
                 ;***** Subroutine register variables
                 
                 #define EEdwr   AL    ;data byte to write to EEPROM
                 #define EEAddL  YL   ;address low byte to write to
                 #define EEAddH  YH   ;address high byte to write to
                 
                 ;***** Code
                +
                +.equ fEEWrite = ( pc )
                 PROC  fEEWrite
0008c7 99e1        sbic  EECR,   EEWE  ;if EEWE not clear
0008c8 cffe        rjmp  fEEWrite    ;    wait more
                 
                 ; out EEAR,EEawr  ;output address for 1200, commented out !
                 
                 ; the two following lines must be replaced with the line above if 1200 is used
0008c9 bbdf        out   EEARH,    EEAddH  ;output address high for 8515
0008ca bbce        out   EEARL,    EEAddL  ;output address low for 8515
                     
                 
0008cb bb0d        out   EEDR,   EEdwr ;output data
0008cc 9ae2        sbi   EECR,   EEMWE ;set master write enable, remove if 1200 is used  
0008cd 9ae1        sbi   EECR,   EEWE  ;set EEPROM Write strobe
                         ;This instruction takes 4 clock cycles since
                         ;it halts the CPU for two clock cycles
0008ce 9508        ret
                 #undef  EEdwr
                 #undef  EEAddrL 
                 #undef  EEAddrH
                +
                +.equ SizeOf_fEEWrite = ( pc - fEEWrite )
                 ENDP  fEEWrite
                 ;###############################################################################
                 ;###############################################################################
                 
                 ;###############################################################################
                 ;***************************************************************************
                 ;* 
                 ;* fEERead
                 ;*
                 ;* This subroutine waits until the EEPROM is ready to be programmed, then
                 ;* reads the register variable "EEdrd" from address "EEardh:EEard"
                 ;*
                 ;* Number of words  :1200 ; 5 + return
                 ;*      :8515 ; 6 + return
                 ;* Number of cycles :1200 ; 8 + return (if EEPROM is ready)
                 ;*      :8515 ; 9 + return (if EEPROM is ready)
                 ;* Low Registers used :1 (EEdrd)
                 ;* High Registers used: :2 (EEard,EEardh)
                 ;*
                 ;***************************************************************************
                 
                 ;***** Subroutine register variables
                 
                 #define EEdrd   AL    ;result data byte
                 #define EEAddL  YL   ;address low to read from
                 #define EEAddH  YH   ;address high to read from
                 
                 ;***** Code
                 
                +
                +.equ fEERead = ( pc )
                 PROC  fEERead
0008cf 99e1        sbic  EECR,   EEWE  ;if EEWE not clear
0008d0 cffe        rjmp  fEERead   ;    wait more
                 ; out EEAR,EEard  ;output address for 1200, commented out !
                 
                 ; the two following lines must be replaced with the line above if 1200 is used
0008d1 bbdf        out   EEARH,    EEAddH  ;output address high for 8515
0008d2 bbce        out   EEARL,    EEAddL  ;output address low for 8515
                 
                 
0008d3 9ae0        sbi   EECR,   EERE  ;set EEPROM Read strobe
                         ;This instruction takes 4 clock cycles since
                         ;it halts the CPU for two clock cycles
0008d4 b30d        in    EEdrd,    EEDR  ;get data
0008d5 9508        ret
                 #undef  EEdrd   
                 #undef  EEAddL 
                 #undef  EEAddH
                +
                +.equ SizeOf_fEERead = ( pc - fEERead )
                 ENDP  fEERead
                 ;###############################################################################
                 ;###############################################################################
                 
                 ;###############################################################################
                 
                 ;S_Alex & ATMEL
                 
                 .include  "RTOSA/RTOSA.asm" ;
                 
                 ;RTOSA Ver. 0.0.0.1 - Copyright (C) 2009-2011 S_Alex.
                 ;This file is part of the RTOSA distribution.
                 ; "2010-08-09" "19:24"
                 ;Updated: "2010-09-09" "23:32"
                 ;Updated: "2011-03-22" "19:00"
                 
                +
                +.equ krClearTaskQueue = ( pc )
                 PROC krClearTaskQueue
                 #define Counter AH
                +
0008d6 93ff     +push ZH
0008d7 93ef     +push ZL
                   mPUSHw  Z
                +
0008d8 e0f1     +ldi ZH , high ( ( TaskQueue ) )
0008d9 e4e0     +ldi ZL , low ( ( TaskQueue ) )
                   LDW   Z,  (TaskQueue)
                 
0008da ef0f        ldi   AL,     0xFF
0008db e110        ldi   Counter,  TASKQUEUESIZE
                   
                   ;< Loop
0008dc 9301          st  z+,     AL  ;
0008dd 951a          dec Counter     ;
0008de f7e9        brne (pc)-1-1     ; Loop
                   ;> Loop
                +
0008df 91ef     +pop ZL
0008e0 91ff     +pop ZH
                   mPOPw   Z
0008e1 9508        ret
                 #undef  Counter
                +
                +.equ SizeOf_krClearTaskQueue = ( pc - krClearTaskQueue )
                 ENDP krClearTaskQueue
                 ;###############################################################################
                 ;###############################################################################
                 
                 ;###############################################################################
                +
                +.equ krClearTimers = ( pc )
                 PROC krClearTimers
                 #define Counter AH
                +
0008e2 93ff     +push ZH
0008e3 93ef     +push ZL
                   mPUSHw  Z
                +
0008e4 e0f1     +ldi ZH , high ( ( TimersPool ) )
0008e5 e5e0     +ldi ZL , low ( ( TimersPool ) )
                   LDW   Z,  (TimersPool)
0008e6 e110        ldi Counter, TIMERSPOOLSIZE
0008e7 ef0f        ldi AL, 0xFF    ; Empty
                   ;< Loop
0008e8 9301          st z+, AL     ; Event
0008e9 9231          st z+, ZERO   ; Counter Lo
0008ea 9231          st z+, ZERO   ; Counter Hi
0008eb 951a          dec Counter   ;
0008ec f7d9        brne pc-1-1-1-1 ; Loop
                   ;> Loop
                +
0008ed 91ef     +pop ZL
0008ee 91ff     +pop ZH
                   mPOPw   Z
0008ef 9508        ret
                 #undef  Counter
                +
                +.equ SizeOf_krClearTimers = ( pc - krClearTimers )
                 ENDP krClearTimers
                 ;###############################################################################
                 ;###############################################################################
                 ;###############################################################################
                +
                +.equ krProcessTaskQueue = ( pc )
                 PROC krProcessTaskQueue
                 #define SREG_ r18       ;
                 
                +
0008f0 e0f1     +ldi ZH , high ( ( TaskQueue ) )
0008f1 e4e0     +ldi ZL , low ( ( TaskQueue ) )
                   LDW   Z,  (TaskQueue)     ;Загрузка указателя на начало очереди задач
0008f2 2d02        mov   AL, r_TaskS
0008f3 700f        andi  AL, TASKQUEUESIZE-1
0008f4 0fe0        add   ZL,   AL
0008f5 8100        ld    AL,   z     ; Читаем идентификатор текущей задачи ID_Task
0008f6 3f0f        cpi   AL,   $FF     ; No Event or Addr out of Range
0008f7 f0b9        breq lProcessTaskQueueN_Ret ; No Action
                   ;< Продвижение очереди вперед на одну задачу
                   ; Advance Queue
                   ;< critical section
0008f8 932f        push  SREG_
0008f9 b72f        in    SREG_,  SREG
0008fa 94f8        cli
0008fb ef1f        ldi   AH, $FF
0008fc 8310        st    z,    AH
0008fd 2d12          mov   AH, r_TaskS
0008fe 9512          swap  AH
0008ff 5f10          subi  AH, -$10
000900 7f1f          andi  AH, ((TASKQUEUESIZE-1)<<4)|0b1111
000901 9512          swap  AH
000902 2e21          mov   r_TaskS,AH
000903 94aa        dec   r_CNTTASK
                   ;> Продвижение очереди вперед на одну задачу
                 
                +
000904 e0f8     +ldi ZH , high ( ( TaskProcs << 1 ) )
000905 e0e0     +ldi ZL , low ( ( TaskProcs << 1 ) )
                   LDW   Z,  (TaskProcs<<1)  ;Загрузка указателя на начало списка задач
000906 0f00        lsl   AL        ;ID_Task*2
000907 0fe0        add   ZL,   AL
000908 1df3        adc   ZH,   ZERO
                 
                   ;< Получаем адрес текущей задачи
000909 9105        lpm   AL, z+
00090a 91f4        lpm   ZH,   z
00090b 2fe0        mov   ZL,   AL
                   ;> Получаем адрес текущей задачи
00090c bf2f        out   SREG, SREG_
00090d 912f        pop   SREG_
                   ;> critical section
                 
00090e 9409        ijmp      ; Переход на код задачи ;Minimize Stack Usage
                  lProcessTaskQueueN_Ret:
00090f 9508        ret
                 #undef  SREG_
                +
                +.equ SizeOf_krProcessTaskQueue = ( pc - krProcessTaskQueue )
                 ENDP krProcessTaskQueue
                 ;###############################################################################
                 ;###############################################################################
                 
                 
                 ;###############################################################################
                 ; AL - ID_Tasck
                +
                +.equ krSendTask = ( pc )
                 PROC krSendTask
                 ;.ifdef PROTEUS
                 ;   mStop
                 ; .endif
                 
                 #define SREG_ r18
                +
000910 93df     +push YH
000911 93cf     +push YL
                   mPUSHw  Y
000912 931f        push  AH
000913 932f        push  SREG_
                   ;< critical section
000914 b72f        in    SREG_,  SREG
000915 94f8        cli
                 
                +
000916 e0d1     +ldi YH , high ( ( TaskQueue ) )
000917 e4c0     +ldi YL , low ( ( TaskQueue ) )
                   LDW   Y   ,(TaskQueue)       ;Загрузка указателя на начало очереди задач
000918 2d12        mov   AH  ,r_TaskS
000919 9512        swap  AH  
00091a 701f        andi  AH  ,TASKQUEUESIZE-1
00091b 0fc1        add   YL  ,AH
00091c 8118        ld    AH  ,y
00091d 3f1f        cpi   AH  ,0xFF
00091e f439        brne lSendTaskN1
00091f 8308          st    y       ,AL
000920 2d12          mov   AH      ,r_TaskS
000921 5f10          subi  AH      ,-0x10
000922 7f1f          andi  AH      ,((TASKQUEUESIZE-1)<<4)|0b1111
000923 2e21          mov   r_TaskS ,AH
000924 94a3          inc   r_CNTTASK
000925 d06f          rcall krDedug
                  lSendTaskN1:
000926 bf2f        out   SREG, SREG_
                   ;> critical section
000927 912f        pop   SREG_
000928 911f        pop   AH
                +
000929 91cf     +pop YL
00092a 91df     +pop YH
                   mPOPw Y
00092b 9508        ret
                 #undef  SREG_
                +
                +.equ SizeOf_krSendTask = ( pc - krSendTask )
                 ENDP krSendTask
                 ;###############################################################################
                 ;###############################################################################
                 
                 ;###############################################################################
                 ; AL - Timer ID_Task
                 ; X - Counter
                 ;#if 1
                 ;#endif
                 
                +
                +.equ krSetTimer = ( pc )
                 PROC krSetTimer
                 #define SREG_ r19
                 #define Counter r18
                +
00092c 93ff     +push ZH
00092d 93ef     +push ZL
                   mPUSHw  Z
00092e 931f        push AH
00092f 932f        push Counter
000930 933f        push SREG_
                   
                   ;< critical section
000931 b73f        in    SREG_,  SREG  ; Critical Section
000932 94f8        cli
                   
                   ;< Поиск в очереди таймеров таймера с текущим заданием ID_Task
                +
000933 e0f1     +ldi ZH , high ( ( TimersPool ) )
000934 e5e0     +ldi ZL , low ( ( TimersPool ) )
                   LDW   Z     ,(TimersPool)
000935 e120        ldi Counter ,TIMERSPOOLSIZE
                  L_krSetTimer_SearchLoop:
000936 8110          ld  AH    ,z      ; Value / Counter
000937 1710          cp  AH    ,AL     ; Search for Event
000938 f439          brne L_krSetTimer_MissMatchID
                     
                 ; L_krSetTimer_MatchID:
                   ;< ID_Task match AL
000939 83a1        std   z+1   ,XL    
00093a 83b2        std   z+2   ,XH    ; Update Counter
00093b 2bab        or    XL    ,XH
00093c f4a1        brne L_krSetTimer_ret   ; Exit
00093d ef1f          ldi AH    ,0xFF
00093e 8310          st  z     ,AH
00093f c011        rjmp L_krSetTimer_ret   ; Exit
                   ;> ID_Task match AL
                   
                  L_krSetTimer_MissMatchID:
000940 9633          adiw  ZL, 3
000941 952a          dec Counter     ;
000942 f799          brne L_krSetTimer_SearchLoop; Loop
                   ;> Поиск в очереди таймеров таймера с текущим заданием ID_Task
                 
                   ;< Search in queue Empty Timer
                +
000943 e0f1     +ldi ZH , high ( ( TimersPool ) )
000944 e5e0     +ldi ZL , low ( ( TimersPool ) )
                   LDW   Z,    (TimersPool)
000945 e120        ldi Counter, TIMERSPOOLSIZE
                  L_krSetTimer_EmptyLoop:
000946 8110          ld  AH, z     ; Value / Counter
000947 3f1f          cpi AH, 0xFF    ; Search for Empty Timer
000948 f421          brne L_krSetTimer_NoEmpty
                     
                 ; L_krSetTimer_Empty:
                   ;< ID_Task match AL
000949 8300        st    z,    AL    ; Set Event ID_Task
00094a 83a1        std   z+1,  XL    
00094b 83b2        std   z+2,  XH    ; Update Counter
00094c c004        rjmp L_krSetTimer_ret   ; Exit
                   ;> ID_Task match AL
                   
                  L_krSetTimer_NoEmpty:
00094d 9633          adiw  ZL, 3
00094e 952a          dec Counter     ;
00094f f7b1          brne L_krSetTimer_EmptyLoop; Loop
                   ;> Search in queue Empty Timer
                   
000950 d056        rcall krError
                 
                 
                  L_krSetTimer_ret:
000951 bf3f        out   SREG, SREG_ ; leave Critical Section
                   ;> critical section
                  
000952 913f        pop SREG_
000953 912f        pop Counter
000954 911f        pop AH
                +
000955 91ef     +pop ZL
000956 91ff     +pop ZH
                   mPOPw   Z
000957 9508        ret
                 #undef  SREG_
                 #undef  Counter
                +
                +.equ SizeOf_krSetTimer = ( pc - krSetTimer )
                 ENDP krSetTimer
                 
                 ;###############################################################################
                 ;###############################################################################
                 
                 ;###############################################################################
                 ; AL - Timer ID_Task
                +
                +.equ krClrTimer = ( pc )
                 PROC krClrTimer
                 #define SREG_ r19
                 #define Counter r18
                +
000958 93ff     +push ZH
000959 93ef     +push ZL
                   mPUSHw  Z
00095a 931f        push AH
00095b 932f        push Counter
00095c 933f        push SREG_
                   
                 
                +
00095d e0f1     +ldi ZH , high ( ( TimersPool ) )
00095e e5e0     +ldi ZL , low ( ( TimersPool ) )
                   LDW   Z,    (TimersPool)
00095f e120        ldi Counter, TIMERSPOOLSIZE
                   ; Поиск в очереди таймеров таймера с текущим заданием ID_Task
                   
                   ;< critical section
000960 b73f        in    SREG_,  SREG  ; Critical Section
000961 94f8        cli
                   
                  L_krClrTimer_Loop:
000962 8110        ld AH, z      ; Value / Counter
000963 1710        cp AH, AL   ; Search for Event
000964 f429        brne lClrTimer_NE
                 
000965 8231        std   z+1,  ZERO    ; Critical Section
000966 8232        std   z+2,  ZERO    ; Update Counter
000967 ef1f        ldi   AH,   0xFF
000968 8310        st    z,    AH  ;Запишем маркер отключения таймера
000969 c003        rjmp  lClrTimer_Exit
                 
                  lClrTimer_NE:
00096a 9633        adiw  ZL, 3
                 
00096b 952a        dec Counter     ;
00096c f7a9        brne L_krClrTimer_Loop     ; Loop
                 
                  lClrTimer_Exit:
                  
00096d bf3f        out   SREG, SREG_ ; leave Critical Section
                   ;> critical section
                   
00096e 913f        pop SREG_
00096f 912f        pop Counter
000970 911f        pop AH
                +
000971 91ef     +pop ZL
000972 91ff     +pop ZH
                   mPOPw   Z
000973 9508        ret
                 #undef  SREG_
                 #undef  Counter
                +
                +.equ SizeOf_krClrTimer = ( pc - krClrTimer )
                 ENDP krClrTimer
                 
                 
                 ;###############################################################################
                 ;###############################################################################
                 ;################################## FUNCTION ###################################
                 ;Name of function:
                  ; krMemFill
                 ;Input:
                  ; AL - byte for filling
                  ; AH - size of filling block
                  ; y  - RAM pointer. The address of the beginning of the block of filling
                 ;Return:
                  ; -
                 ;Description:
                  ; Fills the block of memory in the specified byte
                 ;
                 
                 
                +
                +.equ krMemFill = ( pc )
                 PROC krMemFill
                 ; ldi   AH, LCDBUFFSIZE
                 ; ldi   AL, ' '
                 ; LDW   Y,(v_LCDBuf)
000974 931f        push  AH
000975 9309         st   y+,   AL
000976 951a         dec    AH
000977 f7e9        brne  (pc)-1-1
000978 911f        pop   AH
000979 9508        ret
                +
                +.equ SizeOf_krMemFill = ( pc - krMemFill )
                 ENDP krMemFill
                 
                 ;################################## FUNCTION ###################################
                 ;Name of function:
                  ; krMemCopyR2R
                 ;Input:
                  ; AL - size the block of memory for copy 
                  ; Z  - RAM pointer. The address of the beginning of the block of copying
                  ; y  - RAM pointer. Destination address
                 ;Return:
                  ; -
                 ;Description:
                  ; Copying the specified size the block of memory from RAM into RAM
                 ;
                +
                +.equ krMemCopyR2R = ( pc )
                 PROC krMemCopyR2R
00097a 931f        push  AH
00097b 930f        push  AL
                   ;
00097c 9111          ld  AH  ,z+
00097d 9319          st  y+  ,AH
00097e 950a          dec AL
00097f f7e1        brne (pc)-1-1-1
000980 910f        pop   AL
000981 911f        pop   AH
000982 9508        ret
                +
                +.equ SizeOf_krMemCopyR2R = ( pc - krMemCopyR2R )
                 ENDP krMemCopyR2R
                 
                 ;################################## FUNCTION ###################################
                 ;Name of function:
                  ; krMemCopyF2R
                 ;Input:
                  ; AL - size the block of memory for copy 
                  ; Z  - FLASH pointer. The address of the beginning of the block of copying
                  ; y  - RAM pointer. Destination address
                 ;Return:
                  ; -
                 ;Description:
                  ; Copying the specified size the block of memory from FLASH into RAM
                 ;
                +
                +.equ krMemCopyF2R = ( pc )
                 PROC krMemCopyF2R
000983 931f        push  AH
000984 930f        push  AL
                   ;
000985 9115          lpm   AH, z+
000986 9319          st    y+,   AH
000987 950a          dec   AL
000988 f7e1        brne (pc)-1-1-1
000989 910f        pop   AL
00098a 911f        pop   AH
00098b 9508        ret
                +
                +.equ SizeOf_krMemCopyF2R = ( pc - krMemCopyF2R )
                 ENDP krMemCopyF2R
                 
                 ;###############################################################################
                 
                 ;PROC fTimerService
                 ; mTimerService
                 ; ret
                 ;ENDP fTimerService
                 
                +
                +.equ krRand = ( pc )
                 PROC krRand
                   ;< MUL RND,17
00098c 2d07        mov AL, r_RND ; x1
00098d 0f00        lsl AL    ; x2
00098e 0f00        lsl AL    ; x4
00098f 0f00        lsl AL    ; x8
000990 0f00        lsl AL    ; x16
000991 0d07        add AL, r_RND ; x(16+1) = 0b00010001
                   ;> MUL RND,17
000992 5c0b        subi AL, -53  ; -(-53) = +53
000993 2e70        mov r_RND,AL  ; RND = (RNDi * 17 + 53) {MOD 256}
000994 9508        ret
                +
                +.equ SizeOf_krRand = ( pc - krRand )
                 ENDP krRand
                 ;
                 #include  "RTOSA/Debug.asm" ;
                 
                +
                +.equ krDedug = ( pc )
                 PROC krDedug
000995 930f        push  AL
000996 e100        ldi   AL        ,TASKQUEUESIZE
000997 16a0        cp    r_CNTTASK ,AL
000998 f020        brcs no_ovf_task
                   
                +
000999 e0f9     +ldi ZH , high ( ( szErrorTaskOvf ) )
00099a e9ef     +ldi ZL , low ( ( szErrorTaskOvf ) )
                     LDW   Z       ,(szErrorTaskOvf)
00099b d9b5          rcall fLCDPageZ
00099c cfff          rjmp  pc
                  no_ovf_task:
00099d 910f        pop   AL
00099e 9508        ret
                 szErrorTaskOvf:
                 ;-------------------------+
                              ;|01234567| ;|
00099f 2020
0009a0 7245
0009a1 6f72
0009a2 2072                .db "  Error " ;|
0009a3 6154
0009a4 6b73
0009a5 6f20
0009a6 6676                .db "Task ovf" ;|
                 ;-------------------------+
                 
                +
                +.equ SizeOf_krDedug = ( pc - krDedug )
                 ENDP krDedug
                 
                +
                +.equ krError = ( pc )
                 PROC krError
                +
0009a7 e800     +ldi AL , SetDDRAM | Line1 | Pos0
                +
                +.if LCDTYPE == 3
                +
                +rcall fLCD_WR3
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                +
                +.if P_LCDRS > ( 0x3f )
                +push r16
0009a8 98ae     +push r17
                +in r17 , SREG
                +.error "Botva BATENKA!!!"
                +.endif 
                +rcall fLCD_Strob
                +rcall fLCDWait
0009a9 d921     +
                +.elif LCDTYPE == 4
                +
                +.if LCD_CMD == LCD_CMD
                +mPinCLR LCDRS
                +.elif LCD_CMD == LCD_DATA
                +mPinSET LCDRS
                +.else 
                +mLCD_WR LCD_CMD
0009aa e5ee     +ldi ZL , low ( szError * 2 )
0009ab e1f3     +ldi ZH , high ( szError * 2 )
0009ac d98d     +rcall fLCDszZ
                   mLCDszZat Line1,Pos0,szError
0009ad cfff        rjmp  pc
0009ae 9508        ret
                 szError:
0009af 7245
0009b0 6f72
0009b1 2172
0009b2 0021        .db "Error!!",0
                +
                +.equ SizeOf_krError = ( pc - krError )
                 ENDP krError
                 
                 .include  "ServoHXT900.inc"
                 
                 ;Updated: "2011-03-07" "19:41"
                 
                 #ifndef	SERVOHXT900_INC
                 	#define	SERVOHXT900_INC 1
                 	
                 	#ifndef MACROEX_INC
                 	#endif
                 	#ifndef	TIMERCNTRS_INC
                 	#endif
                 	;<
                 		;500us 
                 		;2500us
                 		;609 344
                 	#define	Deg			*12.25;us per 1°
                 
                 	.equ	RELOADT1	=	2500*2
                 	.equ  CORRECT		= 0
                 	.equ	SERVOINIT	=	1500+CORRECT
                 	
                 	.equ	SERVOMID	=	RELOADT1*SERVOINIT/20000
ServoHXT900.inc(24): warning: float->int cast, truncated
TankDemo.asm(1726): 'ServoHXT900.inc' included form here
                 	.equ	SERVOMIN	=	RELOADT1*(SERVOINIT-(Alf)Deg)/20000
ServoHXT900.inc(25): warning: float->int cast, truncated
TankDemo.asm(1726): 'ServoHXT900.inc' included form here
                 	.equ	SERVOMAX	=	RELOADT1*(SERVOINIT+(Alf)Deg)/20000
                 	
                 	
                +
                +.equ fServoInit = ( pc )
                 	PROC fServoInit
                 		;500us 
                 		;2500us
                 		;PWM Frequency 50Hz
                 		
                +
0009b3 e1f3     +ldi ZH , high ( ( RELOADT1 ) )
0009b4 e8e8     +ldi ZL , low ( ( RELOADT1 ) )
                 		LDW		Z       ,(RELOADT1)
                +
                +.if ICR1H > ( 0x3f )
                +sts ICR1H , ZH
0009b5 bdf7     +.else 
                +out ICR1H , ZH
                 		mOut	ICR1H   ,ZH
                +
                +.if ICR1L > ( 0x3f )
                +sts ICR1L , ZL
0009b6 bde6     +.else 
                +out ICR1L , ZL
                 		mOut	ICR1L   ,ZL
                 		;< Setting Servo0 into MID position
                +
0009b7 e0f1     +ldi ZH , high ( ( SERVOMID ) )
0009b8 e7e7     +ldi ZL , low ( ( SERVOMID ) )
                 		LDW		Z       ,(SERVOMID)
                +
                +.if OCR1AH > ( 0x3f )
                +sts OCR1AH , ZH
0009b9 bdfb     +.else 
                +out OCR1AH , ZH
                 		mOut	OCR1AH  ,ZH
                +
                +.if OCR1AL > ( 0x3f )
                +sts OCR1AL , ZL
0009ba bdea     +.else 
                +out OCR1AL , ZL
                 		mOut	OCR1AL  ,ZL
                 		;> Setting Servo0 into MID position
                 		
                 		;< Setting Servo1 into MID position
                 ;		LDW		Z       ,(SERVOMID)
                +
                +.if OCR1BH > ( 0x3f )
                +sts OCR1BH , ZH
0009bb bdf9     +.else 
                +out OCR1BH , ZH
                 		mOut	OCR1BH  ,ZH
                +
                +.if OCR1BL > ( 0x3f )
                +sts OCR1BL , ZL
0009bc bde8     +.else 
                +out OCR1BL , ZL
                 		mOut	OCR1BL  ,ZL
                 		;> Setting Servo1 into MID position
                 
                   ;< Sets Servo into the centre position
0009bd e098            ldi rvIndxServo     ,8
                   ;> Sets Servo into the centre position
                 
                 	
                 		;Set MODE 8 - 
                 ;----+-----+-----+-----+-----+---------------------------+------+---------+---------+
                 ;Mode|WGMn3|WGMn2|WGMnl|WGMnO|Timer/Counter Mode of      |TOP   |Update of|TOVn Flag|
                 ;    |     |CTCn |PWMnl|PWMn0|        Operation          |      |OCRnx at | Set on  |
                 ;  8 |  1  |  0  |  0  |  0  |PWM, Phase and Freq Correct|ICRn  |BOTTOM   |BOTTOM   |
                 ;  14|  1  |  1  |  1  |  0  |Fast PWM                   |ICRn  |TOP      |TOP      |
                 ;----+-----+-----+-----+-----+---------------------------+------+---------+---------+
                 		;
                +
                +.if 1
                +.endif 
                +
                +.if TCCR1A > ( 0x3f )
                +lds AL , TCCR1A
0009be b50f     +.else 
                +in AL , TCCR1A
                +mIn AL , TCCR1A
0009bf 7000     +cbr AL , 0xff
0009c0 6802     +ori AL , ( 14 & 0b0011 ) | PWM1A_NoInv
                +
                +
                +.if TCCR1B > ( 0x3f )
                +lds AH , TCCR1B
0009c1 b51e     +.else 
                +in AH , TCCR1B
                +mIn AH , TCCR1B
                +.if T1Div64 > 7
                +
0009c2 7e10     +cbr AH , ( 1 << WGM13 ) | ( 1 << WGM12 )
0009c3 611b     +ori AH , ( ( 14 & 0b1100 ) << 1 )
                +.else 
                +cbr AH , ( 1 << WGM13 ) | ( 1 << WGM12 ) | ( 1 << CS12 ) | ( 1 << CS11 ) | ( 1 << CS10 )
                +
                +.if TCCR1A > ( 0x3f )
                +sts TCCR1A , AL
0009c4 bd0f     +.else 
                +out TCCR1A , AL
                +ori AH , ( ( 14 & 0b1100 ) << 1 ) | T1Div64
                +
                +.if TCCR1B > ( 0x3f )
                +sts TCCR1B , AH
0009c5 bd1e     +.else 
                +out TCCR1B , AH
                +.endif 
                +
                +mOut TCCR1A , AL
                +mOut TCCR1B , AH
                +
                +.if ( P_PWM1A - 1 ) > ( 0x3f )
                +push r16
0009c6 9abd     +lds r16 , P_PWM1A - 1
                +sbr r16 , ( 1 << PWM1A )
                +
                +
                +.if P_PWM1A > ( 0x3f )
                +push r16
0009c7 9ac5     +push r17
                +in r17 , SREG
                +
                +
                 		mT1SetMode 14 ,T1Div64 ,PWM1A_NoInv
                 	
                +
                +.if TIMSK > ( 0x3f )
                +lds AL , TIMSK
0009c8 b707     +.else 
                +in AL , TIMSK
                 	mIn AL    ,TIMSK
0009c9 6004      	ori AL    ,(1<<TOIE1)
                +
                +.if TIMSK > ( 0x3f )
                +sts TIMSK , AL
0009ca bf07     +.else 
                +out TIMSK , AL
                 	mOut TIMSK,AL
                 	
                 		
                 			;< Interrupt
                 				.set	OldPC	=	pc
                 				.org	OVF1addr	;Overflow0 Interrupt Vector Address
00001c c144      					rjmp f_IntOVF1	;Timer0 Overflow Handler
                 				.org	OldPC
                 				
                 			;> Interrupt
                 		
0009cb 9508      		ret
                 	
                +
                +.equ SizeOf_fServoInit = ( pc - fServoInit )
                 	ENDP fServoInit
                 
                 
                 
                 ;>
                 #else
                 #endif
                 
                 .include  "Melody.asm"
                 
                 .equ 	F_DO	=	262	; До				261,63
                 .equ 	F_DOD	=	277	; До-диез		277,18
                 .equ 	F_RE	=	294	; Ре				293,67
                 .equ 	F_RED	=	311	; Ре-диез		311,13
                 .equ 	F_MI	=	330	; Ми				329,63
                 .equ 	F_FA	=	349	; Фа				349,22
                 .equ 	F_FAD	=	370	; Фа-диез		369,99
                 .equ 	F_SOL	=	392	; Соль			391,99
                 .equ 	F_SOLD=	415	; Соль-диез	415,30
                 .equ 	F_LA	=	440	; Ля				440,00
                 .equ 	F_LAD	=	466	; Ля-диез		466,16
                 .equ 	F_SI	=	494	; Си				493,88
                 
                 .equ NP    = 0 ;	Пауза
                 .equ NDO   = 1 ;
                 .equ NDOD  = 2 ;
                 .equ NRE   = 3 ;
                 .equ NRED  = 4 ;
                 .equ NMI   = 5 ;
                 .equ NFA   = 6 ;
                 .equ NFAD  = 7 ;
                 .equ NSOL  = 8 ;
                 .equ NSOLD = 9 ;
                 .equ NLA   = 10;
                 .equ NLAD  = 11;
                 .equ NSI   = 12;
                 
                 .equ  NT0	 =	0
                 .equ  NT1	 =	1
                 .equ  NT2	 =	2
                 .equ  NT4	 =	3
                 .equ  NT8	 =	4
                 .equ  NT16 =	5
                 .equ  NT32 =	6
                 
                 ;< Use this code as interrupts handler
                 ;PROC INT_OC3C ;"Buzer"
                 ;
                 ;  in    TmpSREG   ,SREG
                 ;  ;Place your code here
                 ;  mPinCpl pBuzer  ; Инверсия состояния для вывода "Buzer"
                 ;
                 ;  push  AL
                 ;  push  AH
                 ;  mIn   AL    ,OCR3CL
                 ;  lds   AH    ,v_DivNote+0
                 ;  add   AL    ,AH
                 ;
                 ;  push  AL
                 ;  mIn   AL    ,OCR3CH
                 ;  lds   AH    ,v_DivNote+1
                 ;  adc   AH    ,AL
                 ;  pop   AL
                 ;
                 ;  mOut OCR3CH ,AH
                 ;  mOut OCR3CL ,AL
                 ;
                 ;  pop   AH
                 ;  pop   AL
                 ;  out   SREG  ,TmpSREG
                 ;  reti
                 ;
                 ;ENDP INT_OC3C
                 ;> Use this code as interrupts handler
                 
                 
                +
                +.equ fBuzerInit = ( pc )
                 PROC fBuzerInit
                +
                +.if P_pBuzer > ( 0x3f )
                +push r16
0009cc 98af     +push r17
                +in r17 , SREG
                 	mPinCLR	pBuzer
                +
                +.if ( P_pBuzer - 1 ) > ( 0x3f )
                +push r16
0009cd 9aa7     +lds r16 , P_pBuzer - 1
                +sbr r16 , ( 1 << pBuzer )
                 	mPinOut	pBuzer
                 .equ	FTC3 = Fclk / 8 ; 2 000 000 Hz
                 
0009ce 9508      	ret
                 	;< Interrupt
                 		.set	OldPC	=	pc
                 		.org	OC3Caddr				; Timer/Counter3 Compare Match C
000038 c0ff      			rjmp INT_OC3C	;
                 		.org	OldPC
                 	;> Interrupt
                 
                +
                +.equ SizeOf_fBuzerInit = ( pc - fBuzerInit )
                 ENDP fBuzerInit
                 
                 
                +
                +.equ fNoteSetF = ( pc )
                 PROC fNoteSetF
                 .ifdef	PROTEUS
                +
                +
                +.if P_Stop > ( 0x3f )
                +push r16
0009cf 98dc     +push r17
                +in r17 , SREG
                +mPinCLR Stop
                +
                +.if P_Stop > ( 0x3f )
                +push r16
0009d0 9adc     +push r17
                +in r17 , SREG
                +mPinSET Stop
                +
                +
                 	mStop
                 .endif
                 
                +
0009d1 e0be     +ldi XH , high ( ( FTC3 / 2 / F_DO ) )
0009d2 eea8     +ldi XL , low ( ( FTC3 / 2 / F_DO ) )
                 	LDW	X,	(FTC3/2/F_DO)
0009d3 93a0 012e 	sts	(v_DivNote+0),	XL
0009d5 93b0 012f 	sts	(v_DivNote+1),	XH
                 
                 
0009d7 9508      	ret
                 
                  ctDivNotes: ; Значение частоты выше вдвое, т.к. прим. инверсия вывода "Buzer"
0009d8 0ee8      	.dw FTC3/2/F_DO		; До				261,63
0009d9 0e1a      	.dw FTC3/2/F_DOD	; До-диез		277,18
0009da 0d49      	.dw FTC3/2/F_RE		; Ре				293,67
0009db 0c8f      	.dw FTC3/2/F_RED	; Ре-диез		311,13
0009dc 0bd6      	.dw FTC3/2/F_MI		; Ми				329,63
0009dd 0b31      	.dw FTC3/2/F_FA		; Фа				349,22
0009de 0a8e      	.dw FTC3/2/F_FAD	; Фа-диез		369,99
0009df 09f7      	.dw FTC3/2/F_SOL	; Соль			391,99
0009e0 0969      	.dw FTC3/2/F_SOLD	; Соль-диез	415,30
0009e1 08e0      	.dw FTC3/2/F_LA		; Ля				440,00
0009e2 0861      	.dw FTC3/2/F_LAD	; Ля-диез		466,16
0009e3 07e8      	.dw FTC3/2/F_SI		; Си				493,88
                 
                  ctDNotes: ; Таблица значений для длительности нот
                 #if 1
0009e4 0064      	.dw 1s
0009e5 0032      	.dw 1s /2
0009e6 0019      	.dw 1s /4
0009e7 000c      	.dw 1s /8
0009e8 0006      	.dw	1s /16
0009e9 0003      	.dw	1s /32
                 
                 #else
                 #endif
                 
                +
                +.equ SizeOf_fNoteSetF = ( pc - fNoteSetF )
                 ENDP fNoteSetF
                 
                +
                +.equ fMelodyFinish = ( pc )
                 PROC fMelodyFinish
                +
0009ea e1fb     +ldi ZH , high ( ( ctGimn_UA << 1 ) )
0009eb e3e4     +ldi ZL , low ( ( ctGimn_UA << 1 ) )
                 	LDW	Z             ,(ctGimn_UA<<1)
0009ec 93e0 0130 	sts	(v_fptrSND+0) ,ZL
0009ee 93f0 0131 	sts	(v_fptrSND+1) ,ZH
                +
0009f0 930f     +push AL
0009f1 e008     +ldi AL , TP_fMelodyPlay - TaskProcs
0009f2 df1d     +rcall krSendTask
0009f3 910f     +pop AL
                 	mSendTask	fMelodyPlay
0009f4 9508      	ret
                +
                +.equ SizeOf_fMelodyFinish = ( pc - fMelodyFinish )
                 ENDP fMelodyFinish
                 
                +
                +.equ fMelodyMoneta = ( pc )
                 PROC fMelodyMoneta
                 
                   ;< Decrement v_CntMonet
0009f5 9100 0106     lds AL          ,(v_CntMonet)
0009f7 950a          dec AL
0009f8 9300 0106     sts (v_CntMonet),AL
                   ;> Decrement v_CntMonet
                 
                +
0009fa e1fb     +ldi ZH , high ( ( ct_monet << 1 ) )
0009fb e0e2     +ldi ZL , low ( ( ct_monet << 1 ) )
                 	LDW	Z             ,(ct_monet<<1)
                 
0009fc 93e0 0130 	sts	(v_fptrSND+0) ,ZL
0009fe 93f0 0131 	sts	(v_fptrSND+1) ,ZH
                +
000a00 930f     +push AL
000a01 e008     +ldi AL , TP_fMelodyPlay - TaskProcs
000a02 df0d     +rcall krSendTask
000a03 910f     +pop AL
                 	mSendTask	fMelodyPlay
000a04 9508      	ret
                +
                +.equ SizeOf_fMelodyMoneta = ( pc - fMelodyMoneta )
                 ENDP fMelodyMoneta
                 
                 
                +
                +.equ fMelodyPlay = ( pc )
                 PROC fMelodyPlay
                 ;	LDW	Z,	(ctMelody<<1)
                 ;	sts	(v_fptrSND+0),	ZL
                 ;	sts	(v_fptrSND+1),	ZH
                 
000a05 91e0 0130 	lds	ZL            ,(v_fptrSND+0)
000a07 91f0 0131 	lds	ZH            ,(v_fptrSND+1)
                 
000a09 9105      	lpm	AL            ,z+	; Read octave and note (octave bit7-4)|(note bit3-0)
000a0a 9115      	lpm	AH            ,z+	; Read duration
000a0b 93e0 0130 	sts	(v_fptrSND+0) ,ZL
000a0d 93f0 0131 	sts	(v_fptrSND+1) ,ZH
                 
000a0f 930f      	push	AL
                 
000a10 d029      	rcall fBuzerOn	;
                 	;< Test PAUSE
000a11 700f      	andi	AL, 0b1111	; Test PAUSE
000a12 f409      	brne L_fMelodyPlay_NoPause
000a13 d02e      		rcall fBuzerOff	;
                  L_fMelodyPlay_NoPause:
                 	;> Test PAUSE
                 
                 	;< Settings prediv for current note
                 	;< Read prediv for current note
                +
000a14 e1f3     +ldi ZH , high ( ( ctDivNotes << 1 ) )
000a15 ebe0     +ldi ZL , low ( ( ctDivNotes << 1 ) )
                 	LDW	  Z   ,(ctDivNotes<<1)
000a16 950a      	dec		AL
000a17 0f00      	lsl		AL
000a18 0fe0      	add		ZL,	AL
000a19 1df3      	adc		ZH,	ZERO
000a1a 91a5      	lpm		XL,	z+
000a1b 91b5      	lpm		XH,	z+
                 	;> Read prediv for current note
                 
000a1c 910f      	pop		AL
                 
                 	;< Correct prediv for current octave
000a1d 9502      	swap	AL
000a1e 700f      	andi	AL, 0b1111
                  L_fMelodyPlay_CO:
000a1f 950a      	dec		AL
000a20 f019      	breq L_fMelodyPlay_NoCO
000a21 95b6      		lsr	XH
000a22 95a7      		ror	XL
000a23 cffb      		rjmp L_fMelodyPlay_CO
                 L_fMelodyPlay_NoCO:
                 	;> Correct prediv for current octave
                 
000a24 93a0 012e 	sts	(v_DivNote+0),	XL
000a26 93b0 012f 	sts	(v_DivNote+1),	XH
                 	;> Settings prediv for current note
                 
                 	;< Read & settings duration
000a28 2311      	tst		AH ;AH - Inex of Duration into ctDNotes tables
000a29 f429      	brne L_fMelodyPlay_Cont ;
000a2a d017      		rcall fBuzerOff	;	THE END
000a2b 9100 012d 		lds   AL    ,(v_Event_Melody)
000a2d dee2      		rcall krSendTask
                 
000a2e 9508      		ret
                  L_fMelodyPlay_Cont:
000a2f 951a      	dec		AH
000a30 0f11      	lsl		AH
                +
000a31 e1f3     +ldi ZH , high ( ( ctDNotes << 1 ) )
000a32 ece8     +ldi ZL , low ( ( ctDNotes << 1 ) )
                 	LDW		Z,	(ctDNotes<<1)
000a33 0fe1      	add		ZL,	AH
000a34 1df3      	adc		ZH,	ZERO
000a35 91a5      	lpm		XL,	z+                      ; init Timer
000a36 91b5      	lpm		XH,	z+                      ; init Timer
000a37 e008      	ldi		AL,	GetTaskID(fMelodyPlay)	; TaskID
000a38 def3      	rcall krSetTimer
                 	;> Read & settings duration
                 
                  L_fMelodyPlay_Ret:
000a39 9508      	ret
                 
                +
                +.equ SizeOf_fMelodyPlay = ( pc - fMelodyPlay )
                 ENDP fMelodyPlay
                 
                 
                +
                +.equ fBuzerOn = ( pc )
                 PROC fBuzerOn
000a3a 930f      	push	AL
                +
                +.if ETIMSK > ( 0x3f )
000a3b 9100 007d+lds AL , ETIMSK
                +.else 
                +in AL , ETIMSK
                 	mIn		AL,			ETIMSK
000a3d 6002      	ori		AL,			(1<<OCIE3C)
                +
                +.if ETIMSK > ( 0x3f )
000a3e 9300 007d+sts ETIMSK , AL
                +.else 
                +out ETIMSK , AL
                 	mOut	ETIMSK,	AL
000a40 910f      	pop		AL
000a41 9508      	ret
                +
                +.equ SizeOf_fBuzerOn = ( pc - fBuzerOn )
                 ENDP fBuzerOn
                 
                +
                +.equ fBuzerOff = ( pc )
                 PROC fBuzerOff
000a42 930f      	push	AL
                +
                +.if ETIMSK > ( 0x3f )
000a43 9100 007d+lds AL , ETIMSK
                +.else 
                +in AL , ETIMSK
                 	mIn		AL,			ETIMSK
000a45 7f0d      	cbr		AL,			(1<<OCIE3C)
                +
                +.if ETIMSK > ( 0x3f )
000a46 9300 007d+sts ETIMSK , AL
                +.else 
                +out ETIMSK , AL
                 	mOut	ETIMSK,	AL
                +
                +.if P_pBuzer > ( 0x3f )
                +push r16
000a48 98af     +push r17
                +in r17 , SREG
                 	mPinCLR	pBuzer
000a49 910f      	pop		AL
000a4a 9508      	ret
                +
                +.equ SizeOf_fBuzerOff = ( pc - fBuzerOff )
                 ENDP fBuzerOff
                 
                 .include  "InfraRedControl.inc"
                 
                 .endif
                 
                 .ifndef flg_IRStart
                 .endif
                 
                 	;##########################################################
                 	;##########################################################
                 	.dseg
                 	.list
                 	.listmac
                 	;##########################################################
                 	;##########################################################
                 	
                 ;< defines constants
                 
                 ;	mExtIntType	INT5,EXTANY	;	BAMP F-TSOP
                 ;--------
                 ; RC5
                 ;	The modulated carrier is usually derived from 432kHz and is 1/12 of the
                 ;	frequency with 1/3 duty cycle.
                 ;	When data are transmitted repeatedly, the frame cycle is 113.7ms or 256
                 ;	period.
                 ;	A frame consists of a two-bit syn code, a one-bit control code, a five-bit
                 ;	system code, and a six-bit data code. Len = 14-bit
                 ; Frame = 14 * 4* 444 = 24 864us
                 ;		Data Item         	Time (sec.)     Time (no. of period)
                 ;		Data off time     	0.888ms         2T
                 ;		Data on time      	0.888ms         2T
                 ;		Data period (0)   	3.552ms         4T
                 ;		Data period (1)   	3.552ms         4T
                 ;		Frame output cycle	113.7ms         256T
                 ;		Where T=0.444ms
                 #define SYNCRC5	888
                 ;--------
                 ; SONY
                 ;	The modulated carrier is usually derived from 480kHz and is 1/12 of the
                 ;	frequency with 1/3 duty cycle.
                 ;	When data are transmitted repeatedly, the frame cycle is 45ms or 150
                 ;	period.
                 ;	A frame consists of a syn pulse, a seven-bit data code and a five-bit custom
                 ;	code.
                 ; Frame = (8+6*13) * 300 = 25 800us
                 ;		Data Item         	Time (sec.)			Time (no. of period)
                 ;		Syn pulse         	2.4ms      			8T
                 ;		Data off time     	0.61ms     			2T
                 ;		Data on time (0)  	0.59ms     			2T
                 ;		Data on time (1)  	1.19ms     			4T
                 ;		Data period (0)   	1.2ms      			4T
                 ;		Data period (1)   	1.8ms      			6T
                 ;		Frame output cycle	45ms       			150T
                 ;		Where T=0.3ms
                 #define SYNCSONY	2400
                 ;--------
                 ;	Matsushita
                 ;	The modulated carrier is usually derived from 440kHz and is 1/12 of the
                 ;	frequency with 1/2 duty cycle.
                 ;	When data are transmitted repeatedly, the frame cycle is 104.7ms or 240
                 ;	period.
                 ;	A frame consists of a syn pulse, a six-bit custom code, six-bit data code, a
                 ;	six-bit inverted custom code and  a six-bit inverted data code.
                 ; Frame = (8+8+12*4+12*8) * 436 = 69 760us
                 
                 ;	 Data Item          	Time (sec.)			Time (no. of period)
                 ;	 Syn pulse on time  	3.49ms     			8T
                 ;	 Syn pulse off time 	3.49ms     			8T
                 ;	 Data on time (0)   	0.86ms     			2T
                 ;	 Data off time (0)  	0.88ms     			2T
                 ;	 Data on time (1)   	0.86ms     			2T
                 ;	 Data off time (1)  	2.63ms     			6T
                 ;	 Data period (0)    	1.74ms     			4T
                 ;	 Data period (1)    	3.49ms     			8T
                 ;	 Frame output cycle 	104.7ms    			240T
                 ;	 Where T=0.436ms
                 #define SYNCMATSUSHITA	3490
                 
                 ;--------
                 ; NEC
                 ;	The modulated carrier is usually derived from 455kHz and is 1/12 of the
                 ;	frequency with 1/3 duty cycle.
                 ;	When data are transmitted repeatedly, the frame cycle is 107.9ms or 186
                 ;	period.
                 ;	A frame consists of a syn pulse, an eight-bit custom code, an eight-bit
                 ;	inverted custom code, an eight-bit data code and an eight-bit inverted data
                 ;	code.
                 ; Frame = (15,5+8+16*2+16*4)* 580 = 69 310us
                 
                 ;		Data Item         	Time (sec.)			Time (no. of period)
                 ;		Syn pulse on time 	8.993ms    			15.5T
                 ;		Syn pulse off time	4.642ms    			8T
                 ;		Syn pulse off time	2.321ms    			4T
                 ;		(subsequent frame)
                 ;		Data on time (0)  	0.561ms    			T
                 ;		Data off time (0) 	0.598ms    			T
                 ;		Data on time (1)  	0.561ms    			T
                 ;		Data off time (1) 	1.758ms    			3T
                 ;		Data period (0)   	1.160ms    			2T
                 ;		Data period (1)   	2.321ms    			4T
                 ;		Frame output cycle	107.9ms    			186T
                 ;		Where T=0.58ms
                 #define SYNCNEC	8993
                 
                 #define SYNCTIMEOUT	10000
                 
                 #define IrPulseThershold(Tus) Tus*Fclk/1000000/1024;
                 ;#define IrPulseThershold(Tus) 1100*16000000/1000000/1024;
                 ;> defines constants
                 
                +
                +.equ fIRInit = ( pc )
                 PROC fIRInit
                +
                +.if ( P_IRC - 1 ) > ( 0x3f )
                +push r16
000a4b 9815     +lds r16 , P_IRC - 1
                +cbr r16 , ( 1 << IRC )
                 	mPinIn	IRC	;	от датчика переднего бампера	;INT5
                +
                +.if P_IRC > ( 0x3f )
                +push r16
000a4c 9a1d     +push r17
                +in r17 , SREG
                 	mPinSET	IRC	;	от датчика переднего бампера	;INT5
                +
000a4d 930f     +push r16
                +.if INT5 > 4
                +
                +.if EICRB > ( 0x3f )
                +lds r16 , EICRB
000a4e b70a     +.else 
                +in r16 , EICRB
                +mIn r16 , EICRB
000a4f 7f0b     +cbr r16 , EXTANY << ( ( INT5 & 0b11 ) * 2 )
000a50 6004     +ori r16 , EXTANY << ( ( INT5 & 0b11 ) * 2 )
                +
                +.if EICRB > ( 0x3f )
                +sts EICRB , r16
000a51 bf0a     +.else 
                +out EICRB , r16
                +mOut EICRB , r16
                +.else 
                +mIn r16 , EICRA
                +
                +.if EIMSK > ( 0x3f )
                +lds r16 , EIMSK
000a52 b709     +.else 
                +in r16 , EIMSK
                +
000a53 6200     +
                +
                +.if EIMSK > ( 0x3f )
                +sts EIMSK , r16
000a54 bf09     +.else 
                +out EIMSK , r16
                +
000a55 910f     +cbr r16 , EXTANY << ( ( INT5 & 0b11 ) * 2 )
                 	mExtIntType	INT5,EXTANY	;	BAMP F-TSOP
                +
                +
                +.if flg_IRStart < 8
000a56 7b6f     +cbr r_Flags , ( 1 << flg_IRStart )
                +.else 
                +cbr r_FlagsH , 1 << ( flg_IRStart & 0b111 )
                 	mFlgClr	flg_IRStart
                +
                +
                +.if flg_IR_OK < 8
000a57 776f     +cbr r_Flags , ( 1 << flg_IR_OK )
                +.else 
                +cbr r_FlagsH , 1 << ( flg_IR_OK & 0b111 )
                 	mFlgClr	flg_IR_OK
                 
000a58 9508      	ret
                +
                +.equ SizeOf_fIRInit = ( pc - fIRInit )
                 ENDP fIRInit
                 
                +
                +.equ fIRShiftBuff = ( pc )
                 PROC fIRShiftBuff ;Any logical change on INT5 generates an interrupt request
                 
                +
                +
                +
                +.if flg_IR_OK < 8
000a59 fd67     +sbrc r_Flags , flg_IR_OK
000a5a 9508     +ret
                +.else 
                +sbrc r_FlagsH , flg_IR_OK & 0b111
                 	mIfFlgSET flg_IR_OK,ret
                 
000a5b 930f      	push	AL
000a5c 931f      	push	AH
                 
                +
                +
                +
                +.if flg_IRStart < 8
000a5d ff66     +sbrs r_Flags , flg_IRStart
000a5e c03a     +rjmp L_fIRShiftBuff_Start
                +.else 
                +sbrs r_FlagsH , ( flg_IRStart & 0b111 )
                 	mIfFlgCLR flg_IRStart,rjmp L_fIRShiftBuff_Start
                 	;< Continuation the IR pulses
                 		;< Calc pulse duration
000a5f b702      		in	AL,						TCNT0
000a60 9110 01c8 		lds	AH,						(v_IRTCNT0)
000a62 9300 01c8 		sts	(v_IRTCNT0),	AL
000a64 1b01      		sub	AL,	AH
                 		;> Calc pulse duration
                 
                 		;< Detect infrared code formats (RC5; SONY; MATSUSHITA; NEC)
000a65 9110 01c9 		lds		AH,		(v_IRBits)
000a67 9513      		inc		AH
000a68 9310 01c9 		sts		(v_IRBits),	AH
                 
000a6a f499      		brne L_fIRShiftBuff_NoSync
000a6b e415      			ldi	AH,	'E'; - ERROR
000a6c 300c      			cpi	AL,	IrPulseThershold (SYNCRC5)-1
000a6d f068      			brlo L_fIRShiftBuff_SetID
000a6e e315      				ldi	AH,	'5'; - RC5;
000a6f 3204      				cpi	AL,	IrPulseThershold (SYNCSONY)-1
000a70 f050      				brlo L_fIRShiftBuff_SetID
000a71 e513      					ldi	AH,	'S'; - SONY;
000a72 3305      					cpi	AL,	IrPulseThershold (SYNCMATSUSHITA)-1
000a73 f038      					brlo L_fIRShiftBuff_SetID
000a74 e41d      						ldi	AH,	'M'; - MATSUSHITA
000a75 380b      						cpi	AL,	IrPulseThershold (SYNCNEC)-1
000a76 f020      						brlo L_fIRShiftBuff_SetID
000a77 e41e      							ldi	AH,	'N'; - NEC
000a78 390b      							cpi	AL,	IrPulseThershold (SYNCTIMEOUT)-1
000a79 f008      							brlo L_fIRShiftBuff_SetID
000a7a e415      								ldi	AH,	'E'; - ERROR
                 
                 		L_fIRShiftBuff_SetID:
000a7b 9310 01ca 			sts	(v_IRID),	AH	; '5'-RC5; 'S'-SONY; 'M'-MATSUSHITA; 'N'-NEC; 'E'-ERROR
000a7d c02e      		rjmp L_fIRShiftBuff_Ret
                 		;> Detect infrared code formats (RC5; SONY; MATSUSHITA; NEC)
                 
                  L_fIRShiftBuff_NoSync:
000a7e 9110 01c9 		lds		AH,		(v_IRBits)
000a80 ff10      		sbrs	AH,		0
000a81 c02a      		rjmp L_fIRShiftBuff_Ret
                  			;< Shift only even bit
                 	;		ldi	AH,	IrPulseThershold(1152)
000a82 e114      			ldi	AH,	IrPulseThershold(1300)
000a83 1710      			cp	AH,	AL	; если длительность импульса/паузы больше пороговой
                 									; сдвигаем в буфер единицу иначе ноль.
                 
                 			; LSB is transmitted first
000a84 9100 01c4 			lds		AL,	(v_IR_Buff+0)
000a86 9507      			ror		AL
000a87 9300 01c4 			sts		(v_IR_Buff+0),	AL
000a89 9100 01c5 			lds		AL,	(v_IR_Buff+1)
000a8b 9507      			ror		AL
000a8c 9300 01c5 			sts		(v_IR_Buff+1),	AL
000a8e 9100 01c6 			lds		AL,	(v_IR_Buff+2)
000a90 9507      			ror		AL
000a91 9300 01c6 			sts		(v_IR_Buff+2),	AL
000a93 9100 01c7 			lds		AL,	(v_IR_Buff+3)
000a95 9507      			ror		AL
000a96 9300 01c7 			sts		(v_IR_Buff+3),	AL
                  			;> Shift only even bit
000a98 c013      		rjmp L_fIRShiftBuff_Ret
                 	;> Continuation the IR pulses
                 
                  L_fIRShiftBuff_Start:
                 	;< Starting IR pulse
000a99 ef1f      	ser		AH
000a9a 9310 01c9 	sts		(v_IRBits),	AH
000a9c 9230 01c4 	sts		(v_IR_Buff+0)	,ZERO
000a9e 9230 01c5 	sts		(v_IR_Buff+1)	,ZERO
000aa0 9230 01c6 	sts		(v_IR_Buff+2)	,ZERO
000aa2 9230 01c7   sts		(v_IR_Buff+3)	,ZERO
                 
                +
                +
                +.if flg_IRStart < 8
000aa4 6460     +ori r_Flags , 1 << flg_IRStart
                +.else 
                +ori r_FlagsH , 1 << ( flg_IRStart & 0b111 )
                 	mFlgSet	flg_IRStart	; Начало посылки IR кода
000aa5 b702      	in	AL,						TCNT0
000aa6 9300 01c8 	sts	(v_IRTCNT0),	AL
                +
                +.if 100 * 100 / 1000 > ( 1 << 16 ) || ( 100 * 100 / 1000 == 0 )
                +.error "Time out range!!!"
000aa8 e00d     +.else 
000aa9 e0aa     +ldi AL , TP_fIRTimeOut - TaskProcs
000aaa e0b0     +ldi XL , low ( 100 * 100 / 1000 )
000aab de80     +ldi XH , high ( 100 * 100 / 1000 )
                +rcall krSetTimer
                 	mSetTimerTask fIRTimeOut,100ms
                 	;> Starting IR pulse
                 
                 L_fIRShiftBuff_Ret:
                 
000aac 911f      		pop		AH
000aad 910f      		pop		AL
000aae 9508      		ret
                 	;
                +
                +.equ SizeOf_fIRShiftBuff = ( pc - fIRShiftBuff )
                 ENDP fIRShiftBuff
                 
                +
                +.equ fIRTimeOut = ( pc )
                 PROC fIRTimeOut
                +
000aaf 930f     +push r16
000ab0 b709     +in r16 , EIMSK
000ab1 7d0f     +cbr r16 , ( 1 << INT5 )
000ab2 bf09     +out EIMSK , r16
000ab3 910f     +pop r16
                 	mDI_EXT	INT5
                 
                +
                +
                +.if flg_IRStart < 8
000ab4 7b6f     +cbr r_Flags , ( 1 << flg_IRStart )
                +.else 
                +cbr r_FlagsH , 1 << ( flg_IRStart & 0b111 )
                 	mFlgClr	flg_IRStart
000ab5 9100 01ca 	lds		AL	,(v_IRID)
000ab7 340e      	cpi		AL	,'N';-NEC;
000ab8 f409       	brne (pc+1)+1
000ab9 d019       		rcall fIRDecodeNEC
                 
000aba 3305      	cpi		AL	,'5';-RC5;
000abb f409       	brne (pc+1)+1
000abc d00d       		rcall fIRDecodeRC5
                 
000abd 3503      	cpi		AL	,'S';-SONY;
000abe f409       	brne (pc+1)+1
000abf d00d       		rcall fIRDecodeSONY
                 
000ac0 340d      	cpi		AL	,'M';-MATSUSHITA;
000ac1 f409       	brne (pc+1)+1
000ac2 d00d       		rcall fIRDecodeMATSUSHITA
                 
                +
                +
                +.if flg_IRStart < 8
000ac3 7b6f     +cbr r_Flags , ( 1 << flg_IRStart )
                +.else 
                +cbr r_FlagsH , 1 << ( flg_IRStart & 0b111 )
                  	mFlgClr	flg_IRStart
                 
                +
000ac4 930f     +push r16
                +
                +.if EIMSK > ( 0x3f )
                +lds r16 , EIMSK
000ac5 b709     +.else 
                +in r16 , EIMSK
                +mIn r16 , EIMSK
000ac6 6200     +sbr r16 , exp2 ( INT5 )
                +
                +.if EIMSK > ( 0x3f )
                +sts EIMSK , r16
000ac7 bf09     +.else 
                +out EIMSK , r16
                +mOut EIMSK , r16
000ac8 910f     +pop r16
                  	mEI_EXT	INT5
000ac9 9508       	ret
                +
                +.equ SizeOf_fIRTimeOut = ( pc - fIRTimeOut )
                 ENDP fIRTimeOut
                 
                +
                +.equ fIRDecodeRC5 = ( pc )
                 PROC fIRDecodeRC5
000aca 930f      	push	AL
                 	;
000acb 910f      	pop		AL
                 
000acc 9508      	ret
                 
                +
                +.equ SizeOf_fIRDecodeRC5 = ( pc - fIRDecodeRC5 )
                 ENDP fIRDecodeRC5
                 
                +
                +.equ fIRDecodeSONY = ( pc )
                 PROC fIRDecodeSONY
000acd 930f      	push	AL
                 	;
000ace 910f      	pop		AL
                 
000acf 9508      	ret
                 
                +
                +.equ SizeOf_fIRDecodeSONY = ( pc - fIRDecodeSONY )
                 ENDP fIRDecodeSONY
                 
                +
                +.equ fIRDecodeMATSUSHITA = ( pc )
                 PROC fIRDecodeMATSUSHITA
000ad0 930f      	push	AL
                 	;
000ad1 910f      	pop		AL
                 
000ad2 9508      	ret
                 
                +
                +.equ SizeOf_fIRDecodeMATSUSHITA = ( pc - fIRDecodeMATSUSHITA )
                 ENDP fIRDecodeMATSUSHITA
                 
                +
                +.equ fIRDecodeNEC = ( pc )
                 PROC fIRDecodeNEC
000ad3 930f      	push	AL
                 	;< For NEC only
000ad4 2711      	clr		AH
000ad5 2722      	clr		BL
000ad6 9100 01c4 	lds		AL,	(v_IR_Buff+0)
000ad8 2710      	eor		AH,	AL
000ad9 2b20      	or		BL,	AL
000ada 9300 01c0 	sts		(v_IR_Code+0)	,AL
                 
000adc 9100 01c5 	lds		AL,	(v_IR_Buff+1)
000ade 2710      	eor		AH,	AL
000adf 2b20      	or		BL,	AL
000ae0 9300 01c1 	sts		(v_IR_Code+1)	,AL
                 
000ae2 9100 01c6 	lds		AL,	(v_IR_Buff+2)
000ae4 2710      	eor		AH,	AL
000ae5 2b20      	or		BL,	AL
000ae6 9300 01c2 	sts		(v_IR_Code+2)	,AL
                 
000ae8 9100 01c7 	lds		AL,	(v_IR_Buff+3)
000aea 2710      	eor		AH,	AL
000aeb 2b20      	or		BL,	AL
000aec 9300 01c3 	sts		(v_IR_Code+3)	,AL
000aee f059        breq (pc+1)+1+1+1+2+2+2+2 ;-----------+
000aef 2311          tst   AH        				;           |
000af0 f449          brne (pc+1)+1+2+2+2+2   ;--------+  |
                +
                +
                +.if flg_IR_OK < 8
000af1 6860     +ori r_Flags , 1 << flg_IR_OK
                +.else 
                +ori r_FlagsH , 1 << ( flg_IR_OK & 0b111 )
                       mFlgSet flg_IR_OK;    				 |  |
000af2 9100 01c7       lds	AL					,(v_IR_Buff+3);|  |
000af4 9300 01cb       sts	(v_IR_Addr)	,AL           ;|  |
000af6 9100 01c5       lds	AL					,(v_IR_Buff+1);|  |
000af8 9300 01cc       sts	(v_IR_Cmd)	,AL           ;|  |
                     ;                <---------------+  |
                   ;                  <------------------+
                 	;> For NEC only
000afa 910f      	pop		AL
000afb 9508      	ret
                 
                +
                +.equ SizeOf_fIRDecodeNEC = ( pc - fIRDecodeNEC )
                 ENDP fIRDecodeNEC
                 
                 
                 
                 
                 ;< MAP KEY for  VCD/MP3 JX-2001 
                 ;++=======+=====+ +=======+=====+ +=======+=====+ +=======+=====+
                 ;||  Key  | Cmd | |  Key  | Cmd | |  Key  | Cmd | |  Key  | Cmd |
                 ;++=======+=====+ +=======+=====+ +=======+=====+ +=======+=====+
                 ;|| POWER |0x10 | |   b   |0x03 | |      |0x01 | |   #   |0x06 |
                 ;++-------+-----+ +-------+-----+ +-------+-----+ +-------+-----+
                 ;||   1   |0x09 | |   2   |0x1D | |   3   |0x1F | |   4   |0x0D |
                 ;++-------+-----+ +-------+-----+ +-------+-----+ +-------+-----+
                 ;||   5   |0x19 | |   6   |0x1B | |   7   |0x11 | |   8   |0x15 |
                 ;++-------+-----+ +-------+-----+ +-------+-----+ +-------+-----+
                 ;||   9   |0x17 | | 10/0  |0x12 | |  10+  |0x16 | | Time  |0x4C |
                 ;++-------+-----+ +-------+-----+ +-------+-----+ +-------+-----+
                 ;||  OSD  |0x40 | |REPEAT |0x48 | | SLOW  |0x04 | | MODE  |0x00 |
                 ;++-------+-----+ +-------+-----+ +-------+-----+ +-------+-----+
                 ;||  VOL- |0x02 | | VOL+  |0x05 | |RETURN |0x54 | |  PBC  |0x4D |
                 ;++-------+-----+ +-------+-----+ +-------+-----+ +-------+-----+
                 ;||  <<   |0x0A | |  >>   |0x1E | |  |<<  |0x0E | |  >>|  |0x1A |
                 ;++-------+-----+ +-------+-----+ +-------+-----+ +-------+-----+
                 ;||  R/L  |0x1C | |  >||  |0x14 | | STOP  |0x0F | |  P/N  |0x0C |
                 ;++=======+=====+ +=======+=====+ +=======+=====+ +=======+=====+
                 ;> MAP KEY for  VCD/MP3 JX-2001 
                 
                +
                +.equ fIR_Command = ( pc )
                 PROC fIR_Command
                +
                +
                +
                +.if flg_IR_OK < 8
000afc ff67     +sbrs r_Flags , flg_IR_OK
000afd c05c     +rjmp L_fIR_Command_Exit
                +.else 
                +sbrs r_FlagsH , ( flg_IR_OK & 0b111 )
                 	mIfFlgCLR flg_IR_OK, rjmp L_fIR_Command_Exit
000afe d060      	rcall	fIRPrint
                 
000aff 9100 01cc 	lds		AL,	(v_IR_Cmd)
                 
                 ;< Sets rvIndxServo (0..7) at Key "1".."8";OR -90 0 90 at Key "10/0" "9" "10+"
000b01 3009      	cpi		AL,	0x09 ; Key 1
                 	;<
000b02 f411      	brne (pc+1)+1+1
000b03 e090      		ldi	rvIndxServo,	0
000b04 c054      		rjmp L_fIR_Command_Handle
                 	;>
                 
000b05 310d      	cpi		AL,	0x1D ; Key 2
                 	;<
000b06 f411      	brne (pc+1)+1+1
000b07 e091      		ldi	rvIndxServo,	1
000b08 c050      		rjmp L_fIR_Command_Handle
                 	;>
                 
000b09 310f      	cpi		AL,	0x1F ; Key 3
                 	;<
000b0a f411      	brne (pc+1)+1+1
000b0b e092      		ldi	rvIndxServo,	2
000b0c c04c      		rjmp L_fIR_Command_Handle
                 	;>
                 
000b0d 300d      	cpi		AL,	0x0D ; Key 4
                 	;<
000b0e f411      	brne (pc+1)+1+1
000b0f e093      		ldi	rvIndxServo,	3
000b10 c048      		rjmp L_fIR_Command_Handle
                 	;>
                 
000b11 3109      	cpi		AL,	0x19 ; Key 5
                 	;<
000b12 f411      	brne (pc+1)+1+1
000b13 e094      		ldi	rvIndxServo,	4
000b14 c044      		rjmp L_fIR_Command_Handle
                 	;>
                 
000b15 310b      	cpi		AL,	0x1B ; Key 6
                 	;<
000b16 f411      	brne (pc+1)+1+1
000b17 e095      		ldi	rvIndxServo,	5
000b18 c040      		rjmp L_fIR_Command_Handle
                 	;>
                 
000b19 3101      	cpi		AL,	0x11 ; Key 7
                 	;<
000b1a f411      	brne (pc+1)+1+1
000b1b e096      		ldi	rvIndxServo,	6
000b1c c03c      		rjmp L_fIR_Command_Handle
                 	;>
                 
000b1d 3105      	cpi		AL,	0x15 ; Key 8
                 	;<
000b1e f411      	brne (pc+1)+1+1
000b1f e097      		ldi	rvIndxServo,	7
000b20 c038      		rjmp L_fIR_Command_Handle
                 	;>
                 
000b21 3107      	cpi		AL,	0x17 ; Key 9
                 	;<
000b22 f411      	brne (pc+1)+1+1
000b23 e098      		ldi	rvIndxServo,	8
000b24 c034      		rjmp L_fIR_Command_Handle
                 	;>
                 	
000b25 3102      	cpi		AL,	0x12 ; Key 10/0
                 	;<
000b26 f411      	brne (pc+1)+1+1
000b27 e099      		ldi	rvIndxServo,	9
000b28 c030      		rjmp L_fIR_Command_Handle
                 	;>
                 	
000b29 3106      	cpi		AL,	0x16 ; Key 10+
                 	;<
000b2a f411      	brne (pc+1)+1+1
000b2b e09a      		ldi	rvIndxServo,	10
000b2c c02c      		rjmp L_fIR_Command_Handle
                 	;>
                 
                 ;> Sets rvIndxServo (0..7) at Key "1".."8";OR -90 0 90 at Key "10/0" "9" "10+"
                 
                 ;;< Sets fInit_FM_LS at Key "MODE"
                 ;cpi		AL,	0x00 ; Key "MODE"
                 ;	;<
                 ;	brne (pc+1)+1+1
                 ;		rcall	fInit_FM_LS
                 ;		rjmp L_fIR_Command_Handle
                 ;	;>
                 ;;> Sets fInit_FM_LS at Key "MODE"
                 
                 ;< Sets fSearch_Finish at Key "square"
000b2d 3001      cpi		AL,	0x01 ; Key "square"
                 	;<
000b2e f411      	brne (pc+1)+1+1
000b2f dbce      		rcall	fSearch_Finish
000b30 c028      		rjmp L_fIR_Command_Handle
                 	;>
                 ;> Sets fSearch_Finish at Key "square"
                 
                 ;< Sets "flg_Lamp = 1" at Key "b"
000b31 3003      cpi		AL,	0x03 ; Key "b"
                 	;<
000b32 f411      	brne (pc+1)+1+1
                +
                +
                +.if flg_Lamp < 8
                +ori r_Flags , 1 << flg_Lamp
000b33 6470     +.else 
                +ori r_FlagsH , 1 << ( flg_Lamp & 0b111 )
                 		mFlgSet flg_Lamp
000b34 c024      		rjmp L_fIR_Command_Handle
                 	;>
                 ;> Sets "flg_Lamp = 1" at Key "b"
                 		
                 ;< Sets fAdjustAtMonet at Key "Time"
000b35 340c      cpi		AL,	0x4C ; Key "Time"
                 	;<
000b36 f411      	brne (pc+1)+1+1
000b37 db38      		rcall	fAdjustAtMonet
000b38 c020      		rjmp L_fIR_Command_Handle
                 	;>
                 ;> Sets fAdjustAtMonet at Key "Time"
                 	
000b39 3006      	cpi		AL,	0x06 ; #
                 	;<
000b3a f419      	brne (pc+1)+1+1+1
000b3b db85      		rcall	fScanMonet
000b3c da5a      		rcall	fEvent
000b3d c01b      		rjmp L_fIR_Command_Handle
                 	;>
                 
                 
000b3e 310c      cpi		AL,	0x1C
                 	;<
000b3f f411      	brne (pc+1)+1+1
000b40 6480      		ori	rvSpeedLR, 0x40
000b41 c017      		rjmp L_fIR_Command_Handle
                 	;>
                 
000b42 300c      cpi		AL,	0x0C
                 	;<
000b43 f411      	brne (pc+1)+1+1
000b44 6084      		ori	rvSpeedLR, 0x04
000b45 c013      		rjmp L_fIR_Command_Handle
                 	;>
                 
000b46 300f      cpi		AL,	0x0F
                 	;<
000b47 f411      	brne (pc+1)+1+1
000b48 e080      		ldi	rvSpeedLR, 0x00
000b49 c00f      		rjmp L_fIR_Command_Handle
                 	;>
                 
000b4a 3504      cpi		AL,	0x54
                 	;<
000b4b f419      	brne (pc+1)+1+1+1
000b4c e800      		ldi	AL,	0x80
000b4d 2780      		eor	rvSpeedLR,	AL
000b4e c00a      		rjmp L_fIR_Command_Handle
                 	;>
                 
000b4f 340d      cpi		AL,	0x4D
                 	;<
000b50 f419      	brne (pc+1)+1+1+1
000b51 e008      		ldi	AL,	0x08
000b52 2780      		eor	rvSpeedLR,	AL
000b53 c005      		rjmp L_fIR_Command_Handle
                 	;>
000b54 3104      cpi		AL,	0x14 ; Key "PLAY"
                 	;<
000b55 f411      	brne (pc+1)+1+1
000b56 de93          rcall fMelodyFinish
000b57 c001        	rjmp L_fIR_Command_Handle
                 	;>
                 
000b58 c001        rjmp L_fIR_Command_Exit ;The Command No Handle 
                 
                  L_fIR_Command_Handle:
                +
                +
                +.if flg_IR_OK < 8
000b59 776f     +cbr r_Flags , ( 1 << flg_IR_OK )
                +.else 
                +cbr r_FlagsH , 1 << ( flg_IR_OK & 0b111 )
                 	mFlgClr	flg_IR_OK
                 	
                  L_fIR_Command_Exit:
                +
                +.if 310 * 100 / 1000 > ( 1 << 16 ) || ( 310 * 100 / 1000 == 0 )
                +.error "Time out range!!!"
000b5a e00e     +.else 
000b5b e1af     +ldi AL , TP_fIR_Command - TaskProcs
000b5c e0b0     +ldi XL , low ( 310 * 100 / 1000 )
000b5d ddce     +ldi XH , high ( 310 * 100 / 1000 )
                +rcall krSetTimer
                 	mSetTimerTask fIR_Command,310ms
000b5e 9508      	ret
                +
                +.equ SizeOf_fIR_Command = ( pc - fIR_Command )
                 ENDP fIR_Command
                 
                +
                +.equ fIRPrint = ( pc )
                 PROC fIRPrint
                 #define		r_Tmp r20
                 ;	mIfFlgCLR flg_IR_OK,ret
                 ;	mFlgClr	flg_IR_OK
                 
                 
                 ;	rcall	fLCDBuffCLR
                +
                +.if v_LCDBuf < SRAM_START || ( v_LCDBuf + LCDBUFFSIZE ) > RAMEND
                +.error "mMemFill: Parameter(s) out of range!"
MacroEX.asm(499): Ok
                +.else 
000b5f e9c0     +.message "Ok"
000b60 e0d1     +ldi YL , low ( v_LCDBuf )
000b61 e2e0     +ldi YH , high ( v_LCDBuf )
                +ldi ZL , ' '
000b62 93e9     +LMemClr_Loop :
000b63 3ac0     +st y + , ZL
000b64 e001     +cpi YL , low ( ( v_LCDBuf + LCDBUFFSIZE ) )
000b65 07d0     +ldi r16 , high ( ( v_LCDBuf + LCDBUFFSIZE ) )
000b66 f3d8     +cpc YH , r16
                +brlo LMemClr_Loop
                +
                +.endif 
                 	mMemFill v_LCDBuf,(v_LCDBuf+LCDBUFFSIZE),' '
000b67 e409      	ldi		AL						,'I'
000b68 9300 0190 	sts		(v_LCDBuf1+0)	,AL
000b6a e502      	ldi		AL						,'R'
000b6b 9300 0191 	sts		(v_LCDBuf1+1)	,AL
                 
000b6d 9100 01ca 	lds		AL						,	(v_IRID)
000b6f 9300 0193 	sts		(v_LCDBuf1+3)	,AL
                 
                +
000b71 e0d1     +ldi YH , high ( ( v_LCDBuf1 + 5 ) )
000b72 e9c5     +ldi YL , low ( ( v_LCDBuf1 + 5 ) )
                 		LDW	Y							,(v_LCDBuf1+5)
000b73 9100 01c9 		lds	AL						,(v_IRBits)
000b75 2d13      		mov	AH						,ZERO
000b76 d04f      		rcall	fw2a
                 
                 
                +
000b77 e0d1     +ldi YH , high ( ( v_LCDBuf2 ) )
000b78 e9c8     +ldi YL , low ( ( v_LCDBuf2 ) )
                 	LDW		Y,	(v_LCDBuf2)
                +
000b79 e0b1     +ldi XH , high ( ( v_IR_Addr ) )
000b7a ecab     +ldi XL , low ( ( v_IR_Addr ) )
                 	LDW 	X,	(v_IR_Addr)
                 
000b7b e042      	ldi		r_Tmp,	2
                  L_fIRPrint:
000b7c 910d      		ld		AL,	x+
                 
000b7d 2f10      		mov		AH,	AL
000b7e 700f      		cbr		AL,	0xF0
000b7f 9512      		swap	AH
000b80 701f      		cbr		AH,	0xF0
                 
000b81 6300      		ori		AL,	'0'
000b82 6310      		ori		AH,	'0'
                 
000b83 330a      		cpi		AL,	'9'+1
000b84 f008      		brlo pc+1+1
000b85 5f09      			subi	AL,	-7
000b86 331a      		cpi		AH,	'9'+1
000b87 f008      		brlo pc+1+1
000b88 5f19      			subi	AH,	-7
                 
000b89 9319      		st		y+,	AH
000b8a 9309      		st		y+,	AL
                 
                 
000b8b 954a      		dec		r_Tmp
000b8c f779      	brne L_fIRPrint
                 
                 
                 #undef r_Tmp
                 ;;----------------+
                 ;    ;|01234567| ;|
                 ; .db "01020304" ;|
                 ; .db "05060708" ;|
                 ;;----------------+
000b8d 9508      	ret
                 
                +
                +.equ SizeOf_fIRPrint = ( pc - fIRPrint )
                 ENDP fIRPrint
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 .include  "BCD_Math.asm"
                 
                 ;Updated: "2011-03-07" "19:41"
                 
                 ;DAA
                 ;(Decimal Adjust for Addition)
                 ;Десятичная коррекция после сложения
                 ;  Схема команды:  daa
                 ;Назначение: коррекция упакованного результата сложения двух BCD-чисел в упакованном формате.
                 ;Синтаксис
                 ;Алгоритм работы:
                 ;команда работает только с регистром al и анализирует наличие следующих ситуаций:
                 ;
                 ;Ситуация 1. В результате предыдущей команды сложения флаг HF=1 или значение младшей тетрады регистра al>9.
                 ; HF = 1 в случае переноса единицы из бита 3 в 4.
                 ; Наличие одного из этих двух признаков говорит о том, что значение младшей тетрады превысило 0x09.
                 ;
                 ;Ситуация 2. В результате предыдущей команды сложения флаг CF=1 или значение регистра al>9fh. Напомним, что флаг cf устанавливается в 1 в случае переноса двоичной единицы в старший бит операнда (если значение превысило 0ffh в случае регистра al). Наличие                  одного из этих двух признаков говорит о том, что значение в регистре al превысило 9fh.
                 ;Если имеет место одна из этих двух ситуаций, то регистр al корректируется следующим образом:
                 ;для ситуации 1 содержимое регистра al увеличивается на 6;
                 ;для ситуации 2 содержимое регистра al увеличивается на 60h;
                 ;если имеют место обе ситуации, то корректировка начинается с младшей тетрады.
                 
                 
                 
                 ;.def  AL  = r16
                 ;.def  AH  = r17
                 
                 ;################################## FUNCTION ###################################
                 ;Name of function:
                  ; fBCDAdd
                 ;Input:
                  ; AL , AH
                 ;Return:
                  ; AL = AL + AH. If  (AL + AH) > 99 then CF = 1
                 ;Description:
                  ; 2-digit packed BCD addition
                  ; This proc adds the two unsigned 2-digit BCD numbers
                 ;
                 
                 ;
                 ; +---------->+---------->+---------------------->+(ret)->
                 ;													!												!
                 ;													!---------------------->!
                 ;
                +
                +.equ fBCDAdd = ( pc )
                 PROC fBCDAdd
000b8e 0f01      	add		AL,		AH
000b8f c002      	rjmp	fBCDAdx
                +
                +.equ SizeOf_fBCDAdd = ( pc - fBCDAdd )
                 ENDP fBCDAdd
                 
                 ;################################## FUNCTION ###################################
                 ;Name of function:
                  ; fBCDAdc
                 ;Input:
                  ; AL , AH
                 ;Return:
                  ; AL = AL + AH + CF. If	(AL + AH) > 99 then CF = 1
                 ;Description:
                  ; 2-digit packed BCD addition with carry
                  ; This proc adds the two unsigned 2-digit BCD numbers with carry
                 ;
                 
                 ;
                 ; +---------->+---------->+---------------------->+(ret)->
                 ;													!												!
                 ;													!---------------------->!
                 ;
                 
                +
                +.equ fBCDAdc = ( pc )
                 PROC fBCDAdc
000b90 1f01      	adc		AL,		AH
000b91 c000      	rjmp	fBCDAdx
                +
                +.equ SizeOf_fBCDAdc = ( pc - fBCDAdc )
                 ENDP fBCDAdc
                 
                 
                +
                +.equ fBCDAdx = ( pc )
                 PROC fBCDAdx
000b92 b71f      	in		AH, SREG		; Seve CF into AH bit0
000b93 5f0a      	subi	AL,		-6		; Add 6 to LSD, Pre correction
                 	;(!!! inverse logic HF and CF, Because use (subi AL, -(x)) instead of (add AL,(x) )
000b94 f415      	brhc (pc+1)+1+1		; if half carry set (LSD > 9), needed correction
000b95 ff15      		sbrs	AH, HF		; if previous carry not set
000b96 5006      			subi	AL, 6		;  cancel Pre correction
                 	;
000b97 5a00      	subi	AL, -0x60 ; Add 6 to MSD, Pre correction
                 	;(!!! inverse logic HF and CF, Because use (subi AL, -(x)) instead of (add AL,(x) )
000b98 f410      	brcc (pc+1)+1+1		; if carry set (MSD > 9), needed correction
000b99 ff10      		sbrs	AH,		CF	; if previous carry not set
000b9a 5600      			subi	AL, 0x60; cancel Pre correction
                 	;
000b9b 9508      	ret
                +
                +.equ SizeOf_fBCDAdx = ( pc - fBCDAdx )
                 ENDP fBCDAdx
                 
                 
                 ;################################## FUNCTION ###################################
                 ;Name of function:
                  ; fBCDSub
                 ;Input:
                  ; AL, AH
                 ;Return:
                  ; AL = AL - AH
                 ;Description:
                  ;2-digit packed BCD subtraction
                  ;This subroutine subtracts the two unsigned 2-digit BCD numbers
                 ;
                 
                 ;
                 ; +---------->+---------->+---------------------->+(ret)->
                 ;													!												!
                 ;													!---------------------->!
                 ;
                 
                 
                +
                +.equ fBCDSub = ( pc )
                 PROC fBCDSub
000b9c 1b01      	sub	AL,AH	;subtract the numbers binary
                 
000b9d b71f      	in		AH, SREG		; Seve CF into AH bit0
                 
                 ;IF HF ==1 then LSD = LSD - 6
                 ;IF CF == 1 then MSD = MSD - 6
                 
000b9e fd15      	sbrc	AH,	HF		;if half carry clear skip
000b9f 5006      		subi	AL,$06	; LSD = LSD - 6
                 	;
000ba0 fd10      	sbrc	AH,	CF		;if previous carry clear skip
000ba1 5600      		subi	AL,$60	; MSD = MSD - 6
000ba2 9508      	ret
                +
                +.equ SizeOf_fBCDSub = ( pc - fBCDSub )
                 ENDP fBCDSub
000ba3 9508      ret
                 
                 ;################################## FUNCTION ###################################
                 ;Name of function:
                  ; fBCDInc
                 ;Input:
                  ; AL - BCD
                 ;Return:
                  ; AL = AL + 1
                 ;Description:
                  ; -
                 ;
                 
                 
                 
                +
                +.equ fBCDInc = ( pc )
                 PROC fBCDInc
000ba4 e011      	ldi		AH,	0x01
000ba5 dfe8      	rcall	fBCDAdd
000ba6 9508      	ret
                +
                +.equ SizeOf_fBCDInc = ( pc - fBCDInc )
                 ENDP fBCDInc
                 
                 ;################################## FUNCTION ###################################
                 ;Name of function:
                  ; fBCDDec
                 ;Input:
                  ; AL - BCD
                 ;Return:
                  ; AL = AL - 1
                 ;Description:
                  ; -
                 ;
                 
                 
                +
                +.equ fBCDDec = ( pc )
                 PROC fBCDDec
000ba7 e011      	ldi		AH,	0x01
000ba8 dff3      	rcall	fBCDSub
000ba9 9508      	ret
                +
                +.equ SizeOf_fBCDDec = ( pc - fBCDDec )
                 ENDP fBCDDec
                 
                 ;################################## FUNCTION ###################################
                 ;Name of function:
                  ; fBin2BCD16
                 ;Input:
                  ; AH:AL - 16bit value
                 ;Return:
                  ; R15:R14:R13 - BCD
                 ;Description:
                  ; 16-bit Binary to BCD conversion
                 ;
                 
                 
                 
                +
                +.equ fBin2BCD16 = ( pc )
                 PROC fBin2BCD16
                 
                 .equ	AtBCD0	=13		;address of tBCD0
                 .equ	AtBCD2	=15		;address of tBCD1
                 
                 #define	tBCD0	r13	;BCD value digits 1 and 0
                 #define	tBCD1	r14	;BCD value digits 3 and 2
                 #define	tBCD2	r15	;BCD value digit 4
                 
                 #define	rbinL	AL	;binary value Low byte
                 #define	rbinH	AH	;binary value High byte
                 #define	rvCNT	r18	;loop counter
                 #define	rvTmp	r19	;temporary value
                 
                 ; * Code *
000baa e120      	ldi		rvCNT,16	;Init loop counter
000bab 24ff      	clr		tBCD2		;clear result (3 bytes)
000bac 24ee      	clr		tBCD1
000bad 24dd      	clr		tBCD0
000bae 27ff      	clr		ZH			;clear ZH (not needed for AT90Sxx0x)
                  bBCDx_1:
000baf 0f00      	lsl		rbinL		;shift input value
000bb0 1f11      	rol		rbinH		;through all bytes
000bb1 1cdd      	rol		tBCD0		;
000bb2 1cee      	rol		tBCD1
000bb3 1cff      	rol		tBCD2
000bb4 952a      	dec		rvCNT		;decrement loop counter
000bb5 f409      	brne	bBCDx_2		;if counter not zero
000bb6 9508      	ret					;   return
                 
                  bBCDx_2:
000bb7 e1e0      	ldi		ZL,	AtBCD2+1	;Z points to result MSB + 1
                  bBCDx_3:
000bb8 9132      	ld		rvTmp,	-z		;get (Z) with pre-decrement
000bb9 5f3d      	subi	rvTmp,	-$03	;add 0x03
000bba fd33      	sbrc	rvTmp,	3		;if bit 3 not clear
000bbb 8330      	st		z,		rvTmp	;	store back
000bbc 8130      	ld		rvTmp,	z		;get (Z)
000bbd 5d30      	subi	rvTmp,	-$30	;add 0x30
000bbe fd37      	sbrc	rvTmp,	7		;if bit 7 not clear
000bbf 8330      	st		z,		rvTmp	;	store back
000bc0 30ed      	cpi		ZL,		AtBCD0	;done all three?
000bc1 f7b1      	brne	bBCDx_3			;loop again if not
000bc2 cfec      	rjmp	bBCDx_1
                 #undef tBCD0
                 #undef tBCD1
                 #undef tBCD2
                 #undef rbinL
                 #undef rbinH
                 #undef rvCNT
                 #undef rvTmp
                +
                +.equ SizeOf_fBin2BCD16 = ( pc - fBin2BCD16 )
                 ENDP fBin2BCD16
                 
                +
                +.equ fw2a_10 = ( pc )
                 PROC	fw2a_10
                +
000bc3 e0b4     +ldi XH , high ( ( 0x0405 ) )
000bc4 e0a5     +ldi XL , low ( ( 0x0405 ) )
                 	LDW		X,	(0x0405)
000bc5 c002      	rjmp	fw2aEX
                 ;	rcall fw2aEX
                 ;
                 ;	ret
                +
                +.equ SizeOf_fw2a_10 = ( pc - fw2a_10 )
                 ENDP fw2a_10
                 
                +
                +.equ fw2a = ( pc )
                 PROC	fw2a
                +
000bc6 efbf     +ldi XH , high ( ( 0xFFFF ) )
000bc7 efaf     +ldi XL , low ( ( 0xFFFF ) )
                 	LDW	X,	(0xFFFF)
                 ;	rcall fw2aEX
                 ;
                 ;	ret
                +
                +.equ SizeOf_fw2a = ( pc - fw2a )
                 ENDP fw2a
                 
                 ;################################## FUNCTION ###################################
                 ;Name of function:
                  ; fw2aEX
                 ;Input:
                  ; AH:AL - word (int)
                  ; Y - SZ
                  ; XL - сколько символов выводить
                  ; XH - после какого знака десятичная точка 
                 ;Return:
                  ; -
                  ;54321
                  ;     ;
                  ;BCD value digits 1 and 0
                  ;BCD value digits 3 and 2
                  ;BCD value digit 4
                 ;Description:
                  ;
                 ;
                 
                 
                 
                +
                +.equ fw2aEX = ( pc )
                 PROC fw2aEX
                 #define	rCNT 	r18
                 #define	rflgZ	r19
                 #define	rTmp	r20
                 
000bc8 932f      	push	rCNT	;
000bc9 933f      	push	rflgZ	; Флаг ведущего нуля
000bca 934f      	push	rTmp
000bcb dfde      	rcall fBin2BCD16
000bcc e025      	ldi		rCNT,	5
                 	
000bcd e0f6      	ldi		ZH,		5+1
000bce 1bfb      	sub		ZH,		XH
000bcf e0e6      	ldi		ZL,		5+1
000bd0 1bea      	sub		ZL,		XL
                 	
000bd1 2733      	clr		rflgZ
000bd2 27bb      	clr		XH
000bd3 e0af      	ldi		XL,		AtBCD2		; X points to result MSB
                  lw2a:
                  		;< Если последний разряд то его нужно отобразить даже если это "0" 
000bd4 ef4e       		ldi		rTmp,	~0x01
000bd5 2342      		and		rTmp,	rCNT
000bd6 f409      		brne (pc+1)+1
000bd7 ef3f      			ser	rflgZ
                 		;> Если последний разряд то его нужно отобразить даже если это "0"
                 		
000bd8 914c      		ld		rTmp,		x
000bd9 ff20      		sbrs	rCNT,		bit0
000bda 9542      		 swap	rTmp			; если четное swap
000bdb 704f      		andi	rTmp,		0x0f
000bdc 2b34      		or		rflgZ,	rTmp
000bdd 6340      		ori		rTmp,		'0'
000bde 1133      		cpse	rflgZ,	ZERO
000bdf 9349      		 st		y+,			rTmp
000be0 1133      		cpse	rflgZ,	ZERO
000be1 9503      		 inc	AL
                 		 
000be2 172e      		cp		rCNT,	ZL		; проверка на достижение нужной длинны
000be3 f079      		breq lw2a_ret			; выход если вывели необходимое число символов
                 		
000be4 172f      		cp		rCNT,	ZH		; проверка на номер позиции десятичной точки
000be5 f449      		brne lw2a_NoDP		; Переход ели не совпало
000be6 2333      		  tst	rflgZ				; нужно вывести ведущий ноль если точка выводится самой первой
000be7 f421      		  brne (pc+1)+1+1+1+1
000be8 9533      		  	inc	rflgZ			; Установим  флаг отсутствия ведущих нулей
000be9 e340      			  ldi	rTmp,	'0'	; выводим ведущий ноль
000bea 9349      			  st	y+,		rTmp
000beb 9503      	  		  inc	AL			; инкремент длинны строки
000bec e24e      		  ldi	rTmp,	'.'		; выводим десятичную точку
000bed 9349      		  st	y+,		rTmp
000bee 9503        		  inc	AL				; инкремент длинны строки
                  lw2a_NoDP:
000bef 952a      		dec		rCNT
000bf0 ff20      		sbrs	rCNT,	bit0
000bf1 914e      		 ld		rTmp,	-x		; если четное swap
000bf2 f709      	brne lw2a
                  lw2a_ret:
000bf3 914f      	pop		rTmp
000bf4 913f      	pop		rflgZ
000bf5 912f      	pop		rCNT
000bf6 9508      	ret
                 #undef	rCNT	
                 #undef	rflgZ
                 #undef	rTmp
                +
                +.equ SizeOf_fw2aEX = ( pc - fw2aEX )
                 ENDP fw2aEX
                 
                 
                 
                 
                 ;--------------------------------------------------------------------------------
                 
                 
                 ;PROC fDebCrawlers
                 ;
                 ;  ;< Вывод для отладки
                 ;    rcall fLCDBuffCLR
                 ;
                 ;    lds AL  ,(v_CrawlerPosL)
                 ;    LDW Y   ,(v_LCDBuf)
                 ;    mov AH  ,ZERO
                 ;    rcall fw2a
                 ;
                 ;    LDW Y   ,(v_LCDBuf2)
                 ;    lds AL  ,(v_CrawlerCurPosL)
                 ;    mov AH  ,ZERO
                 ;    rcall fw2a
                 ;
                 ;    LDW Y   ,(v_LCDBuf+5)
                 ;    lds AL  ,(v_CrawlerPosR)
                 ;    mov AH  ,ZERO
                 ;    rcall fw2a
                 ;
                 ;    LDW Y   ,(v_LCDBuf2+5)
                 ;    lds AL  ,(v_CrawlerCurPosR)
                 ;    mov AH  ,ZERO
                 ;    rcall fw2a
                 ;
                 ;;   rcall fLCDPrint
                 ;  ;>
                 ;
                 ;  ret
                 ;
                 ;ENDP fDebCrawlers
                 
                 
                 
                 ;|01234567| ;|
                 ;"B F  L B" ;|
                 ;"B M  REB" ;|
                 ;------------+
                 
                +
                +.equ fShowSensorsState = ( pc )
                 PROC fShowSensorsState
000bf7 9100 0106     lds AL, (v_CntMonet)
000bf9 6300          ori AL            ,'0'
000bfa 9300 01ba     sts (v_InfoBuf2+2),AL
                     
                 ;    lds   AL  ,(v_ADC+7)
                 ;    ldi   AH  ,39
                 ;    
                 ;cli
                 ;	mul	  BL    ,CL
                 ;	movw	AH:AL    ,r1:r0
                 ;sei
                 ;	
                 ; ; AH:AL - word (int)
                 ; ; Y - SZ
                 ; ; XL - сколько символов выводить
                 ; ; XH - после какого знака десятичная точка 
                 ;  LDWY  (v_InfoBuf2+2)
                 ;  ldi   XL  ,4
                 ;  ldi   XH  ,2
                 ;  rcall fw2aEX
                 
                   ;< Ubat bin2hex
000bfc 9100 0187       lds   AL  ,(v_ADC+7)
000bfe 2f10            mov   AH  ,AL
000bff 700f            cbr   AL  ,0xF0
000c00 9512            swap  AH
000c01 701f            cbr   AH  ,0xF0
000c02 6300            ori   AL  ,'0'
000c03 6310            ori   AH  ,'0'
000c04 330a            cpi   AL  ,'9'+1
000c05 f008            brlo (pc+1)+1
000c06 5f09              subi  AL, -7
000c07 331a            cpi   AH  ,'9'+1
000c08 f008            brlo (pc+1)+1
000c09 5f19              subi  AH, -7
000c0a 9310 01bc     sts (v_InfoBuf2+4)  ,AH
000c0c 9300 01bd     sts (v_InfoBuf2+5)  ,AL
                   ;> Ubat bin2hex
                 
                 
                   ;< Copy page v_InfoBuf into v_LCDBuf
000c0e e100          ldi   AL    ,LCDBUFFSIZE
                +
000c0f e0f1     +ldi ZH , high ( ( v_InfoBuf ) )
000c10 ebe0     +ldi ZL , low ( ( v_InfoBuf ) )
                     LDW   Z     ,(v_InfoBuf)
                +
000c11 e0d1     +ldi YH , high ( ( v_LCDBuf ) )
000c12 e9c0     +ldi YL , low ( ( v_LCDBuf ) )
                     LDWY  (v_LCDBuf)
000c13 dd66          rcall krMemCopyR2R
                   ;> Copy page v_InfoBuf into v_LCDBuf
                 
                 ;--------
                 
                   ;< Clear v_InfoBuf
                +
000c14 e0d1     +ldi YH , high ( ( v_InfoBuf ) )
000c15 ebc0     +ldi YL , low ( ( v_InfoBuf ) )
                     LDWY  (v_InfoBuf)
                +
000c16 e0f3     +ldi ZH , high ( ( fLCDBuffCLR ) )
000c17 e7e3     +ldi ZL , low ( ( fLCDBuffCLR ) )
                     LDW   Z   ,(fLCDBuffCLR)
000c18 9509          icall ;Z
                 ;    mMemFill v_InfoBuf,(v_InfoBuf+LCDBUFFSIZE),' '
                   ;> Clear v_InfoBuf
                 
000c19 e801        ldi   AL, 0x81  ; GND = 1
000c1a 9300 01b0   sts   v_InfoBuf1+0,  AL ; LINE FRONT-L
000c1c 9300 01b8   sts   v_InfoBuf2+0,  AL ; LINE REAR-L
000c1e 9300 01b7   sts   v_InfoBuf1+7,  AL ; LINE FRONT-R
000c20 9300 01bf   sts   v_InfoBuf2+7,  AL ; LINE REAR-R
                 
000c22 e20e        ldi   AL, '.'
000c23 9300 01b2   sts   v_InfoBuf1+2,  AL ; Монетка
000c25 9300 01b5   sts   v_InfoBuf1+5,  AL ; Источник света
                 
000c27 e50f        ldi   AL, '_'
000c28 9300 01b4   sts   v_InfoBuf1+4,  AL ; Препятствие спереди
000c2a 9300 01b3   sts   v_InfoBuf1+3,  AL ; Препятствие спереди
                 
                +
                +.if 250 * 100 / 1000 > ( 1 << 16 ) || ( 250 * 100 / 1000 == 0 )
                +.error "Time out range!!!"
000c2c e00a     +.else 
000c2d e1a9     +ldi AL , TP_fShowSensorsState - TaskProcs
000c2e e0b0     +ldi XL , low ( 250 * 100 / 1000 )
000c2f dcfc     +ldi XH , high ( 250 * 100 / 1000 )
                +rcall krSetTimer
                   mSetTimerTask fShowSensorsState,250ms
                 
000c30 9508        ret
                 
                +
                +.equ SizeOf_fShowSensorsState = ( pc - fShowSensorsState )
                 ENDP fShowSensorsState
                 
                +
                +.equ fPrintLineInfo = ( pc )
                 PROC fPrintLineInfo
                 
000c31 e30f        ldi   AL, '?'
                +
                +.if flg_LFL < 8
                +sbrc r_Flags , flg_LFL
000c32 fd70     +.else 
                +sbrc r_FlagsH , flg_LFL & 0b111
                   mFlgSkipClr flg_LFL     ; LINE FRONT-L
000c33 9300 01b0   sts   v_InfoBuf1+0,  AL ; LINE FRONT-L
                 
                +
                +.if flg_LRL < 8
                +sbrc r_Flags , flg_LRL
000c35 fd72     +.else 
                +sbrc r_FlagsH , flg_LRL & 0b111
                   mFlgSkipClr flg_LRL     ; LINE REAR-L
000c36 9300 01b8   sts   v_InfoBuf2+0,  AL ; LINE REAR-L
                 
                +
                +.if flg_LFR < 8
                +sbrc r_Flags , flg_LFR
000c38 fd71     +.else 
                +sbrc r_FlagsH , flg_LFR & 0b111
                   mFlgSkipClr flg_LFR     ; LINE FRONT-R
000c39 9300 01b7   sts   v_InfoBuf1+7,  AL ; LINE FRONT-R
                 
                +
                +.if flg_LRR < 8
                +sbrc r_Flags , flg_LRR
000c3b fd73     +.else 
                +sbrc r_FlagsH , flg_LRR & 0b111
                   mFlgSkipClr flg_LRR     ; LINE REAR-R
000c3c 9300 01bf   sts   v_InfoBuf2+7,  AL ; LINE REAR-R
000c3e 9508        ret
                 
                +
                +.equ SizeOf_fPrintLineInfo = ( pc - fPrintLineInfo )
                 ENDP fPrintLineInfo
                 
                 
                 .include  "Songs.inc"
                 
                 #define NOTE(N,T,Oct) .dw (T<<8)|((Oct<<4)|N)
                 
                  ctCCCP:
                 
                 ;<
000c3f 0418      NOTE(NSOL,NT8 ,1)
                 ;-
000c40 0321      NOTE(NDO ,NT4 ,2)
000c41 0418      NOTE(NSOL,NT8 ,1)
000c42 0510      NOTE(NP  ,NT16,1)
000c43 051a      NOTE(NLA ,NT16,1)
000c44 031c      NOTE(NSI ,NT4 ,1)
000c45 0415      NOTE(NMI ,NT8 ,1)
000c46 0415      NOTE(NMI ,NT8 ,1)
                 ;-
000c47 031a      NOTE(NLA ,NT4 ,1)
000c48 0418      NOTE(NSOL,NT8 ,1)
000c49 0510      NOTE(NP  ,NT16,1)
000c4a 0516      NOTE(NFA ,NT16,1)
000c4b 0318      NOTE(NSOL,NT4 ,1)
000c4c 0411      NOTE(NDO ,NT8 ,1)
000c4d 0510      NOTE(NP  ,NT16,1)
000c4e 0511      NOTE(NDO ,NT16,1)
                 ;-
000c4f 0313      NOTE(NRE ,NT4 ,1)
000c50 0413      NOTE(NRE ,NT8 ,1)
000c51 0510      NOTE(NP  ,NT16,1)
000c52 0515      NOTE(NMI ,NT16,1)
000c53 0316      NOTE(NFA ,NT4 ,1)
000c54 0416      NOTE(NFA ,NT8 ,1)
000c55 0418      NOTE(NSOL,NT8 ,1)
                 ;-
000c56 031a      NOTE(NLA ,NT4 ,1)
000c57 041c      NOTE(NSI ,NT8 ,1)
000c58 0510      NOTE(NP  ,NT16,1)
000c59 0521      NOTE(NDO ,NT16,2)
000c5a 0323      NOTE(NRE ,NT4 ,2)
000c5b 0410      NOTE(NP  ,NT8 ,1)
000c5c 0418      NOTE(NSOL,NT8 ,1)
                 ;-
000c5d 0325      NOTE(NMI ,NT4 ,2)
000c5e 0423      NOTE(NRE ,NT8 ,2)
000c5f 0510      NOTE(NP  ,NT16,1)
000c60 0521      NOTE(NDO ,NT16,2)
000c61 0323      NOTE(NRE ,NT4 ,2)
000c62 041c      NOTE(NSI ,NT8 ,1)
000c63 0418      NOTE(NSOL,NT8 ,1)
                 ;-
000c64 0321      NOTE(NDO ,NT4 ,2)
000c65 041c      NOTE(NSI ,NT8 ,1)
000c66 0510      NOTE(NP  ,NT16,1)
000c67 051a      NOTE(NLA ,NT16,1)
000c68 031c      NOTE(NSI ,NT4 ,1)
000c69 0415      NOTE(NMI ,NT8 ,1)
000c6a 0415      NOTE(NMI ,NT8 ,1)
                 ;-
000c6b 031a      NOTE(NLA ,NT4 ,1)
000c6c 0418      NOTE(NSOL,NT8 ,1)
000c6d 0510      NOTE(NP  ,NT16,1)
000c6e 0516      NOTE(NFA ,NT16,1)
000c6f 0318      NOTE(NSOL,NT4 ,1)
000c70 0411      NOTE(NDO ,NT8 ,1)
000c71 0510      NOTE(NP  ,NT16,1)
000c72 0511      NOTE(NDO ,NT16,1)
                 ;-
000c73 0321      NOTE(NDO ,NT4 ,2)
000c74 041c      NOTE(NSI ,NT8 ,1)
000c75 0510      NOTE(NP  ,NT16,1)
000c76 051a      NOTE(NLA ,NT16,1)
000c77 0218      NOTE(NSOL,NT2 ,1)
                 ;-
000c78 0225      NOTE(NMI ,NT2 ,2)
000c79 0423      NOTE(NRE ,NT8 ,2)
000c7a 0421      NOTE(NDO ,NT8 ,2)
000c7b 041c      NOTE(NSI ,NT8 ,1)
000c7c 0421      NOTE(NDO ,NT8 ,2)
                 ;-
000c7d 0323      NOTE(NRE ,NT4 ,2)
000c7e 0410      NOTE(NP  ,NT8 ,1)
000c7f 0418      NOTE(NSOL,NT8 ,1)
000c80 0218      NOTE(NSOL,NT2 ,1)
                 ;-
000c81 0221      NOTE(NDO ,NT2 ,2)
000c82 041c      NOTE(NSI ,NT8 ,1)
000c83 041a      NOTE(NLA ,NT8 ,1)
000c84 0418      NOTE(NSOL,NT8 ,1)
000c85 041a      NOTE(NLA ,NT8 ,1)
                 ;-
000c86 031c      NOTE(NSI ,NT4 ,1)
000c87 0410      NOTE(NP  ,NT8 ,1)
000c88 0415      NOTE(NMI ,NT8 ,1)
000c89 0315      NOTE(NMI ,NT4 ,1)
000c8a 0310      NOTE(NP  ,NT4 ,1)
                 ;-
000c8b 0321      NOTE(NDO ,NT4 ,2)
000c8c 041a      NOTE(NLA ,NT8 ,1)
000c8d 0510      NOTE(NP  ,NT16,1)
000c8e 051c      NOTE(NSI ,NT16,1)
000c8f 0321      NOTE(NDO ,NT4 ,2)
000c90 041a      NOTE(NLA ,NT8 ,1)
000c91 0510      NOTE(NP  ,NT16,1)
000c92 051c      NOTE(NSI ,NT16,1)
                 ;-
000c93 0321      NOTE(NDO ,NT4 ,2)
000c94 041a      NOTE(NLA ,NT8 ,1)
000c95 0510      NOTE(NP  ,NT16,1)
000c96 0521      NOTE(NDO ,NT16,2)
000c97 0226      NOTE(NFA ,NT2 ,2)
                 ;-
000c98 0226      NOTE(NFA ,NT2 ,2)
000c99 0425      NOTE(NMI ,NT8 ,2)
000c9a 0423      NOTE(NRE ,NT8 ,2)
000c9b 0421      NOTE(NDO ,NT8 ,2)
000c9c 0423      NOTE(NRE ,NT8 ,2)
                 ;-
000c9d 0325      NOTE(NMI ,NT4 ,2)
000c9e 0410      NOTE(NP  ,NT8 ,1)
000c9f 0421      NOTE(NDO ,NT8 ,2)
000ca0 0221      NOTE(NDO ,NT2 ,2)
                 ;-
000ca1 0223      NOTE(NRE ,NT2 ,2)
000ca2 0421      NOTE(NDO ,NT8 ,2)
000ca3 041c      NOTE(NSI ,NT8 ,1)
000ca4 041a      NOTE(NLA ,NT8 ,1)
000ca5 041c      NOTE(NSI ,NT8 ,1)
                 ;-
000ca6 0321      NOTE(NDO ,NT4 ,2)
000ca7 0410      NOTE(NP  ,NT8 ,1)
000ca8 041a      NOTE(NLA ,NT8 ,1)
000ca9 021a      NOTE(NLA ,NT2 ,1)
                 ;-
000caa 0321      NOTE(NDO ,NT4 ,2)
000cab 041c      NOTE(NSI ,NT8 ,1)
000cac 041a      NOTE(NLA ,NT8 ,1)
000cad 0318      NOTE(NSOL,NT4 ,1)
000cae 0411      NOTE(NDO ,NT8 ,1)
000caf 0510      NOTE(NP  ,NT16,1)
000cb0 0511      NOTE(NDO ,NT16,1)
                 ;> BLOK1
                 
                 ;< BLOK3
000cb1 0321      NOTE(NDO ,NT4 ,2)
000cb2 041c      NOTE(NSI ,NT8 ,1)
000cb3 0510      NOTE(NP  ,NT16,1)
000cb4 051a      NOTE(NLA ,NT16,1)
000cb5 0418      NOTE(NSOL,NT8 ,1)
000cb6 0410      NOTE(NP  ,NT8 ,1)
000cb7 0410      NOTE(NP  ,NT8 ,1)
000cb8 0418      NOTE(NSOL,NT8 ,1)
                 ;> BLOK3
                 
                 ;< Повтор еще разок
                 ;<
000cb9 0418      NOTE(NSOL,NT8 ,1)
                 ;-
000cba 0321      NOTE(NDO ,NT4 ,2)
000cbb 0418      NOTE(NSOL,NT8 ,1)
000cbc 0510      NOTE(NP  ,NT16,1)
000cbd 051a      NOTE(NLA ,NT16,1)
000cbe 031c      NOTE(NSI ,NT4 ,1)
000cbf 0415      NOTE(NMI ,NT8 ,1)
000cc0 0415      NOTE(NMI ,NT8 ,1)
                 ;-
000cc1 031a      NOTE(NLA ,NT4 ,1)
000cc2 0418      NOTE(NSOL,NT8 ,1)
000cc3 0510      NOTE(NP  ,NT16,1)
000cc4 0516      NOTE(NFA ,NT16,1)
000cc5 0318      NOTE(NSOL,NT4 ,1)
000cc6 0411      NOTE(NDO ,NT8 ,1)
000cc7 0510      NOTE(NP  ,NT16,1)
000cc8 0511      NOTE(NDO ,NT16,1)
                 ;-
000cc9 0313      NOTE(NRE ,NT4 ,1)
000cca 0413      NOTE(NRE ,NT8 ,1)
000ccb 0510      NOTE(NP  ,NT16,1)
000ccc 0515      NOTE(NMI ,NT16,1)
000ccd 0316      NOTE(NFA ,NT4 ,1)
000cce 0416      NOTE(NFA ,NT8 ,1)
000ccf 0418      NOTE(NSOL,NT8 ,1)
                 ;-
000cd0 031a      NOTE(NLA ,NT4 ,1)
000cd1 041c      NOTE(NSI ,NT8 ,1)
000cd2 0510      NOTE(NP  ,NT16,1)
000cd3 0521      NOTE(NDO ,NT16,2)
000cd4 0323      NOTE(NRE ,NT4 ,2)
000cd5 0410      NOTE(NP  ,NT8 ,1)
000cd6 0418      NOTE(NSOL,NT8 ,1)
                 ;-
000cd7 0325      NOTE(NMI ,NT4 ,2)
000cd8 0423      NOTE(NRE ,NT8 ,2)
000cd9 0510      NOTE(NP  ,NT16,1)
000cda 0521      NOTE(NDO ,NT16,2)
000cdb 0323      NOTE(NRE ,NT4 ,2)
000cdc 041c      NOTE(NSI ,NT8 ,1)
000cdd 0418      NOTE(NSOL,NT8 ,1)
                 ;-
000cde 0321      NOTE(NDO ,NT4 ,2)
000cdf 041c      NOTE(NSI ,NT8 ,1)
000ce0 0510      NOTE(NP  ,NT16,1)
000ce1 051a      NOTE(NLA ,NT16,1)
000ce2 031c      NOTE(NSI ,NT4 ,1)
000ce3 0415      NOTE(NMI ,NT8 ,1)
000ce4 0415      NOTE(NMI ,NT8 ,1)
                 ;-
000ce5 031a      NOTE(NLA ,NT4 ,1)
000ce6 0418      NOTE(NSOL,NT8 ,1)
000ce7 0510      NOTE(NP  ,NT16,1)
000ce8 0516      NOTE(NFA ,NT16,1)
000ce9 0318      NOTE(NSOL,NT4 ,1)
000cea 0411      NOTE(NDO ,NT8 ,1)
000ceb 0510      NOTE(NP  ,NT16,1)
000cec 0511      NOTE(NDO ,NT16,1)
                 ;-
000ced 0321      NOTE(NDO ,NT4 ,2)
000cee 041c      NOTE(NSI ,NT8 ,1)
000cef 0510      NOTE(NP  ,NT16,1)
000cf0 051a      NOTE(NLA ,NT16,1)
000cf1 0218      NOTE(NSOL,NT2 ,1)
                 ;-
000cf2 0225      NOTE(NMI ,NT2 ,2)
000cf3 0423      NOTE(NRE ,NT8 ,2)
000cf4 0421      NOTE(NDO ,NT8 ,2)
000cf5 041c      NOTE(NSI ,NT8 ,1)
000cf6 0421      NOTE(NDO ,NT8 ,2)
                 ;-
000cf7 0323      NOTE(NRE ,NT4 ,2)
000cf8 0410      NOTE(NP  ,NT8 ,1)
000cf9 0418      NOTE(NSOL,NT8 ,1)
000cfa 0218      NOTE(NSOL,NT2 ,1)
                 ;-
000cfb 0221      NOTE(NDO ,NT2 ,2)
000cfc 041c      NOTE(NSI ,NT8 ,1)
000cfd 041a      NOTE(NLA ,NT8 ,1)
000cfe 0418      NOTE(NSOL,NT8 ,1)
000cff 041a      NOTE(NLA ,NT8 ,1)
                 ;-
000d00 031c      NOTE(NSI ,NT4 ,1)
000d01 0410      NOTE(NP  ,NT8 ,1)
000d02 0415      NOTE(NMI ,NT8 ,1)
000d03 0315      NOTE(NMI ,NT4 ,1)
000d04 0310      NOTE(NP  ,NT4 ,1)
                 ;-
000d05 0321      NOTE(NDO ,NT4 ,2)
000d06 041a      NOTE(NLA ,NT8 ,1)
000d07 0510      NOTE(NP  ,NT16,1)
000d08 051c      NOTE(NSI ,NT16,1)
000d09 0321      NOTE(NDO ,NT4 ,2)
000d0a 041a      NOTE(NLA ,NT8 ,1)
000d0b 0510      NOTE(NP  ,NT16,1)
000d0c 051c      NOTE(NSI ,NT16,1)
                 ;-
000d0d 0321      NOTE(NDO ,NT4 ,2)
000d0e 041a      NOTE(NLA ,NT8 ,1)
000d0f 0510      NOTE(NP  ,NT16,1)
000d10 0521      NOTE(NDO ,NT16,2)
000d11 0226      NOTE(NFA ,NT2 ,2)
                 ;-
000d12 0226      NOTE(NFA ,NT2 ,2)
000d13 0425      NOTE(NMI ,NT8 ,2)
000d14 0423      NOTE(NRE ,NT8 ,2)
000d15 0421      NOTE(NDO ,NT8 ,2)
000d16 0423      NOTE(NRE ,NT8 ,2)
                 ;-
000d17 0325      NOTE(NMI ,NT4 ,2)
000d18 0410      NOTE(NP  ,NT8 ,1)
000d19 0421      NOTE(NDO ,NT8 ,2)
000d1a 0221      NOTE(NDO ,NT2 ,2)
                 ;-
000d1b 0223      NOTE(NRE ,NT2 ,2)
000d1c 0421      NOTE(NDO ,NT8 ,2)
000d1d 041c      NOTE(NSI ,NT8 ,1)
000d1e 041a      NOTE(NLA ,NT8 ,1)
000d1f 041c      NOTE(NSI ,NT8 ,1)
                 ;-
000d20 0321      NOTE(NDO ,NT4 ,2)
000d21 0410      NOTE(NP  ,NT8 ,1)
000d22 041a      NOTE(NLA ,NT8 ,1)
000d23 021a      NOTE(NLA ,NT2 ,1)
                 ;-
000d24 0321      NOTE(NDO ,NT4 ,2)
000d25 041c      NOTE(NSI ,NT8 ,1)
000d26 041a      NOTE(NLA ,NT8 ,1)
000d27 0318      NOTE(NSOL,NT4 ,1)
000d28 0411      NOTE(NDO ,NT8 ,1)
000d29 0510      NOTE(NP  ,NT16,1)
000d2a 0511      NOTE(NDO ,NT16,1)
                 ;> BLOK1
                 
                 ;< BLOK3
000d2b 0321      NOTE(NDO ,NT4 ,2)
000d2c 041c      NOTE(NSI ,NT8 ,1)
000d2d 0510      NOTE(NP  ,NT16,1)
000d2e 051a      NOTE(NLA ,NT16,1)
000d2f 0418      NOTE(NSOL,NT8 ,1)
000d30 0410      NOTE(NP  ,NT8 ,1)
000d31 0410      NOTE(NP  ,NT8 ,1)
000d32 0418      NOTE(NSOL,NT8 ,1)
                 ;> BLOK3
                 
                 ;>
                 
000d33 0321      NOTE(NDO ,NT4 ,2)
000d34 041c      NOTE(NSI ,NT8 ,1)
000d35 041a      NOTE(NLA ,NT8 ,1)
000d36 0318      NOTE(NSOL,NT4 ,1)
000d37 0411      NOTE(NDO ,NT8 ,1)
000d38 0510      NOTE(NP  ,NT16,1)
000d39 0511      NOTE(NDO ,NT16,1)
                 ;-
                 
                 ;< BLOK2
000d3a 0218      NOTE(NSOL,NT2 ,1)
000d3b 031a      NOTE(NLA ,NT4 ,1)
000d3c 031c      NOTE(NSI ,NT4 ,1)
                 ;-
000d3d 0121      NOTE(NDO ,NT1,2)
000d3e 0121      NOTE(NDO ,NT1,2)
000d3f 0421      NOTE(NDO ,NT8,2)
                 ;> BLOK2
000d40 0010      NOTE(0,0,1)
                 ;>
                 
                 
                 ctNapoleTanki:
                 ;<
                 ;- 2/4
000d41 0315      NOTE(NMI ,NT4 ,1)
000d42 031a      NOTE(NLA ,NT4 ,1)
000d43 0315      NOTE(NMI ,NT4 ,1)
                 ;-
000d44 031a      NOTE(NLA ,NT4 ,1)
000d45 0315      NOTE(NMI ,NT4 ,1)
000d46 031a      NOTE(NLA ,NT4 ,1)
000d47 031c      NOTE(NSI ,NT4 ,1)
                 ;- 3/4
000d48 0321      NOTE(NDO ,NT4 ,2)
000d49 041c      NOTE(NSI ,NT8 ,1)
000d4a 041a      NOTE(NLA ,NT8 ,1)
000d4b 0218      NOTE(NSOL,NT2 ,1)
000d4c 0318      NOTE(NSOL,NT4 ,1)
                 ;-
000d4d 0321      NOTE(NDO ,NT4 ,2)
000d4e 0323      NOTE(NRE ,NT4 ,2)
000d4f 0325      NOTE(NMI ,NT4 ,2)
000d50 0321      NOTE(NDO ,NT4 ,2)
000d51 0323      NOTE(NRE ,NT4 ,2)
000d52 031c      NOTE(NSI ,NT4 ,1)
                 ;- 2/4
000d53 0321      NOTE(NDO ,NT4 ,2)
000d54 0328      NOTE(NSOL,NT4 ,2)
000d55 0326      NOTE(NFA ,NT4 ,2)
000d56 0325      NOTE(NMI ,NT4 ,2)
                 ;-
000d57 0323      NOTE(NRE ,NT4 ,2)
000d58 031a      NOTE(NLA ,NT4 ,1)
000d59 0226      NOTE(NFA ,NT2 ,2)
000d5a 0226      NOTE(NFA ,NT2 ,2)
000d5b 0325      NOTE(NMI ,NT4 ,2)
000d5c 0323      NOTE(NRE ,NT4 ,2)
                 ;-
000d5d 0321      NOTE(NDO ,NT4 ,2)
000d5e 031c      NOTE(NSI ,NT4 ,1)
000d5f 021a      NOTE(NLA ,NT2 ,1)
                 ;-
000d60 031a      NOTE(NLA ,NT4 ,1)
000d61 031c      NOTE(NSI ,NT4 ,1)
000d62 0321      NOTE(NDO ,NT4 ,2)
000d63 0323      NOTE(NRE ,NT4 ,2)
                 ;-
000d64 0325      NOTE(NMI ,NT4 ,2)
000d65 0323      NOTE(NRE ,NT4 ,2)
000d66 0321      NOTE(NDO ,NT4 ,2)
000d67 031c      NOTE(NSI ,NT4 ,1)
                 
                 
                 ;-
000d68 0321      NOTE(NDO ,NT4 ,2)
000d69 0328      NOTE(NSOL,NT4 ,2)
000d6a 0326      NOTE(NFA ,NT4 ,2)
000d6b 0325      NOTE(NMI ,NT4 ,2)
                 ;-
000d6c 0323      NOTE(NRE ,NT4 ,2)
000d6d 031a      NOTE(NLA ,NT4 ,1)
000d6e 0226      NOTE(NFA ,NT2 ,2)
000d6f 0226      NOTE(NFA ,NT2 ,2)
000d70 0325      NOTE(NMI ,NT4 ,2)
000d71 0323      NOTE(NRE ,NT4 ,2)
                 ;-
000d72 0321      NOTE(NDO ,NT4 ,2)
000d73 031c      NOTE(NSI ,NT4 ,1)
000d74 021a      NOTE(NLA ,NT2 ,1)
                 ;-
000d75 031a      NOTE(NLA ,NT4 ,1)
000d76 031c      NOTE(NSI ,NT4 ,1)
000d77 0321      NOTE(NDO ,NT4 ,2)
000d78 0323      NOTE(NRE ,NT4 ,2)
                 ;-
000d79 0325      NOTE(NMI ,NT4 ,2)
000d7a 0323      NOTE(NRE ,NT4 ,2)
000d7b 0321      NOTE(NDO ,NT4 ,2)
000d7c 031c      NOTE(NSI ,NT4 ,1)
                 ;-
000d7d 011a      NOTE(NLA ,NT1 ,1)
                 ;-
000d7e 021a      NOTE(NLA ,NT2 ,1)
                 ;-
000d7f 0210      NOTE(NP  ,NT2 ,1)
                 
                 ;-
                 ;-
000d80 0010      NOTE(0,0,1)
                 ;>
                 ;###############################################################################
                 ;###############################################################################
                 
                 ;###############################################################################
                 
                 
                 ct_monet:
000d81 0421      NOTE(NDO ,NT4+1 ,2)
000d82 0428      NOTE(NSOL,NT4+1 ,2)
000d83 0426      NOTE(NFA ,NT4+1 ,2)
000d84 0425      NOTE(NMI ,NT4+1 ,2)
                 ;-            1
000d85 0423      NOTE(NRE ,NT4+1 ,2)
000d86 041a      NOTE(NLA ,NT4+1 ,1)
000d87 0326      NOTE(NFA ,NT2+1 ,2)
000d88 0326      NOTE(NFA ,NT2+1 ,2)
000d89 0425      NOTE(NMI ,NT4+1 ,2)
000d8a 0423      NOTE(NRE ,NT4+1 ,2)
                 ;-            1
000d8b 0421      NOTE(NDO ,NT4+1 ,2)
000d8c 041c      NOTE(NSI ,NT4+1 ,1)
000d8d 031a      NOTE(NLA ,NT2+1 ,1)
                 ;-            1
000d8e 041a      NOTE(NLA ,NT4+1 ,1)
000d8f 041c      NOTE(NSI ,NT4+1 ,1)
000d90 0421      NOTE(NDO ,NT4+1 ,2)
000d91 0423      NOTE(NRE ,NT4+1 ,2)
                 ;-            1
000d92 0425      NOTE(NMI ,NT4+1 ,2)
000d93 0423      NOTE(NRE ,NT4+1 ,2)
000d94 0421      NOTE(NDO ,NT4+1 ,2)
000d95 041c      NOTE(NSI ,NT4+1 ,1)
                 ;-            1
000d96 021a      NOTE(NLA ,NT1+1 ,1)
                 ;-            1
000d97 031a      NOTE(NLA ,NT2+1 ,1)
                 ;-            1
000d98 0310      NOTE(NP  ,NT2+1 ,1)
                 
000d99 0010      NOTE(0,0,1)
                 
                  ctGimn_UA:
                 
                 ;###############################################################################
                 ;<
000d9a 021a      NOTE(NLA ,NT4-1 ,1)
000d9b 031a      NOTE(NLA ,NT8-1 ,1)
000d9c 031a      NOTE(NLA ,NT8-1 ,1)
000d9d 031a      NOTE(NLA ,NT8-1 ,1)
000d9e 0318      NOTE(NSOL,NT8-1 ,1)
000d9f 031a      NOTE(NLA ,NT8-1 ,1)
000da0 031c      NOTE(NSI ,NT8-1 ,1)
                 ;---         -1
000da1 0221      NOTE(NDO ,NT4-1 ,2)
000da2 0321      NOTE(NDO ,NT8-1 ,2)
000da3 031c      NOTE(NSI ,NT8-1 ,1)
000da4 021a      NOTE(NLA ,NT4-1 ,1)
000da5 0218      NOTE(NSOL,NT4-1 ,1)
                 ;===         -1
000da6 0216      NOTE(NFA ,NT4-1 ,1)
000da7 021a      NOTE(NLA ,NT4-1 ,1)
000da8 0215      NOTE(NMI ,NT4-1 ,1)
000da9 021a      NOTE(NLA ,NT4-1 ,1)
                 ;---         -1
000daa 0213      NOTE(NRE ,NT4-1 ,1)
000dab 0313      NOTE(NRE ,NT8-1 ,1)
000dac 0315      NOTE(NMI ,NT8-1 ,1)
000dad 0216      NOTE(NFA ,NT4-1 ,1)
000dae 0218      NOTE(NSOL,NT4-1 ,1)
                 ;===         -1
000daf 021a      NOTE(NLA ,NT4-1 ,1)
000db0 031a      NOTE(NLA ,NT8-1 ,1)
000db1 031a      NOTE(NLA ,NT8-1 ,1)
000db2 031a      NOTE(NLA ,NT8-1 ,1)
000db3 0318      NOTE(NSOL,NT8-1 ,1)
000db4 031a      NOTE(NLA ,NT8-1 ,1)
000db5 031c      NOTE(NSI ,NT8-1 ,1)
                 ;---         -1
000db6 0221      NOTE(NDO ,NT4-1 ,2)
000db7 0321      NOTE(NDO ,NT8-1 ,2)
000db8 031c      NOTE(NSI ,NT8-1 ,1)
000db9 021a      NOTE(NLA ,NT4-1 ,1)
000dba 0218      NOTE(NSOL,NT4-1 ,1)
                 ;===         -1
000dbb 0216      NOTE(NFA ,NT4-1 ,1)
000dbc 021a      NOTE(NLA ,NT4-1 ,1)
000dbd 0215      NOTE(NMI ,NT4-1 ,1)
000dbe 021a      NOTE(NLA ,NT4-1 ,1)
                 ;---         -1
000dbf 0113      NOTE(NRE ,NT2-1 ,1)
000dc0 0213      NOTE(NRE ,NT4-1 ,1)
000dc1 0210      NOTE(NP  ,NT4-1 ,1)
                 ;===         -1
000dc2 0215      NOTE(NMI ,NT4-1 ,1)
000dc3 0215      NOTE(NMI ,NT4-1 ,1)
000dc4 031a      NOTE(NLA ,NT8-1 ,1)
000dc5 0318      NOTE(NSOL,NT8-1 ,1)
000dc6 0316      NOTE(NFA ,NT8-1 ,1)
000dc7 0315      NOTE(NMI ,NT8-1 ,1)
                 ;---         -1
000dc8 0313      NOTE(NRE ,NT8-1 ,1)
000dc9 0315      NOTE(NMI ,NT8-1 ,1)
000dca 0316      NOTE(NFA ,NT8-1 ,1)
000dcb 0313      NOTE(NRE ,NT8-1 ,1)
000dcc 0215      NOTE(NMI ,NT4-1 ,1)
000dcd 0215      NOTE(NMI ,NT4-1 ,1)
                 ;===         -1
000dce 0216      NOTE(NFA ,NT4-1 ,1)
000dcf 0216      NOTE(NFA ,NT4-1 ,1)
000dd0 0218      NOTE(NSOL,NT4-1 ,1)
000dd1 0218      NOTE(NSOL,NT4-1 ,1)
                 ;---         -1
000dd2 011a      NOTE(NLA ,NT2-1 ,1)
000dd3 021a      NOTE(NLA ,NT4-1 ,1)
000dd4 0210      NOTE(NP  ,NT4-1 ,1)
                 ;===         -1
000dd5 0215      NOTE(NMI ,NT4-1 ,1)
000dd6 0215      NOTE(NMI ,NT4-1 ,1)
000dd7 031a      NOTE(NLA ,NT8-1 ,1)
000dd8 0318      NOTE(NSOL,NT8-1 ,1)
000dd9 0316      NOTE(NFA ,NT8-1 ,1)
000dda 0315      NOTE(NMI ,NT8-1 ,1)
                 ;---         -1
000ddb 0313      NOTE(NRE ,NT8-1 ,1)
000ddc 0315      NOTE(NMI ,NT8-1 ,1)
000ddd 0316      NOTE(NFA ,NT8-1 ,1)
000dde 0313      NOTE(NRE ,NT8-1 ,1)
000ddf 0215      NOTE(NMI ,NT4-1 ,1)
000de0 0215      NOTE(NMI ,NT4-1 ,1)
                 ;===         -1
000de1 0216      NOTE(NFA ,NT4-1 ,1)
000de2 021a      NOTE(NLA ,NT4-1 ,1)
000de3 0215      NOTE(NMI ,NT4-1 ,1)
000de4 021a      NOTE(NLA ,NT4-1 ,1)
                 ;---         -1
000de5 0213      NOTE(NRE ,NT4-1 ,1)
000de6 0313      NOTE(NRE ,NT8-1 ,1)
000de7 0315      NOTE(NMI ,NT8-1 ,1)
000de8 0216      NOTE(NFA ,NT4-1 ,1)
000de9 0218      NOTE(NSOL,NT4-1 ,1)
                 ;===         -1
000dea 0221      NOTE(NDO ,NT4-1 ,2)
000deb 0321      NOTE(NDO ,NT8-1 ,2)
000dec 031c      NOTE(NSI ,NT8-1 ,1)
000ded 0221      NOTE(NDO ,NT4-1 ,2)
000dee 021a      NOTE(NLA ,NT4-1 ,1)
                 ;---         -1
000def 0218      NOTE(NSOL,NT4-1 ,1)
000df0 0218      NOTE(NSOL,NT4-1 ,1)
000df1 0321      NOTE(NDO ,NT8-1 ,2)
000df2 031c      NOTE(NSI ,NT8-1 ,1)
000df3 031a      NOTE(NLA ,NT8-1 ,1)
000df4 0318      NOTE(NSOL,NT8-1 ,1)
                 ;===         -1
000df5 0216      NOTE(NFA ,NT4-1 ,1)
000df6 0216      NOTE(NFA ,NT4-1 ,1)
000df7 0218      NOTE(NSOL,NT4-1 ,1)
000df8 0218      NOTE(NSOL,NT4-1 ,1)
                 ;---         -1
000df9 021a      NOTE(NLA ,NT4-1 ,1)
000dfa 031a      NOTE(NLA ,NT8-1 ,1)
000dfb 0318      NOTE(NSOL,NT8-1 ,1)
000dfc 021a      NOTE(NLA ,NT4-1 ,1)
000dfd 021c      NOTE(NSI ,NT4-1 ,1)
                 ;===         -1
000dfe 0221      NOTE(NDO ,NT4-1 ,2)
000dff 0321      NOTE(NDO ,NT8-1 ,2)
000e00 031c      NOTE(NSI ,NT8-1 ,1)
000e01 0221      NOTE(NDO ,NT4-1 ,2)
000e02 021a      NOTE(NLA ,NT4-1 ,1)
                 ;---         -1
000e03 0218      NOTE(NSOL,NT4-1 ,1)
000e04 0218      NOTE(NSOL,NT4-1 ,1)
000e05 0321      NOTE(NDO ,NT8-1 ,2)
000e06 031c      NOTE(NSI ,NT8-1 ,1)
000e07 031a      NOTE(NLA ,NT8-1 ,1)
000e08 0318      NOTE(NSOL,NT8-1 ,1)
                 ;===         -1
000e09 0216      NOTE(NFA ,NT4-1 ,1)
000e0a 021a      NOTE(NLA ,NT4-1 ,1)
000e0b 0215      NOTE(NMI ,NT4-1 ,1)
000e0c 021a      NOTE(NLA ,NT4-1 ,1)
                 ;---         -1
000e0d 0113      NOTE(NRE ,NT2-1 ,1)
000e0e 0113      NOTE(NRE ,NT2-1 ,1)
                 
                 
000e0f 0010      NOTE(0,0,1)
                 ;>
                 
                 .include  "MoveLists.inc"
                 
                 ;Updated: "2011-04-06" "10:56"
                 ;
                 
                 #define LEFT  1
                 #define RIGHT 0
                 
                 .macro m4Move ;SpeedL,LenL,SpeedR,LenR,Time
                   .if @4<256
                     .if (@1<256) && (@3<256)
                       .db  ((@0&0b1111)<<4)|(@2&0b1111),@1,@3,@4 ;.db rvSpeedLR,LenL,LenR,Time
                     .else
                       .error "m4Move: Distance is big!"
                     .endif
                   .else
                     .error "m4Move: Time is big!"
                   .endif
                 .endmacro
                 
                 .macro m4Rotate ;Left/Right,Speed,Deg,Method
                 
                     .if @2>255
                       .error "m4Rotate: Distance is big!"
                     .endif
                   
                   .if @3==1 ;Method
                     ;< Rotate use 1 Crawler
                     .if @0==(LEFT)  ;Left/Right
                       ;Left
                      .db  ((0&0b1111)<<4)|(@1&0b1111),0,@2,40 ;.db rvSpeedLR,LenL,LenR,Time
                     .else
                       ;Right
                      .db  ((@1&0b1111)<<4)|(0&0b1111),@2,0,40 ;.db rvSpeedLR,LenL,LenR,Time
                     .endif
                     ;> Rotate use 1 Crawler
                   .else
                     ;< Rotate use 2 Crawlers
                     .if @0==(LEFT)  ;Left/Right
                       ;Left
                      .db  ((-@1&0b1111)<<4)|(@1&0b1111),@2/2,@2/2,40 ;.db rvSpeedLR,LenL,LenR,Time
                     .else
                       ;Right
                      .db  ((@1&0b1111)<<4)|(-@1&0b1111),@2/2,@2/2,40 ;.db rvSpeedLR,LenL,LenR,Time
                     .endif
                     ;> Rotate use 2 Crawlers
                   .endif
                   
                   
                 .endmacro
                 
                 
                 
                 ct_RR_45:
                +
                +
                +.if 45 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 1 == 1
                +
                +.if 0 == ( 1 )
                +
MoveLists.inc(33): warning: float->int cast, truncated
MoveLists.inc(54): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e10 1650
000e11 2800     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 5 & 0b1111 ) , 0 , 45 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 40
                +.else 
                +
                +.db ( ( 5 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 45 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 0 , 40
                +.endif 
                +
                +.else 
                +
                +.if 0 == ( 1 )
                +
                     m4Rotate RIGHT ,5,45degT,1 ;Left/Right,Speed,Deg,Method
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e12 0000
000e13 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                     
                 ct_RL_45:
                +
                +
                +.if 45 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 1 == 1
                +
                +.if 1 == ( 1 )
MoveLists.inc(30): warning: float->int cast, truncated
MoveLists.inc(58): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e14 0005
000e15 2816     +
                +.db ( ( 0 & 0b1111 ) << 4 ) | ( 5 & 0b1111 ) , 0 , 45 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 40
                +.else 
                +
                +.db ( ( 5 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 45 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 0 , 40
                +.endif 
                +
                +.else 
                +
                +.if 1 == ( 1 )
                +
                     m4Rotate LEFT,5,45degT,1 ;Left/Right,Speed,Deg,Method
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e16 0000
000e17 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                     
                 ct_RR_90:
                +
                +
                +.if 90 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 1 == 1
                +
                +.if 0 == ( 1 )
                +
MoveLists.inc(33): warning: float->int cast, truncated
MoveLists.inc(62): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e18 2d50
000e19 2800     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 5 & 0b1111 ) , 0 , 90 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 40
                +.else 
                +
                +.db ( ( 5 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 90 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 0 , 40
                +.endif 
                +
                +.else 
                +
                +.if 0 == ( 1 )
                +
                     m4Rotate RIGHT ,5,90degT,1 ;Left/Right,Speed,Deg,Method
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e1a 0000
000e1b 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                     
                 ct_RL_90:
                +
                +
                +.if 90 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 1 == 1
                +
                +.if 1 == ( 1 )
MoveLists.inc(30): warning: float->int cast, truncated
MoveLists.inc(66): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e1c 0005
000e1d 282d     +
                +.db ( ( 0 & 0b1111 ) << 4 ) | ( 5 & 0b1111 ) , 0 , 90 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 40
                +.else 
                +
                +.db ( ( 5 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 90 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 0 , 40
                +.endif 
                +
                +.else 
                +
                +.if 1 == ( 1 )
                +
                     m4Rotate LEFT,5,90degT,1 ;Left/Right,Speed,Deg,Method
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e1e 0000
000e1f 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                     
                 ct_RR_180:
                +
                +
                +.if 180 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 1 == 1
                +
                +.if 0 == ( 1 )
                +
MoveLists.inc(33): warning: float->int cast, truncated
MoveLists.inc(70): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e20 5b50
000e21 2800     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 5 & 0b1111 ) , 0 , 180 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 40
                +.else 
                +
                +.db ( ( 5 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 180 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 0 , 40
                +.endif 
                +
                +.else 
                +
                +.if 0 == ( 1 )
                +
                   m4Rotate RIGHT ,5,180degT,1 ;Left/Right,Speed,Deg,Method
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e22 0000
000e23 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                 
                 ct_RL_180:
                +
                +
                +.if 180 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 1 == 1
                +
                +.if 1 == ( 1 )
MoveLists.inc(30): warning: float->int cast, truncated
MoveLists.inc(74): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e24 0005
000e25 285b     +
                +.db ( ( 0 & 0b1111 ) << 4 ) | ( 5 & 0b1111 ) , 0 , 180 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 40
                +.else 
                +
                +.db ( ( 5 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 180 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 0 , 40
                +.endif 
                +
                +.else 
                +
                +.if 1 == ( 1 )
                +
                     m4Rotate LEFT,5,180degT,1 ;Left/Right,Speed,Deg,Method
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e26 0000
000e27 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                     
                 ct_RR_360_2:
                +
                +
                +.if 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 2 == 1
                +
                +.if 0 == ( 1 )
                +
                +.db ( ( 0 & 0b1111 ) << 4 ) | ( 5 & 0b1111 ) , 0 , 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 40
                +.else 
                +
                +.db ( ( 5 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 0 , 40
MoveLists.inc(43): warning: float->int cast, truncated
MoveLists.inc(78): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
MoveLists.inc(43): warning: float->int cast, truncated
MoveLists.inc(78): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e28 5b5b
000e29 285b     +.endif 
                +
                +.else 
                +
                +.if 0 == ( 1 )
                +
                   m4Rotate RIGHT ,5,360degT,2 ;Left/Right,Speed,Deg,Method
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e2a 0000
000e2b 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                   m4Move 0,0,0,0,0; End Moves
                   
                 ct_SearchFinishMove:
                +
                +
                +.if 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 2 == 1
                +
                +.if 0 == ( 1 )
                +
                +.db ( ( 0 & 0b1111 ) << 4 ) | ( 5 & 0b1111 ) , 0 , 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 40
                +.else 
                +
                +.db ( ( 5 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 0 , 40
MoveLists.inc(43): warning: float->int cast, truncated
MoveLists.inc(82): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
MoveLists.inc(43): warning: float->int cast, truncated
MoveLists.inc(82): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e2c 5b5b
000e2d 285b     +.endif 
                +
                +.else 
                +
                +.if 0 == ( 1 )
                +
                   m4Rotate RIGHT ,5,360degT,2 ;Left/Right,Speed,Deg,Method
                +
                +
                +.if 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 2 == 1
                +
                +.if 0 == ( 1 )
                +
                +.db ( ( 0 & 0b1111 ) << 4 ) | ( 5 & 0b1111 ) , 0 , 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 40
                +.else 
                +
                +.db ( ( 5 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 0 , 40
MoveLists.inc(43): warning: float->int cast, truncated
MoveLists.inc(83): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
MoveLists.inc(43): warning: float->int cast, truncated
MoveLists.inc(83): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e2e 5b5b
000e2f 285b     +.endif 
                +
                +.else 
                +
                +.if 0 == ( 1 )
                +
                   m4Rotate RIGHT  ,5,360degT,2 ;Left/Right,Speed,Deg,Method
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e30 0000
000e31 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                   m4Move 0,0,0,0,0; End Moves
                 
                 
                 ct_SearchMove:
                +
                +.if 255 < 256
                +.if ( 7 * 1000 / 2540 < 256 ) && ( 7 * 1000 / 2540 < 256 )
000e32 0266
000e33 ff02     +.db ( ( 6 & 0b1111 ) << 4 ) | ( 6 & 0b1111 ) , 7 * 1000 / 2540 , 7 * 1000 / 2540 , 255
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move  6,7mm, 6,7mm,255;*2.55s
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e34 0000
000e35 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                     
                 ct_OutLineMoveR:
                +
                +.if 20 < 256
                +.if ( 75 * 1000 / 2540 < 256 ) && ( 75 * 1000 / 2540 < 256 )
000e36 1daa
000e37 141d     +.db ( ( - 6 & 0b1111 ) << 4 ) | ( - 6 & 0b1111 ) , 75 * 1000 / 2540 , 75 * 1000 / 2540 , 20
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move  -6,75mm, -6,75mm,20;*2.55s
                +
                +
                +.if 90 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 1 == 1
                +
                +.if 0 == ( 1 )
                +
MoveLists.inc(33): warning: float->int cast, truncated
MoveLists.inc(93): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e38 2d60
000e39 2800     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 6 & 0b1111 ) , 0 , 90 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 40
                +.else 
                +
                +.db ( ( 6 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 90 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 0 , 40
                +.endif 
                +
                +.else 
                +
                +.if 0 == ( 1 )
                +
                     m4Rotate RIGHT ,6,90degT,1 ;Left/Right,Speed,Deg,Method
                +
                +.if 20 < 256
                +.if ( 60 * 1000 / 2540 < 256 ) && ( 60 * 1000 / 2540 < 256 )
000e3a 1766
000e3b 1417     +.db ( ( 6 & 0b1111 ) << 4 ) | ( 6 & 0b1111 ) , 60 * 1000 / 2540 , 60 * 1000 / 2540 , 20
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move   6,60mm,  6,60mm,20;*2.55s
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e3c 0000
000e3d 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                     
                 ct_OutLineMoveL:
                +
                +.if 20 < 256
                +.if ( 75 * 1000 / 2540 < 256 ) && ( 75 * 1000 / 2540 < 256 )
000e3e 1daa
000e3f 141d     +.db ( ( - 6 & 0b1111 ) << 4 ) | ( - 6 & 0b1111 ) , 75 * 1000 / 2540 , 75 * 1000 / 2540 , 20
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move  -6,75mm, -6,75mm,20;*2.55s
                +
                +
                +.if 90 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 1 == 1
                +
                +.if 1 == ( 1 )
MoveLists.inc(30): warning: float->int cast, truncated
MoveLists.inc(99): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e40 0006
000e41 282d     +
                +.db ( ( 0 & 0b1111 ) << 4 ) | ( 6 & 0b1111 ) , 0 , 90 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 40
                +.else 
                +
                +.db ( ( 6 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 90 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 0 , 40
                +.endif 
                +
                +.else 
                +
                +.if 1 == ( 1 )
                +
                     m4Rotate LEFT ,6,90degT,1 ;Left/Right,Speed,Deg,Method
                +
                +.if 20 < 256
                +.if ( 60 * 1000 / 2540 < 256 ) && ( 60 * 1000 / 2540 < 256 )
000e42 1766
000e43 1417     +.db ( ( 6 & 0b1111 ) << 4 ) | ( 6 & 0b1111 ) , 60 * 1000 / 2540 , 60 * 1000 / 2540 , 20
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move   6,60mm,  6,60mm,20;*2.55s
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e44 0000
000e45 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                 
                 
                 ct_TstMove:
                +
                +.if 20 < 256
                +.if ( 650 * 1000 / 2540 < 256 ) && ( 650 * 1000 / 2540 < 256 )
000e46 ff44
000e47 14ff     +.db ( ( 4 & 0b1111 ) << 4 ) | ( 4 & 0b1111 ) , 650 * 1000 / 2540 , 650 * 1000 / 2540 , 20
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move  4,650mm, 4,650mm,20;*2.55s
                +
                +.if 20 < 256
                +.if ( 650 * 1000 / 2540 < 256 ) && ( 650 * 1000 / 2540 < 256 )
000e48 ff44
000e49 14ff     +.db ( ( 4 & 0b1111 ) << 4 ) | ( 4 & 0b1111 ) , 650 * 1000 / 2540 , 650 * 1000 / 2540 , 20
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move  4,650mm, 4,650mm,20;*2.55s    
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e4a 0000
000e4b 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                     
                 ct_Rotate:
                +
                +
                +.if 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 2 == 1
                +
                +.if 1 == ( 1 )
                +
                +.db ( ( 0 & 0b1111 ) << 4 ) | ( 7 & 0b1111 ) , 0 , 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 40
                +.else 
                +
MoveLists.inc(40): warning: float->int cast, truncated
MoveLists.inc(110): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
MoveLists.inc(40): warning: float->int cast, truncated
MoveLists.inc(110): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e4c 5b97
000e4d 285b     +.db ( ( 7 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 0 , 40
                +.endif 
                +
                +.else 
                +
                +.if 1 == ( 1 )
                +
                     m4Rotate LEFT,7,360degT,2 ;Left/Right,Speed,Deg,Method
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e4e 0000
000e4f 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                     
                 ct_Rotate2R:
                +
                +
                +.if 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 2 == 1
                +
                +.if 0 == ( 1 )
                +
                +.db ( ( 0 & 0b1111 ) << 4 ) | ( 6 & 0b1111 ) , 0 , 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 40
                +.else 
                +
                +.db ( ( 6 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 0 , 40
MoveLists.inc(43): warning: float->int cast, truncated
MoveLists.inc(114): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
MoveLists.inc(43): warning: float->int cast, truncated
MoveLists.inc(114): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e50 5b6a
000e51 285b     +.endif 
                +
                +.else 
                +
                +.if 0 == ( 1 )
                +
                     m4Rotate RIGHT,6,360degT,2 ;Left/Right,Speed,Deg,Method
                +
                +
                +.if 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 2 == 1
                +
                +.if 0 == ( 1 )
                +
                +.db ( ( 0 & 0b1111 ) << 4 ) | ( 5 & 0b1111 ) , 0 , 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 40
                +.else 
                +
                +.db ( ( 5 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 0 , 40
MoveLists.inc(43): warning: float->int cast, truncated
MoveLists.inc(115): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
MoveLists.inc(43): warning: float->int cast, truncated
MoveLists.inc(115): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e52 5b5b
000e53 285b     +.endif 
                +
                +.else 
                +
                +.if 0 == ( 1 )
                +
                     m4Rotate RIGHT ,5,360degT,2 ;Left/Right,Speed,Deg,Method
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e54 0000
000e55 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                     
                 ct_Rotate2L:
                +
                +
                +.if 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 2 == 1
                +
                +.if 1 == ( 1 )
                +
                +.db ( ( 0 & 0b1111 ) << 4 ) | ( 6 & 0b1111 ) , 0 , 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 40
                +.else 
                +
MoveLists.inc(40): warning: float->int cast, truncated
MoveLists.inc(119): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
MoveLists.inc(40): warning: float->int cast, truncated
MoveLists.inc(119): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e56 5ba6
000e57 285b     +.db ( ( 6 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 0 , 40
                +.endif 
                +
                +.else 
                +
                +.if 1 == ( 1 )
                +
                     m4Rotate LEFT ,6,360degT,2 ;Left/Right,Speed,Deg,Method
                +
                +
                +.if 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 2 == 1
                +
                +.if 1 == ( 1 )
                +
                +.db ( ( 0 & 0b1111 ) << 4 ) | ( 5 & 0b1111 ) , 0 , 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 40
                +.else 
                +
MoveLists.inc(40): warning: float->int cast, truncated
MoveLists.inc(120): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
MoveLists.inc(40): warning: float->int cast, truncated
MoveLists.inc(120): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e58 5bb5
000e59 285b     +.db ( ( 5 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 360 * 2 * 3.1415 * 29 * 2540 / ( 2540 * 360 ) , 0 , 40
                +.endif 
                +
                +.else 
                +
                +.if 1 == ( 1 )
                +
                     m4Rotate LEFT,5,360degT,2 ;Left/Right,Speed,Deg,Method
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e5a 0000
000e5b 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                     
                 ct_MoveCover:
                +
                +.if 20 < 256
                +.if ( 150 * 1000 / 2540 < 256 ) && ( 150 * 1000 / 2540 < 256 )
000e5c 3b77
000e5d 143b     +.db ( ( 7 & 0b1111 ) << 4 ) | ( 7 & 0b1111 ) , 150 * 1000 / 2540 , 150 * 1000 / 2540 , 20
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move  7,150mm, 7,150mm,20;*2.55s
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e5e 0000
000e5f 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                 
                 
                     
                 ;< MoveList for ADC calibration. Graund detection
                 #define mSpeed(SpeedL,SpeedR) ((SpeedL&0b1111)<<4)|(SpeedR&0b1111)  ; rvSpeedLR
                 ctGNDMoveList:
                 ;  Speed  L  R Crawlers
000e60 b55b        .db mSpeed( 5,-5),mSpeed(-5, 5)
000e61 dd33        .db mSpeed( 3, 3),mSpeed(-3,-3)
000e62 b5b5        .db mSpeed(-5, 5),mSpeed(-5, 5)
000e63 0000        .db mSpeed( 0, 0),mSpeed( 0, 0) ; Stop marker
                 ;> MoveList for ADC calibration. Graund detection
                 
                 ;<  таблица поворотов танка в зависимости от ctrnjhf
                   ct_Sec_0:
                +
                +
                +.if ( 50 * ( 7 - 0 ) ) * 2 * 3.1415 * 29 * 2540 * 83000 / ( 2540 * 360 * 150000 ) / 8 > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 2 == 1
                +
                +.if 0 == ( 1 )
                +
                +.db ( ( 0 & 0b1111 ) << 4 ) | ( 7 & 0b1111 ) , 0 , ( 50 * ( 7 - 0 ) ) * 2 * 3.1415 * 29 * 2540 * 83000 / ( 2540 * 360 * 150000 ) / 8 , 40
                +.else 
                +
                +.db ( ( 7 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , ( 50 * ( 7 - 0 ) ) * 2 * 3.1415 * 29 * 2540 * 83000 / ( 2540 * 360 * 150000 ) / 8 , 0 , 40
MoveLists.inc(43): warning: float->int cast, truncated
MoveLists.inc(141): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
MoveLists.inc(43): warning: float->int cast, truncated
MoveLists.inc(141): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e64 0679
000e65 2806     +.endif 
                +
                +.else 
                +
                +.if 0 == ( 1 )
                +
                     m4Rotate RIGHT,7,(Alf*(7-0))degTM/8,2 ;Left/Right,Speed,Deg,Method
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e66 0000
000e67 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                   ct_Sec_1:
                +
                +
                +.if ( 50 * ( 7 - 1 ) ) * 2 * 3.1415 * 29 * 2540 * 83000 / ( 2540 * 360 * 150000 ) / 8 > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 2 == 1
                +
                +.if 0 == ( 1 )
                +
                +.db ( ( 0 & 0b1111 ) << 4 ) | ( 7 & 0b1111 ) , 0 , ( 50 * ( 7 - 1 ) ) * 2 * 3.1415 * 29 * 2540 * 83000 / ( 2540 * 360 * 150000 ) / 8 , 40
                +.else 
                +
                +.db ( ( 7 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , ( 50 * ( 7 - 1 ) ) * 2 * 3.1415 * 29 * 2540 * 83000 / ( 2540 * 360 * 150000 ) / 8 , 0 , 40
MoveLists.inc(43): warning: float->int cast, truncated
MoveLists.inc(144): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
MoveLists.inc(43): warning: float->int cast, truncated
MoveLists.inc(144): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e68 0579
000e69 2805     +.endif 
                +
                +.else 
                +
                +.if 0 == ( 1 )
                +
                     m4Rotate RIGHT,7,(Alf*(7-1))degTM/8,2 ;Left/Right,Speed,Deg,Method
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e6a 0000
000e6b 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                   ct_Sec_2:
                +
                +
                +.if ( 50 * ( 7 - 2 ) ) * 2 * 3.1415 * 29 * 2540 * 83000 / ( 2540 * 360 * 150000 ) / 8 > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 2 == 1
                +
                +.if 0 == ( 1 )
                +
                +.db ( ( 0 & 0b1111 ) << 4 ) | ( 7 & 0b1111 ) , 0 , ( 50 * ( 7 - 2 ) ) * 2 * 3.1415 * 29 * 2540 * 83000 / ( 2540 * 360 * 150000 ) / 8 , 40
                +.else 
                +
                +.db ( ( 7 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , ( 50 * ( 7 - 2 ) ) * 2 * 3.1415 * 29 * 2540 * 83000 / ( 2540 * 360 * 150000 ) / 8 , 0 , 40
MoveLists.inc(43): warning: float->int cast, truncated
MoveLists.inc(147): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
MoveLists.inc(43): warning: float->int cast, truncated
MoveLists.inc(147): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e6c 0479
000e6d 2804     +.endif 
                +
                +.else 
                +
                +.if 0 == ( 1 )
                +
                     m4Rotate RIGHT,7,(Alf*(7-2))degTM/8,2 ;Left/Right,Speed,Deg,Method
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e6e 0000
000e6f 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                   ct_Sec_3:
                     ;No rotate
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e70 0000
000e71 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                     
                   ct_Sec_4:
                     ;No rotate
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e72 0000
000e73 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                   ct_Sec_5:   
                +
                +
                +.if ( 50 * ( 7 - 2 ) ) * 2 * 3.1415 * 29 * 2540 * 83000 / ( 2540 * 360 * 150000 ) / 8 > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 2 == 1
                +
                +.if 1 == ( 1 )
                +
                +.db ( ( 0 & 0b1111 ) << 4 ) | ( 7 & 0b1111 ) , 0 , ( 50 * ( 7 - 2 ) ) * 2 * 3.1415 * 29 * 2540 * 83000 / ( 2540 * 360 * 150000 ) / 8 , 40
                +.else 
                +
MoveLists.inc(40): warning: float->int cast, truncated
MoveLists.inc(157): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
MoveLists.inc(40): warning: float->int cast, truncated
MoveLists.inc(157): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e74 0497
000e75 2804     +.db ( ( 7 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , ( 50 * ( 7 - 2 ) ) * 2 * 3.1415 * 29 * 2540 * 83000 / ( 2540 * 360 * 150000 ) / 8 , 0 , 40
                +.endif 
                +
                +.else 
                +
                +.if 1 == ( 1 )
                +
                     m4Rotate LEFT,7,(Alf*(7-2))degTM/8,2 ;Left/Right,Speed,Deg,Method
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e76 0000
000e77 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                   ct_Sec_6:   
                +
                +
                +.if ( 50 * ( 7 - 1 ) ) * 2 * 3.1415 * 29 * 2540 * 83000 / ( 2540 * 360 * 150000 ) / 8 > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 2 == 1
                +
                +.if 1 == ( 1 )
                +
                +.db ( ( 0 & 0b1111 ) << 4 ) | ( 7 & 0b1111 ) , 0 , ( 50 * ( 7 - 1 ) ) * 2 * 3.1415 * 29 * 2540 * 83000 / ( 2540 * 360 * 150000 ) / 8 , 40
                +.else 
                +
MoveLists.inc(40): warning: float->int cast, truncated
MoveLists.inc(160): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
MoveLists.inc(40): warning: float->int cast, truncated
MoveLists.inc(160): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e78 0597
000e79 2805     +.db ( ( 7 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , ( 50 * ( 7 - 1 ) ) * 2 * 3.1415 * 29 * 2540 * 83000 / ( 2540 * 360 * 150000 ) / 8 , 0 , 40
                +.endif 
                +
                +.else 
                +
                +.if 1 == ( 1 )
                +
                     m4Rotate LEFT,7,(Alf*(7-1))degTM/8,2 ;Left/Right,Speed,Deg,Method
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e7a 0000
000e7b 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                   ct_Sec_7:   
                +
                +
                +.if ( 50 * ( 7 - 0 ) ) * 2 * 3.1415 * 29 * 2540 * 83000 / ( 2540 * 360 * 150000 ) / 8 > 255
                +.error "m4Rotate: Distance is big!"
                +.endif 
                +
                +.if 2 == 1
                +
                +.if 1 == ( 1 )
                +
                +.db ( ( 0 & 0b1111 ) << 4 ) | ( 7 & 0b1111 ) , 0 , ( 50 * ( 7 - 0 ) ) * 2 * 3.1415 * 29 * 2540 * 83000 / ( 2540 * 360 * 150000 ) / 8 , 40
                +.else 
                +
MoveLists.inc(40): warning: float->int cast, truncated
MoveLists.inc(163): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
MoveLists.inc(40): warning: float->int cast, truncated
MoveLists.inc(163): macro 'm4Rotate' called here
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e7c 0697
000e7d 2806     +.db ( ( 7 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , ( 50 * ( 7 - 0 ) ) * 2 * 3.1415 * 29 * 2540 * 83000 / ( 2540 * 360 * 150000 ) / 8 , 0 , 40
                +.endif 
                +
                +.else 
                +
                +.if 1 == ( 1 )
                +
                     m4Rotate LEFT,7,(Alf*(7-0))degTM/8,2 ;Left/Right,Speed,Deg,Method
                +
                +.if 0 < 256
                +.if ( 0 < 256 ) && ( 0 < 256 )
000e7e 0000
000e7f 0000     +.db ( ( 0 & 0b1111 ) << 4 ) | ( 0 & 0b1111 ) , 0 , 0 , 0
                +.else 
                +.error "m4Move: Distance is big!"
                +.endif 
                +.else 
                     m4Move 0,0,0,0,0; End Moves
                     
                 ct_List_Sec:
000e80 1cc8        .dw ct_Sec_0<<1
000e81 1cd0        .dw ct_Sec_1<<1
000e82 1cd8        .dw ct_Sec_2<<1
000e83 1ce0        .dw ct_Sec_3<<1
000e84 1ce4        .dw ct_Sec_4<<1
000e85 1ce8        .dw ct_Sec_5<<1
000e86 1cf0        .dw ct_Sec_6<<1
000e87 1cf8        .dw ct_Sec_7<<1
                   
                 ;>
                 
                 
                 ct_Servo4Scan:
000e88 00dd        .dw SERVOMIN                           ;0
000e89 0103        .dw (SERVOMIN+(SERVOMIN+SERVOMID)/2)/2 ;1
000e8a 012a        .dw (SERVOMIN+SERVOMID)/2              ;2
000e8b 0150        .dw (SERVOMID+(SERVOMIN+SERVOMID)/2)/2 ;3
                 ; .dw SERVOMID                           ;-
000e8c 019d        .dw (SERVOMID+(SERVOMAX+SERVOMID)/2)/2 ;4
000e8d 01c3        .dw (SERVOMAX+SERVOMID)/2              ;5
000e8e 01e9        .dw (SERVOMAX+(SERVOMAX+SERVOMID)/2)/2 ;6
000e8f 0210        .dw SERVOMAX                           ;7
                   ;---
000e90 0177        .dw SERVOMID                           ;8
MoveLists.inc(191): warning: float->int cast, truncated
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e91 0091        .dw RELOADT1*(SERVOINIT-75Deg)/20000   ;9   MAX RIGHT
MoveLists.inc(192): warning: float->int cast, truncated
TankDemo.asm(1871): 'MoveLists.inc' included form here
000e92 025c        .dw RELOADT1*(SERVOINIT+75Deg)/20000   ;10  MAX LEFT
                 
                 
                 
                 ;< Reklama
                   ListRekPage:
000e93 1d46        .dw t_Rek_P0<<1
000e94 1d56        .dw t_Rek_P1<<1
000e95 1d66        .dw t_Rek_P2<<1
000e96 1d76        .dw t_Rek_P3<<1
000e97 1d86        .dw t_Rek_P4<<1
000e98 1d96        .dw t_Rek_P5<<1
000e99 1da6        .dw t_Rek_P6<<1
000e9a 1db6        .dw t_Rek_P7<<1
                 
000e9b 1dc6        .dw t_Rek_P8<<1
000e9c 1dd6        .dw t_Rek_P9<<1
000e9d 1de6        .dw t_Rek_PA<<1
000e9e 1df6        .dw t_Rek_PB<<1
000e9f 1e06        .dw t_Rek_PC<<1
000ea0 1e16        .dw t_Rek_PD<<1
000ea1 1e26        .dw t_Rek_PE<<1
000ea2 1e36        .dw t_Rek_PF<<1
                 
                   ;-------------------------+
                                ;|01234567| ;|
000ea3 eecf
000ea4 f5e4
000ea5 e4ee
000ea6 21e8        t_Rek_P0: .db "Подходи!" ;|
000ea7 e5cd
000ea8 f020
000ea9 e1ee
000eaa e9e5                  .db "Не робей" ;|
                   ;-------------------------+
                   ;-------------------------+
                                ;|01234567| ;|
000eab 20c0
000eac eecf
000ead eee3
000eae e0e4        t_Rek_P1: .db "А Погода" ;|
000eaf eef5
000eb0 eef0
000eb1 e0f8
000eb2 3fff                  .db "хорошая?" ;|
                   ;-------------------------+
                   ;-------------------------+
                                ;|01234567| ;|
000eb3 3d2d
000eb4 6154
000eb5 6b6e
000eb6 2d3d        t_Rek_P2: .db "-=Tank=-" ;|
000eb7 6556
000eb8 2e72
000eb9 3020
000eba 312e                  .db "Ver. 0.1" ;|
                   ;-------------------------+
                   ;-------------------------+
                                ;|01234567| ;|
000ebb 5452
000ebc 534f
000ebd 6220
000ebe 2079        t_Rek_P3: .db "RTOS by " ;|
000ebf 5320
000ec0 415f
000ec1 656c
000ec2 2078                  .db " S_Alex " ;|
                   ;-------------------------+
                   ;-------------------------+
                                ;|01234567| ;|
000ec3 2020
000ec4 4350
000ec5 2042
000ec6 2020        t_Rek_P4: .db "  PCB   " ;|
000ec7 704f
000ec8 6e65
000ec9 7953
000eca 2073                  .db "OpenSys " ;|
                   ;-------------------------+
                   ;-------------------------+
                                ;|01234567| ;|
000ecb e5d2
000ecc 2eeb
000ecd 3530
000ece 3235        t_Rek_P5: .db "Тел.0552" ;|
000ecf 3320
000ed0 3632
000ed1 3339
000ed2 2037                  .db " 326937 " ;|
                   ;-------------------------+
                   ;-------------------------+
                                ;|01234567| ;|
000ed3 2020
000ed4 cdd5
000ed5 d3d2
000ed6 2020        t_Rek_P6: .db "  ХНТУ  " ;|
000ed7 e0ca
000ed8 e5f4
000ed9 2ee4
000eda d2ca                  .db "Кафед.КТ" ;|
                   ;-------------------------+
                   ;-------------------------+
                                ;|01234567| ;|
000edb 3fc0
000edc d720
000edd e3e5
000ede 20ee        t_Rek_P7: .db "А? Чего " ;|
000edf ecf1
000ee0 f2ee
000ee1 e8f0
000ee2 3fec                  .db "смотрим?" ;|
                   ;-------------------------+
                   ;-------------------------+
                                ;|01234567| ;|
000ee3 c420
000ee4 f2e5
000ee5 ecff
000ee6 2020        t_Rek_P8: .db " Детям  " ;|
000ee7 2033
000ee8 eee4
000ee9 3820
000eea 2030                  .db "3 до 80 " ;|
                   ;-------------------------+
                   ;-------------------------+
                                ;|01234567| ;|
000eeb f3c1
000eec fce4
000eed e5f2
000eee 2020        t_Rek_P9: .db "Будьте  " ;|
000eef c720
000ef0 cec4
000ef1 ced0
000ef2 dbc2                  .db " ЗДОРОВЫ" ;|
                   ;-------------------------+
                   ;-------------------------+
                                ;|01234567| ;|
000ef3 e0c7
000ef4 eef5
000ef5 e8e4
000ef6 e5f2        t_Rek_PA: .db "Заходите" ;|
000ef7 f1e5
000ef8 e8eb
000ef9 f720
000efa eef2                  .db "если что" ;|
                   ;-------------------------+
                   ;-------------------------+
                                ;|01234567| ;|
000efb e5d0
000efc e5e1
000efd eeed
000efe 20ea        t_Rek_PB: .db "Ребенок " ;|
000eff eaf1
000f00 f7f3
000f01 e5e0
000f02 3ff2                  .db "скучает?" ;|
                   ;-------------------------+
                   ;-------------------------+
                                ;|01234567| ;|
000f03 e8d7
000f04 f2f1
000f05 f2ee
000f06 2de0        t_Rek_PC: .db "Чистота-" ;|
000f07 c4c7
000f08 d0ce
000f09 c2ce
000f0a c5dc                  .db "ЗДОРОВЬЕ" ;|
                   ;-------------------------+
                   ;-------------------------+
                                ;|01234567| ;|
000f0b 3d2d
000f0c 6544
000f0d 6f6d
000f0e 2d3d        t_Rek_PD: .db "-=Demo=-" ;|
000f0f 2020
000f10 4f4d
000f11 4544
000f12 2020                  .db "  MODE  " ;|
                   ;-------------------------+
                   ;-------------------------+
                                ;|01234567| ;|
000f13 eed1
000f14 ebe1
000f15 e4fe
000f16 e9e0        t_Rek_PE: .db "Соблюдай" ;|
000f17 e8d7
000f18 f2f1
000f19 f2ee
000f1a 2ef3                  .db "Чистоту." ;|
                   ;-------------------------+
                   ;-------------------------+
                                ;|01234567| ;|
000f1b 4920
000f1c 4c20
000f1d 564f
000f1e 2045        t_Rek_PF: .db " I LOVE " ;|
000f1f 3d2d
000f20 5641
000f21 3d52
000f22 202d                  .db "-=AVR=- " ;|
                   ;-------------------------+
                 ;> Reklama
                 
                 ;< Strings
                 ;--------------------------+
                  sz_Init_GND_OK:          ;|
                               ;|01234567| ;|
000f23 4720
000f24 4152
000f25 4e55
000f26 2044                 .db " GRAUND " ;|
000f27 6153
000f28 6576
000f29 2064
000f2a 4b4f                 .db "Saved OK" ;|
                 ;--------------------------+
                 ;--------------------------+
                  sz_ButtonLSFM_1:         ;|
                               ;|01234567| ;|
000f2b 4253
000f2c 2034
000f2d 4e47
000f2e 2044                 .db "SB4 GND " ;|
000f2f 4253
000f30 2032
000f31 4d46
000f32 534c                 .db "SB2 FMLS" ;|
                 ;--------------------------+
                 ;--------------------------+
                  sz_ButtonLSFM_2:         ;|
                               ;|01234567| ;|
000f33 4253
000f34 2033
000f35 4f47
000f36 2021                 .db "SB3 GO! " ;|
000f37 4720
000f38 214f
000f39 4720
000f3a 214f                 .db " GO! GO!" ;|
                 ;--------------------------+
                 ;--------------------------+
                  sz_Init_FM_LS_OK:        ;|
                               ;|01234567| ;|
000f3b 4620
000f3c 204d
000f3d 4c20
000f3e 2053                 .db " FM  LS " ;|
000f3f 6153
000f40 6576
000f41 2064
000f42 4b4f                 .db "Saved OK" ;|
                 ;--------------------------+
                 
                 ;> Strings
                 
                 
                 .include "LCD_RecodeTable.asm"
                 
                 ReCode_ANSI:
                 
                 ;< HD44780-based Character-LCD
000f43 ffee
000f44 8382
000f45 8584
000f46 8786
000f47 8988
000f48 8b8a
000f49 8d8c
000f4a 8f8e      L080h: .db  0xEE,0xFF,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F
000f4b 9190
000f4c 9392
000f4d 9594
000f4e 9796
000f4f 9998
000f50 9b9a
000f51 9d9c
000f52 9f9e      L090h: .db  0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F
000f53 a1a0
000f54 a3a2
000f55 a5a4
000f56 a7a6
000f57 a9a8
000f58 abaa
000f59 adac
000f5a afae      L0a0h: .db  0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF
000f5b b1b0
000f5c b3b2
000f5d b5b4
000f5e b7b6
000f5f b9b8
000f60 bbba
000f61 bdbc
000f62 bfbe      L0b0h: .db  0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF
                 
000f63 a041
000f64 a142
000f65 45e0
000f66 a4a3      L0c0h: .db  "A",$A0,"B",$A1,$E0,"E",$A3,$A4
000f67 a6a5
000f68 a74b
000f69 484d
000f6a a84f      L0c8h: .db  $A5,$A6,"K",$A7,"M","H","O",$A8
000f6b 4350
000f6c a954
000f6d 58aa
000f6e abe1      L0d0h: .db  "P","C","T",$A9,$AA,"X",$E1,$AB
000f6f e2ac
000f70 aead
000f71 af62
000f72 b1b0      L0d8h: .db  $AC,$E2,$AD,$AE,"b",$AF,$B0,$B1
000f73 b261
000f74 b4b3
000f75 65e3
000f76 b7b6      L0e0h: .db  "a",$B2,$B3,$B4,$E3,"e",$B6,$B7
000f77 b9b8
000f78 bbba
000f79 bdbc
000f7a be6f      L0e8h: .db  $B8,$B9,$BA,$BB,$BC,$BD,"o",$BE
000f7b 6370
000f7c 79bf
000f7d 78e4
000f7e c0e5      L0f0h: .db  "p","c",$BF,"y",$E4,"x",$E5,$C0
000f7f e6c1
000f80 c3c2
000f81 c5c4
000f82 c7c6      L0f8h: .db  $C1,$E6,$C2,$C3,$C4,$C5,$C6,$C7
                 ;> HD44780-based Character-LCD
                   #message "+--------------------+"
                 #ifndef DBG
                   #message "|  Info: Release...  |"
                 #else
                 #endif
                   #message "+--------------------+"
                 
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega64 register use summary:
r0 :   0 r1 :   0 r2 :   7 r3 :  67 r4 :   0 r5 :   0 r6 :  22 r7 :   4 
r8 :   0 r9 :   5 r10:   4 r11:   2 r12:   2 r13:   2 r14:   2 r15:   2 
r16: 928 r17: 321 r18:  60 r19:  53 r20:  35 r21:  10 r22:  45 r23:  46 
r24:  24 r25:  28 r26:  47 r27:  48 r28:  83 r29:  70 r30:  87 r31:  73 
x  :  11 y  :  69 z  :  56 
Registers used: 30 out of 35 (85.7%)

ATmega64 instruction use summary:
.lds  :   0 .sts  :   0 adc   :  15 add   :  23 adiw  :  15 and   :   3 
andi  :  39 asr   :   0 bclr  :   0 bld   :  13 brbc  :   0 brbs  :   0 
brcc  :   4 brcs  :   2 break :   0 breq  :  14 brge  :   0 brhc  :   1 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  17 brlt  :   0 brmi  :   0 
brne  :  90 brpl  :   0 brsh  :  12 brtc  :   3 brts  :   3 brvc  :   0 
brvs  :   0 bset  :   0 bst   :  12 call  :   1 cbi   :  47 cbr   :  45 
clc   :   0 clh   :   0 cli   :   5 cln   :   0 clr   :  24 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   3 cp    :  24 cpc   :   6 
cpi   :  47 cpse  :   2 dec   :  34 eor   :  16 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   1 ijmp  :   1 in    :  59 inc   :  12 jmp   :   0 
ld    :  21 ldd   :  21 ldi   : 467 lds   : 131 lpm   :  32 lsl   :  14 
lsr   :   8 mov   :  29 movw  :   0 mul   :   0 muls  :   0 mulsu :   0 
neg   :   2 nop   :   5 or    :  13 ori   :  47 out   :  62 pop   : 137 
push  : 137 rcall : 218 ret   : 134 reti  :  40 rjmp  :  96 rol   :   6 
ror   :  15 sbc   :   4 sbci  :   1 sbi   :  37 sbic  :   2 sbis  :   0 
sbiw  :   3 sbr   :  10 sbrc  :  43 sbrs  :  18 sec   :   0 seh   :   0 
sei   :   1 sen   :   0 ser   :   6 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   0 st    :  54 std   :  14 sts   : 193 
sub   :   9 subi  :  21 swap  :  16 tst   :  12 wdr   :   0 
Instructions used: 70 out of 113 (61.9%)

ATmega64 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x001f06   5982   1890   7872   65536  12.0%
[.dseg] 0x000100 0x0001cd      0    184    184    4096   4.5%
[.eseg] 0x000010 0x00001c      0     12     12    2048   0.6%

Assembly complete, 0 errors, 43 warnings
